{"version":3,"file":"index.js","sources":["../../src/plugins/loopMapPlugin.ts","../../src/plugins/wrapJsxExpressionPlugin.ts","../../src/index.ts"],"sourcesContent":["import { NodePath } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\nexport const loopMapPlugin = declare((api) => {\n  api.assertVersion(7);\n  return {\n    visitor: {\n      Program(path, state) {\n        const filename = state.filename || \"\";\n\n        // Skip transforming files from Veltra's own source or installed package\n        if (\n          filename.includes(\"/veltra-app/\") ||\n          filename.includes(\"\\\\veltra-app\\\\\") || // local dev\n          filename.includes(\"/node_modules/@veltra/app/\") ||\n          filename.includes(\"\\\\node_modules\\\\@veltra\\\\app\\\\\") // package\n        ) {\n          return;\n        }\n\n        let hasLoop = false;\n\n        path.get(\"body\").forEach((child) => {\n          if (\n            child.isImportDeclaration() &&\n            child.node.source.value === \"@veltra/app\"\n          ) {\n            child.node.specifiers.forEach((spec) => {\n              if (t.isImportSpecifier(spec)) {\n                const imported = spec.imported;\n                if (t.isIdentifier(imported)) {\n                  if (imported.name === \"loop\") hasLoop = true;\n                }\n              }\n            });\n          }\n        });\n\n        const newImports: t.ImportSpecifier[] = [];\n        if (!hasLoop)\n          newImports.push(\n            t.importSpecifier(t.identifier(\"loop\"), t.identifier(\"loop\"))\n          );\n\n        if (newImports.length) {\n          const importDecl = t.importDeclaration(\n            newImports,\n            t.stringLiteral(\"@veltra/app\")\n          );\n          path.unshiftContainer(\"body\", importDecl);\n        }\n      },\n\n      JSXExpressionContainer(path) {\n        const expr = path.get(\"expression\");\n\n        function transformMap(\n          exprPath: NodePath<t.Expression | t.JSXEmptyExpression>\n        ): t.CallExpression | null {\n          const node = exprPath.node;\n          if (\n            t.isCallExpression(node) &&\n            t.isMemberExpression(node.callee) &&\n            t.isIdentifier(node.callee.property) &&\n            node.callee.property.name === \"map\"\n          ) {\n            const mapFn = node.arguments[0];\n            const arrExpr = node.callee.object;\n\n            if (\n              t.isArrowFunctionExpression(mapFn) &&\n              mapFn.params.length >= 2\n            ) {\n              const indexParam = mapFn.params[1];\n              if (t.isIdentifier(indexParam)) {\n                t.traverseFast(mapFn.body, (n) => {\n                  if (t.isIdentifier(n) && n.name === indexParam.name) {\n                    const memberExpr = t.memberExpression(\n                      t.identifier(indexParam.name),\n                      t.identifier(\"value\")\n                    );\n                    Object.assign(n, memberExpr);\n                  }\n                });\n              }\n            }\n\n            return t.callExpression(\n              t.memberExpression(\n                t.callExpression(t.identifier(\"loop\"), [\n                  t.arrowFunctionExpression([], arrExpr),\n                ]),\n                t.identifier(\"each\")\n              ),\n              [mapFn as t.Expression]\n            );\n          }\n          return null;\n        }\n\n        function handleExpression(\n          exprPath: NodePath<t.Expression | t.JSXEmptyExpression>\n        ) {\n          const node = exprPath.node;\n\n          if (t.isLogicalExpression(node)) {\n            const right = exprPath.get(\"right\") as NodePath<\n              t.Expression | t.JSXEmptyExpression\n            >;\n            const transformedRight = transformMap(right);\n            if (transformedRight) {\n              right.replaceWith(transformedRight);\n            }\n          } else if (t.isConditionalExpression(node)) {\n            const consequent = exprPath.get(\"consequent\") as NodePath<\n              t.Expression | t.JSXEmptyExpression\n            >;\n            const alternate = exprPath.get(\"alternate\") as NodePath<\n              t.Expression | t.JSXEmptyExpression\n            >;\n\n            const transformedCons = transformMap(consequent);\n            const transformedAlt = transformMap(alternate);\n\n            if (transformedCons) {\n              consequent.replaceWith(transformedCons);\n            }\n            if (transformedAlt) {\n              alternate.replaceWith(transformedAlt);\n            }\n          } else {\n            const transformed = transformMap(exprPath);\n            if (transformed) {\n              exprPath.replaceWith(transformed);\n            }\n          }\n        }\n\n        handleExpression(expr);\n      },\n    },\n  };\n});\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\n// Second plugin: Wrap every JSX expression in arrow function\nexport const wrapJSXExpressionsPlugin = declare((api) => {\n  api.assertVersion(7);\n  return {\n    visitor: {\n      JSXExpressionContainer(path) {\n        const expr = path.get(\"expression\");\n\n        // Skip wrapping if it's an empty expression (like in fragments or empty slots)\n        if (t.isJSXEmptyExpression(expr.node)) return;\n\n        path.node.expression = t.arrowFunctionExpression([], expr.node);\n      },\n    },\n  };\n});\n","import { TransformOptions, ConfigAPI } from \"@babel/core\";\n// @ts-ignore\nimport babelReactPlugin from \"@babel/preset-react\";\nimport { loopMapPlugin, wrapJSXExpressionsPlugin } from \"./plugins\";\n\n// Main preset function\nexport default function babelPresetVeltra(api: ConfigAPI): TransformOptions {\n  api.assertVersion(7);\n\n  return {\n    presets: [\n      [\n        babelReactPlugin,\n        {\n          runtime: \"automatic\",\n          importSource: \"@veltra/app\",\n        },\n      ],\n    ],\n    plugins: [loopMapPlugin, wrapJSXExpressionsPlugin],\n  };\n}\n"],"names":["loopMapPlugin","declare","api","path","state","filename","hasLoop","child","spec","t","imported","newImports","importDecl","expr","transformMap","exprPath","node","mapFn","arrExpr","indexParam","n","memberExpr","handleExpression","right","transformedRight","consequent","alternate","transformedCons","transformedAlt","transformed","wrapJSXExpressionsPlugin","babelPresetVeltra","babelReactPlugin"],"mappings":"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"}