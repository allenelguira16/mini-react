{"version":3,"file":"index.js","sources":["../../src/plugins/log-jsx-plugin.ts","../../src/plugins/loop-auto-wrap-plugin.ts","../../src/plugins/loop-map-plugin.ts","../../src/plugins/loop-memo-plugin.ts","../../src/plugins/suspense-wrap-plugin.ts","../../src/plugins/wrap-jsx-expression-plugin.ts","../../src/index.ts"],"sourcesContent":["import { NodePath } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\n/**\n * babel plugin to log jsx\n *\n * @param api - The babel api.\n * @returns The babel options.\n */\nexport const logJsxPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    visitor: {\n      Program(path, state) {\n        const filename = state.filename || \"\";\n\n        // Skip Veltra internal or installed files\n        if (\n          filename.includes(\"/veltra-router/\") ||\n          filename.includes(\"\\\\veltra-router\\\\\") ||\n          filename.includes(\"/veltra-app/\") ||\n          filename.includes(\"\\\\veltra-app\\\\\") ||\n          filename.includes(\"/node_modules/@veltra/app/\") ||\n          filename.includes(\"\\\\node_modules\\\\@veltra\\\\app\\\\\")\n        ) {\n          return;\n        }\n\n        let hasLogJsx = false;\n\n        // Check existing imports\n        path.get(\"body\").forEach((child) => {\n          if (child.isImportDeclaration() && child.node.source.value === \"@veltra/app\") {\n            child.node.specifiers.forEach((spec) => {\n              if (t.isImportSpecifier(spec)) {\n                const imported = spec.imported;\n                if (t.isIdentifier(imported) && imported.name === \"logJsx\") {\n                  hasLogJsx = true;\n                }\n              }\n            });\n          }\n        });\n\n        // Insert import if missing\n        if (!hasLogJsx) {\n          const importDecl = t.importDeclaration(\n            [t.importSpecifier(t.identifier(\"logJsx\"), t.identifier(\"logJsx\"))],\n            t.stringLiteral(\"@veltra/app\"),\n          );\n          path.unshiftContainer(\"body\", importDecl);\n        }\n      },\n\n      CallExpression(path: NodePath<t.CallExpression>) {\n        const callee = path.get(\"callee\");\n\n        // Detect console.* calls\n        if (\n          t.isMemberExpression(callee.node) &&\n          t.isIdentifier(callee.node.object, { name: \"console\" }) &&\n          t.isIdentifier(callee.node.property)\n        ) {\n          // For each argument, check if JSX\n          const newArgs = path.node.arguments.map((arg) => {\n            if (t.isJSXElement(arg) || t.isJSXFragment(arg)) {\n              return t.callExpression(t.identifier(\"logJsx\"), [arg]);\n            }\n            return arg;\n          });\n\n          // Replace arguments if any JSX was wrapped\n          if (newArgs.some((arg, i) => arg !== path.node.arguments[i])) {\n            path.node.arguments = newArgs;\n          }\n        }\n      },\n    },\n  };\n});\n","import { PluginObj } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\ntype Metadata = {\n  importedLoops: Set<string>;\n  localLoops: Set<string>;\n};\n\n/**\n * babel plugin to auto wrap loops\n *\n * @param api - The babel api.\n * @returns The babel options.\n */\nexport const loopAutoWrapPlugin = declare((api) => {\n  api.assertVersion(7);\n  return {\n    pre() {\n      // Initialize metadata storage per file\n      const meta = this.file.metadata as Partial<Metadata>;\n      meta.importedLoops = new Set();\n      meta.localLoops = new Set();\n    },\n    visitor: {\n      Program(path, state) {\n        const meta = state.file.metadata as Metadata;\n        const importedLoops = meta.importedLoops;\n        const localLoops = meta.localLoops;\n\n        path.get(\"body\").forEach((child) => {\n          if (child.isImportDeclaration() && child.node.source.value === \"@veltra/app\") {\n            child.node.specifiers.forEach((spec) => {\n              if (t.isImportSpecifier(spec) && t.isIdentifier(spec.imported, { name: \"loop\" })) {\n                importedLoops.add(spec.local.name);\n              }\n            });\n          }\n\n          if (child.isFunctionDeclaration() && t.isIdentifier(child.node.id)) {\n            localLoops.add(child.node.id.name);\n          }\n\n          if (child.isVariableDeclaration()) {\n            child.node.declarations.forEach((decl) => {\n              if (t.isIdentifier(decl.id)) {\n                localLoops.add(decl.id.name);\n              }\n            });\n          }\n        });\n      },\n\n      CallExpression(path, state) {\n        const meta = state.file.metadata as Metadata;\n        const importedLoops = meta.importedLoops;\n        const localLoops = meta.localLoops;\n\n        const callee = path.get(\"callee\");\n        if (!callee.isIdentifier()) return;\n\n        const name = callee.node.name;\n\n        if (importedLoops.has(name) && !localLoops.has(name)) {\n          if (path.node.arguments.length === 1) {\n            const arg = path.node.arguments[0];\n            if (!t.isArrowFunctionExpression(arg) && t.isExpression(arg)) {\n              path.node.arguments[0] = t.arrowFunctionExpression([], arg);\n            }\n          }\n        }\n      },\n    },\n  } satisfies PluginObj;\n});\n","import { NodePath } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\n/**\n * babel plugin to transform map to loop\n *\n * @param api - The babel api.\n * @returns The babel options.\n */\nexport const loopMapPlugin = declare((api) => {\n  api.assertVersion(7);\n  return {\n    visitor: {\n      Program(path, state) {\n        const filename = state.filename || \"\";\n\n        // Skip transforming files from Veltra's own source or installed package\n        if (\n          filename.includes(\"/veltra-router/\") ||\n          filename.includes(\"\\\\veltra-router\\\\\") || // local dev\n          filename.includes(\"/veltra-app/\") ||\n          filename.includes(\"\\\\veltra-app\\\\\") || // local dev\n          filename.includes(\"/node_modules/@veltra/app/\") ||\n          filename.includes(\"\\\\node_modules\\\\@veltra\\\\app\\\\\") // package\n        ) {\n          return;\n        }\n\n        let hasLoop = false;\n\n        path.get(\"body\").forEach((child) => {\n          if (child.isImportDeclaration() && child.node.source.value === \"@veltra/app\") {\n            child.node.specifiers.forEach((spec) => {\n              if (t.isImportSpecifier(spec)) {\n                const imported = spec.imported;\n                if (t.isIdentifier(imported)) {\n                  if (imported.name === \"loop\") hasLoop = true;\n                }\n              }\n            });\n          }\n        });\n\n        const newImports: t.ImportSpecifier[] = [];\n        if (!hasLoop)\n          newImports.push(t.importSpecifier(t.identifier(\"loop\"), t.identifier(\"loop\")));\n\n        if (newImports.length) {\n          const importDecl = t.importDeclaration(newImports, t.stringLiteral(\"@veltra/app\"));\n          path.unshiftContainer(\"body\", importDecl);\n        }\n      },\n\n      JSXExpressionContainer(path) {\n        const expr = path.get(\"expression\");\n\n        function transformMap(\n          exprPath: NodePath<t.Expression | t.JSXEmptyExpression>,\n        ): t.CallExpression | null {\n          const node = exprPath.node;\n          if (\n            t.isCallExpression(node) &&\n            t.isMemberExpression(node.callee) &&\n            t.isIdentifier(node.callee.property) &&\n            node.callee.property.name === \"map\"\n          ) {\n            const mapFn = node.arguments[0];\n            const arrExpr = node.callee.object;\n\n            if (t.isArrowFunctionExpression(mapFn) && mapFn.params.length >= 2) {\n              const indexParam = mapFn.params[1];\n              if (t.isIdentifier(indexParam)) {\n                t.traverseFast(mapFn.body, (n) => {\n                  if (t.isIdentifier(n) && n.name === indexParam.name) {\n                    const memberExpr = t.memberExpression(\n                      t.identifier(indexParam.name),\n                      t.identifier(\"value\"),\n                    );\n                    Object.assign(n, memberExpr);\n                  }\n                });\n              }\n            }\n\n            return t.callExpression(\n              t.memberExpression(\n                t.callExpression(t.identifier(\"loop\"), [t.arrowFunctionExpression([], arrExpr)]),\n                t.identifier(\"each\"),\n              ),\n              [mapFn as t.Expression],\n            );\n          }\n          return null;\n        }\n\n        function handleExpression(exprPath: NodePath<t.Expression | t.JSXEmptyExpression>) {\n          const node = exprPath.node;\n\n          if (t.isLogicalExpression(node)) {\n            const right = exprPath.get(\"right\") as NodePath<t.Expression | t.JSXEmptyExpression>;\n            const transformedRight = transformMap(right);\n            if (transformedRight) {\n              right.replaceWith(transformedRight);\n            }\n          } else if (t.isConditionalExpression(node)) {\n            const consequent = exprPath.get(\"consequent\") as NodePath<\n              t.Expression | t.JSXEmptyExpression\n            >;\n            const alternate = exprPath.get(\"alternate\") as NodePath<\n              t.Expression | t.JSXEmptyExpression\n            >;\n\n            const transformedCons = transformMap(consequent);\n            const transformedAlt = transformMap(alternate);\n\n            if (transformedCons) {\n              consequent.replaceWith(transformedCons);\n            }\n            if (transformedAlt) {\n              alternate.replaceWith(transformedAlt);\n            }\n          } else {\n            const transformed = transformMap(exprPath);\n            if (transformed) {\n              exprPath.replaceWith(transformed);\n            }\n          }\n        }\n\n        handleExpression(expr);\n      },\n    },\n  };\n});\n","import { PluginObj } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport { NodePath } from \"@babel/traverse\";\nimport * as t from \"@babel/types\";\n\ntype Metadata = {\n  importedLoops: Set<string>;\n  hasMemoImport: boolean;\n};\n\n/**\n * babel plugin to wrap loop in memo\n *\n * @param api - The babel api.\n * @returns The babel options.\n */\nexport const loopMemoPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    name: \"wrap-loop-in-memo\",\n\n    pre() {\n      const meta = this.file.metadata as Partial<Metadata>;\n      meta.importedLoops = new Set();\n      meta.hasMemoImport = false;\n    },\n\n    visitor: {\n      Program(path, state) {\n        const meta = state.file.metadata as Metadata;\n\n        path.get(\"body\").forEach((child) => {\n          if (child.isImportDeclaration() && child.node.source.value === \"@veltra/app\") {\n            for (const spec of child.node.specifiers) {\n              if (t.isImportSpecifier(spec) && t.isIdentifier(spec.imported)) {\n                if (spec.imported.name === \"loop\") {\n                  meta.importedLoops.add(spec.local.name);\n                }\n                if (spec.imported.name === \"memo\") {\n                  meta.hasMemoImport = true;\n                }\n              }\n            }\n          }\n        });\n\n        // Inject memo import if missing\n        if (!meta.hasMemoImport) {\n          path.unshiftContainer(\n            \"body\",\n            t.importDeclaration(\n              [t.importSpecifier(t.identifier(\"memo\"), t.identifier(\"memo\"))],\n              t.stringLiteral(\"@veltra/app\"),\n            ),\n          );\n        }\n      },\n\n      JSXExpressionContainer(path, state) {\n        const meta = state.file.metadata as Metadata;\n        const loopNames = meta.importedLoops;\n        let replaced = false;\n\n        path.traverse({\n          CallExpression(callPath) {\n            if (replaced) return;\n\n            const callExpr = callPath.node;\n\n            // Check for loop(...).each(...)\n            if (\n              t.isMemberExpression(callExpr.callee) &&\n              t.isCallExpression(callExpr.callee.object) &&\n              t.isIdentifier(callExpr.callee.object.callee) &&\n              loopNames.has(callExpr.callee.object.callee.name) &&\n              t.isIdentifier(callExpr.callee.property, { name: \"each\" })\n            ) {\n              const loopCall = callExpr.callee.object;\n\n              // Wrap loop(data) â†’ loop(() => data)\n              const loopArg = loopCall.arguments[0];\n              if (loopArg && !t.isArrowFunctionExpression(loopArg) && t.isExpression(loopArg)) {\n                loopCall.arguments[0] = t.arrowFunctionExpression([], loopArg);\n              }\n\n              // Generate const _memo = memo(() => loop(...).each(...))\n              const memoId = path.scope.generateUidIdentifier(\"loopMemo\");\n              const memoDecl = t.variableDeclaration(\"const\", [\n                t.variableDeclarator(\n                  memoId,\n                  t.callExpression(t.identifier(\"memo\"), [t.arrowFunctionExpression([], callExpr)]),\n                ),\n              ]);\n\n              // Hoist to block\n              const blockPath = path.findParent(\n                (p) => p.isBlockStatement() || p.isProgram(),\n              ) as NodePath<t.BlockStatement | t.Program>;\n              blockPath.unshiftContainer(\"body\", memoDecl);\n\n              // Replace full expression with _memo()\n              callPath.replaceWith(t.callExpression(memoId, []));\n              replaced = true;\n            }\n          },\n        });\n      },\n    },\n  } satisfies PluginObj;\n});\n","import { NodePath } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\n/**\n * babel plugin to wrap suspense children\n *\n * @param api - The babel api.\n * @returns The babel options.\n */\nexport const suspenseWrapPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    visitor: {\n      Program(path) {\n        const suspenseNames = new Set<string>([\"Suspense\"]);\n\n        // Detect imported Suspense aliases\n        path.traverse({\n          ImportDeclaration(importPath) {\n            if (importPath.node.source.value === \"@veltra/app\") {\n              importPath.node.specifiers.forEach((spec) => {\n                if (\n                  t.isImportSpecifier(spec) &&\n                  t.isIdentifier(spec.imported) &&\n                  spec.imported.name === \"Suspense\"\n                ) {\n                  suspenseNames.add(spec.local.name);\n                }\n              });\n            }\n          },\n        });\n\n        path.traverse({\n          JSXElement(jsxPath: NodePath<t.JSXElement>) {\n            const openingElement = jsxPath.node.openingElement;\n\n            if (\n              t.isJSXIdentifier(openingElement.name) &&\n              suspenseNames.has(openingElement.name.name)\n            ) {\n              const children = jsxPath.node.children;\n\n              if (children.length === 0) return;\n\n              // If the first child is already an expression container, skip\n              if (t.isJSXExpressionContainer(children[0])) return;\n\n              // Wrap original children in a Fragment inside an ExpressionContainer\n              const wrappedExpression = t.jSXExpressionContainer(\n                t.jSXFragment(t.jSXOpeningFragment(), t.jSXClosingFragment(), children),\n              );\n\n              // Replace all children with single wrapped fragment\n              jsxPath.node.children = [wrappedExpression];\n            }\n          },\n        });\n      },\n    },\n  };\n});\n","import { NodePath, PluginObj } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\ntype Metadata = {\n  loopLocalNames: Set<string>;\n};\n\n/**\n * babel plugin to wrap jsx expressions except loop\n *\n * @param api - The babel api.\n * @returns The babel options.\n */\nexport const wrapJSXExpressionsPlugin = declare((api): PluginObj => {\n  api.assertVersion(7);\n\n  return {\n    name: \"wrap-jsx-expressions-except-loop\",\n\n    pre() {\n      const meta = this.file.metadata as Partial<Metadata>;\n      meta.loopLocalNames = new Set();\n    },\n\n    visitor: {\n      ImportDeclaration(path, state) {\n        const meta = state.file.metadata as Metadata;\n        if (path.node.source.value === \"@veltra/app\") {\n          for (const specifier of path.node.specifiers) {\n            if (\n              t.isImportSpecifier(specifier) &&\n              t.isIdentifier(specifier.imported, { name: \"loop\" })\n            ) {\n              meta.loopLocalNames.add(specifier.local.name); // handles alias\n            }\n          }\n        }\n      },\n\n      JSXExpressionContainer(path: NodePath<t.JSXExpressionContainer>, state) {\n        const meta = state.file.metadata as Metadata;\n        const loopLocalNames = meta.loopLocalNames ?? new Set();\n\n        const expr = path.get(\"expression\");\n\n        if (t.isJSXEmptyExpression(expr.node)) return;\n\n        if (isLoopCallOrEach(expr.node, loopLocalNames)) {\n          return;\n        }\n\n        // 4. Wrap in arrow function\n        path.node.expression = t.arrowFunctionExpression([], expr.node);\n      },\n    },\n  };\n});\n\n/**\n * Detects:\n * - loop(...)\n * - loop(...).each(...)\n */\nfunction isLoopCallOrEach(node: t.Expression, loopNames: Set<string>): boolean {\n  // match loop(...)\n  if (t.isCallExpression(node) && t.isIdentifier(node.callee) && loopNames.has(node.callee.name)) {\n    return true;\n  }\n\n  // match loop(...).each(...)\n  if (\n    t.isCallExpression(node) && // outer .each(...)\n    t.isMemberExpression(node.callee) &&\n    t.isCallExpression(node.callee.object) &&\n    t.isIdentifier(node.callee.object.callee) &&\n    loopNames.has(node.callee.object.callee.name)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","import { ConfigAPI, TransformOptions } from \"@babel/core\";\n// @ts-expect-error - babel-preset-react is not typed\nimport babelReactPlugin from \"@babel/preset-react\";\n\nimport {\n  logJsxPlugin,\n  loopAutoWrapPlugin,\n  loopMemoPlugin,\n  suspenseWrapPlugin,\n  wrapJSXExpressionsPlugin,\n} from \"./plugins\";\n\n/**\n * babel preset for veltra\n *\n * @param api - The babel api.\n * @returns The babel options.\n */\nexport default function babelPresetVeltra(api: ConfigAPI): TransformOptions {\n  api.assertVersion(7);\n\n  return {\n    presets: [\n      [\n        babelReactPlugin,\n        {\n          runtime: \"automatic\",\n          importSource: \"@veltra/app\",\n        },\n      ],\n    ],\n    plugins: [\n      logJsxPlugin,\n      suspenseWrapPlugin,\n      loopAutoWrapPlugin,\n      loopMemoPlugin,\n      wrapJSXExpressionsPlugin,\n    ],\n  };\n}\n"],"names":["logJsxPlugin","declare","api","path","state","filename","hasLogJsx","child","spec","t","imported","importDecl","callee","newArgs","arg","i","loopAutoWrapPlugin","meta","importedLoops","localLoops","decl","name","hasLoop","newImports","expr","transformMap","exprPath","node","mapFn","arrExpr","indexParam","n","memberExpr","handleExpression","right","transformedRight","consequent","alternate","transformedCons","transformedAlt","transformed","loopMemoPlugin","loopNames","replaced","callPath","callExpr","loopCall","loopArg","memoId","memoDecl","p","suspenseWrapPlugin","suspenseNames","importPath","jsxPath","openingElement","children","wrappedExpression","wrapJSXExpressionsPlugin","specifier","loopLocalNames","isLoopCallOrEach","babelPresetVeltra","babelReactPlugin"],"mappings":"uHAUO,MAAMA,EAAeC,EAASC,IACnCA,EAAI,cAAc,CAAC,EAEZ,CACL,QAAS,CACP,QAAQC,EAAMC,EAAO,CACnB,MAAMC,EAAWD,EAAM,UAAY,GAGnC,GACEC,EAAS,SAAS,iBAAiB,GACnCA,EAAS,SAAS,mBAAmB,GACrCA,EAAS,SAAS,cAAc,GAChCA,EAAS,SAAS,gBAAgB,GAClCA,EAAS,SAAS,4BAA4B,GAC9CA,EAAS,SAAS,gCAAgC,EAElD,OAGF,IAAIC,EAAY,GAiBhB,GAdAH,EAAK,IAAI,MAAM,EAAE,QAASI,GAAU,CAC9BA,EAAM,oBAAyBA,GAAAA,EAAM,KAAK,OAAO,QAAU,eAC7DA,EAAM,KAAK,WAAW,QAASC,GAAS,CACtC,GAAIC,EAAE,kBAAkBD,CAAI,EAAG,CAC7B,MAAME,EAAWF,EAAK,SAClBC,EAAE,aAAaC,CAAQ,GAAKA,EAAS,OAAS,WAChDJ,EAAY,GAEhB,CACF,CAAC,CAEL,CAAC,EAGG,CAACA,EAAW,CACd,MAAMK,EAAaF,EAAE,kBACnB,CAACA,EAAE,gBAAgBA,EAAE,WAAW,QAAQ,EAAGA,EAAE,WAAW,QAAQ,CAAC,CAAC,EAClEA,EAAE,cAAc,aAAa,CAC/B,EACAN,EAAK,iBAAiB,OAAQQ,CAAU,CAC1C,CACF,EAEA,eAAeR,EAAkC,CAC/C,MAAMS,EAAST,EAAK,IAAI,QAAQ,EAGhC,GACEM,EAAE,mBAAmBG,EAAO,IAAI,GAChCH,EAAE,aAAaG,EAAO,KAAK,OAAQ,CAAE,KAAM,SAAU,CAAC,GACtDH,EAAE,aAAaG,EAAO,KAAK,QAAQ,EACnC,CAEA,MAAMC,EAAUV,EAAK,KAAK,UAAU,IAAKW,GACnCL,EAAE,aAAaK,CAAG,GAAKL,EAAE,cAAcK,CAAG,EACrCL,EAAE,eAAeA,EAAE,WAAW,QAAQ,EAAG,CAACK,CAAG,CAAC,EAEhDA,CACR,EAGGD,EAAQ,KAAK,CAACC,EAAKC,IAAMD,IAAQX,EAAK,KAAK,UAAUY,CAAC,CAAC,IACzDZ,EAAK,KAAK,UAAYU,EAE1B,CACF,CACF,CACF,EACD,EClEYG,EAAqBf,EAASC,IACzCA,EAAI,cAAc,CAAC,EACZ,CACL,KAAM,CAEJ,MAAMe,EAAO,KAAK,KAAK,SACvBA,EAAK,cAAgB,IAAI,IACzBA,EAAK,WAAa,IAAI,GACxB,EACA,QAAS,CACP,QAAQd,EAAMC,EAAO,CACnB,MAAMa,EAAOb,EAAM,KAAK,SAClBc,EAAgBD,EAAK,cACrBE,EAAaF,EAAK,WAExBd,EAAK,IAAI,MAAM,EAAE,QAASI,GAAU,CAC9BA,EAAM,uBAAyBA,EAAM,KAAK,OAAO,QAAU,eAC7DA,EAAM,KAAK,WAAW,QAASC,GAAS,CAClCC,EAAE,kBAAkBD,CAAI,GAAKC,EAAE,aAAaD,EAAK,SAAU,CAAE,KAAM,MAAO,CAAC,GAC7EU,EAAc,IAAIV,EAAK,MAAM,IAAI,CAErC,CAAC,EAGCD,EAAM,yBAA2BE,EAAE,aAAaF,EAAM,KAAK,EAAE,GAC/DY,EAAW,IAAIZ,EAAM,KAAK,GAAG,IAAI,EAG/BA,EAAM,yBACRA,EAAM,KAAK,aAAa,QAASa,GAAS,CACpCX,EAAE,aAAaW,EAAK,EAAE,GACxBD,EAAW,IAAIC,EAAK,GAAG,IAAI,CAE/B,CAAC,CAEL,CAAC,CACH,EAEA,eAAejB,EAAMC,EAAO,CAC1B,MAAMa,EAAOb,EAAM,KAAK,SAClBc,EAAgBD,EAAK,cACrBE,EAAaF,EAAK,WAElBL,EAAST,EAAK,IAAI,QAAQ,EAChC,GAAI,CAACS,EAAO,eAAgB,OAE5B,MAAMS,EAAOT,EAAO,KAAK,KAEzB,GAAIM,EAAc,IAAIG,CAAI,GAAK,CAACF,EAAW,IAAIE,CAAI,GAC7ClB,EAAK,KAAK,UAAU,SAAW,EAAG,CACpC,MAAMW,EAAMX,EAAK,KAAK,UAAU,CAAC,EAC7B,CAACM,EAAE,0BAA0BK,CAAG,GAAKL,EAAE,aAAaK,CAAG,IACzDX,EAAK,KAAK,UAAU,CAAC,EAAIM,EAAE,wBAAwB,CAAA,EAAIK,CAAG,EAE9D,CAEJ,CACF,CACF,EACD,EChE4Bb,EAASC,IACpCA,EAAI,cAAc,CAAC,EACZ,CACL,QAAS,CACP,QAAQC,EAAMC,EAAO,CACnB,MAAMC,EAAWD,EAAM,UAAY,GAGnC,GACEC,EAAS,SAAS,iBAAiB,GACnCA,EAAS,SAAS,mBAAmB,GACrCA,EAAS,SAAS,cAAc,GAChCA,EAAS,SAAS,gBAAgB,GAClCA,EAAS,SAAS,4BAA4B,GAC9CA,EAAS,SAAS,gCAAgC,EAElD,OAGF,IAAIiB,EAAU,GAEdnB,EAAK,IAAI,MAAM,EAAE,QAASI,GAAU,CAC9BA,EAAM,uBAAyBA,EAAM,KAAK,OAAO,QAAU,eAC7DA,EAAM,KAAK,WAAW,QAASC,GAAS,CACtC,GAAIC,EAAE,kBAAkBD,CAAI,EAAG,CAC7B,MAAME,EAAWF,EAAK,SAClBC,EAAE,aAAaC,CAAQ,GACrBA,EAAS,OAAS,SAAQY,EAAU,GAE5C,CACF,CAAC,CAEL,CAAC,EAED,MAAMC,EAAkC,CAAC,EAIzC,GAHKD,GACHC,EAAW,KAAKd,EAAE,gBAAgBA,EAAE,WAAW,MAAM,EAAGA,EAAE,WAAW,MAAM,CAAC,CAAC,EAE3Ec,EAAW,OAAQ,CACrB,MAAMZ,EAAaF,EAAE,kBAAkBc,EAAYd,EAAE,cAAc,aAAa,CAAC,EACjFN,EAAK,iBAAiB,OAAQQ,CAAU,CAC1C,CACF,EAEA,uBAAuBR,EAAM,CAC3B,MAAMqB,EAAOrB,EAAK,IAAI,YAAY,EAElC,SAASsB,EACPC,EACyB,CACzB,MAAMC,EAAOD,EAAS,KACtB,GACEjB,EAAE,iBAAiBkB,CAAI,GACvBlB,EAAE,mBAAmBkB,EAAK,MAAM,GAChClB,EAAE,aAAakB,EAAK,OAAO,QAAQ,GACnCA,EAAK,OAAO,SAAS,OAAS,MAC9B,CACA,MAAMC,EAAQD,EAAK,UAAU,CAAC,EACxBE,EAAUF,EAAK,OAAO,OAE5B,GAAIlB,EAAE,0BAA0BmB,CAAK,GAAKA,EAAM,OAAO,QAAU,EAAG,CAClE,MAAME,EAAaF,EAAM,OAAO,CAAC,EAC7BnB,EAAE,aAAaqB,CAAU,GAC3BrB,EAAE,aAAamB,EAAM,KAAOG,GAAM,CAChC,GAAItB,EAAE,aAAasB,CAAC,GAAKA,EAAE,OAASD,EAAW,KAAM,CACnD,MAAME,EAAavB,EAAE,iBACnBA,EAAE,WAAWqB,EAAW,IAAI,EAC5BrB,EAAE,WAAW,OAAO,CACtB,EACA,OAAO,OAAOsB,EAAGC,CAAU,CAC7B,CACF,CAAC,CAEL,CAEA,OAAOvB,EAAE,eACPA,EAAE,iBACAA,EAAE,eAAeA,EAAE,WAAW,MAAM,EAAG,CAACA,EAAE,wBAAwB,GAAIoB,CAAO,CAAC,CAAC,EAC/EpB,EAAE,WAAW,MAAM,CACrB,EACA,CAACmB,CAAqB,CACxB,CACF,CACA,OAAO,IACT,CAEA,SAASK,EAAiBP,EAAyD,CACjF,MAAMC,EAAOD,EAAS,KAEtB,GAAIjB,EAAE,oBAAoBkB,CAAI,EAAG,CAC/B,MAAMO,EAAQR,EAAS,IAAI,OAAO,EAC5BS,EAAmBV,EAAaS,CAAK,EACvCC,GACFD,EAAM,YAAYC,CAAgB,CAEtC,SAAW1B,EAAE,wBAAwBkB,CAAI,EAAG,CAC1C,MAAMS,EAAaV,EAAS,IAAI,YAAY,EAGtCW,EAAYX,EAAS,IAAI,WAAW,EAIpCY,EAAkBb,EAAaW,CAAU,EACzCG,EAAiBd,EAAaY,CAAS,EAEzCC,GACFF,EAAW,YAAYE,CAAe,EAEpCC,GACFF,EAAU,YAAYE,CAAc,CAExC,KAAO,CACL,MAAMC,EAAcf,EAAaC,CAAQ,EACrCc,GACFd,EAAS,YAAYc,CAAW,CAEpC,CACF,CAEAP,EAAiBT,CAAI,CACvB,CACF,CACF,EACD,ECtHY,MAAAiB,EAAiBxC,EAASC,IACrCA,EAAI,cAAc,CAAC,EAEZ,CACL,KAAM,oBAEN,KAAM,CACJ,MAAMe,EAAO,KAAK,KAAK,SACvBA,EAAK,cAAgB,IAAI,IACzBA,EAAK,cAAgB,EACvB,EAEA,QAAS,CACP,QAAQd,EAAMC,EAAO,CACnB,MAAMa,EAAOb,EAAM,KAAK,SAExBD,EAAK,IAAI,MAAM,EAAE,QAASI,GAAU,CAClC,GAAIA,EAAM,oBAAoB,GAAKA,EAAM,KAAK,OAAO,QAAU,cAC7D,UAAWC,KAAQD,EAAM,KAAK,WACxBE,EAAE,kBAAkBD,CAAI,GAAKC,EAAE,aAAaD,EAAK,QAAQ,IACvDA,EAAK,SAAS,OAAS,QACzBS,EAAK,cAAc,IAAIT,EAAK,MAAM,IAAI,EAEpCA,EAAK,SAAS,OAAS,SACzBS,EAAK,cAAgB,IAK/B,CAAC,EAGIA,EAAK,eACRd,EAAK,iBACH,OACAM,EAAE,kBACA,CAACA,EAAE,gBAAgBA,EAAE,WAAW,MAAM,EAAGA,EAAE,WAAW,MAAM,CAAC,CAAC,EAC9DA,EAAE,cAAc,aAAa,CAC/B,CACF,CAEJ,EAEA,uBAAuBN,EAAMC,EAAO,CAElC,MAAMsC,EADOtC,EAAM,KAAK,SACD,cACvB,IAAIuC,EAAW,GAEfxC,EAAK,SAAS,CACZ,eAAeyC,EAAU,CACvB,GAAID,EAAU,OAEd,MAAME,EAAWD,EAAS,KAG1B,GACEnC,EAAE,mBAAmBoC,EAAS,MAAM,GACpCpC,EAAE,iBAAiBoC,EAAS,OAAO,MAAM,GACzCpC,EAAE,aAAaoC,EAAS,OAAO,OAAO,MAAM,GAC5CH,EAAU,IAAIG,EAAS,OAAO,OAAO,OAAO,IAAI,GAChDpC,EAAE,aAAaoC,EAAS,OAAO,SAAU,CAAE,KAAM,MAAO,CAAC,EACzD,CACA,MAAMC,EAAWD,EAAS,OAAO,OAG3BE,EAAUD,EAAS,UAAU,CAAC,EAChCC,GAAW,CAACtC,EAAE,0BAA0BsC,CAAO,GAAKtC,EAAE,aAAasC,CAAO,IAC5ED,EAAS,UAAU,CAAC,EAAIrC,EAAE,wBAAwB,CAAIsC,EAAAA,CAAO,GAI/D,MAAMC,EAAS7C,EAAK,MAAM,sBAAsB,UAAU,EACpD8C,EAAWxC,EAAE,oBAAoB,QAAS,CAC9CA,EAAE,mBACAuC,EACAvC,EAAE,eAAeA,EAAE,WAAW,MAAM,EAAG,CAACA,EAAE,wBAAwB,CAAIoC,EAAAA,CAAQ,CAAC,CAAC,CAClF,CACF,CAAC,EAGiB1C,EAAK,WACpB+C,GAAMA,EAAE,iBAAiB,GAAKA,EAAE,UAAA,CACnC,EACU,iBAAiB,OAAQD,CAAQ,EAG3CL,EAAS,YAAYnC,EAAE,eAAeuC,EAAQ,CAAE,CAAA,CAAC,EACjDL,EAAW,EACb,CACF,CACF,CAAC,CACH,CACF,CACF,EACD,ECpGYQ,EAAqBlD,EAASC,IACzCA,EAAI,cAAc,CAAC,EAEZ,CACL,QAAS,CACP,QAAQC,EAAM,CACZ,MAAMiD,EAAgB,IAAI,IAAY,CAAC,UAAU,CAAC,EAGlDjD,EAAK,SAAS,CACZ,kBAAkBkD,EAAY,CACxBA,EAAW,KAAK,OAAO,QAAU,eACnCA,EAAW,KAAK,WAAW,QAAS7C,GAAS,CAEzCC,EAAE,kBAAkBD,CAAI,GACxBC,EAAE,aAAaD,EAAK,QAAQ,GAC5BA,EAAK,SAAS,OAAS,YAEvB4C,EAAc,IAAI5C,EAAK,MAAM,IAAI,CAErC,CAAC,CAEL,CACF,CAAC,EAEDL,EAAK,SAAS,CACZ,WAAWmD,EAAiC,CAC1C,MAAMC,EAAiBD,EAAQ,KAAK,eAEpC,GACE7C,EAAE,gBAAgB8C,EAAe,IAAI,GACrCH,EAAc,IAAIG,EAAe,KAAK,IAAI,EAC1C,CACA,MAAMC,EAAWF,EAAQ,KAAK,SAK9B,GAHIE,EAAS,SAAW,GAGpB/C,EAAE,yBAAyB+C,EAAS,CAAC,CAAC,EAAG,OAG7C,MAAMC,EAAoBhD,EAAE,uBAC1BA,EAAE,YAAYA,EAAE,qBAAsBA,EAAE,mBAAsB+C,EAAAA,CAAQ,CACxE,EAGAF,EAAQ,KAAK,SAAW,CAACG,CAAiB,CAC5C,CACF,CACF,CAAC,CACH,CACF,CACF,EACD,ECjDYC,EAA2BzD,EAASC,IAC/CA,EAAI,cAAc,CAAC,EAEZ,CACL,KAAM,mCAEN,KAAM,CACJ,MAAMe,EAAO,KAAK,KAAK,SACvBA,EAAK,eAAiB,IAAI,GAC5B,EAEA,QAAS,CACP,kBAAkBd,EAAMC,EAAO,CAC7B,MAAMa,EAAOb,EAAM,KAAK,SACxB,GAAID,EAAK,KAAK,OAAO,QAAU,cAC7B,UAAWwD,KAAaxD,EAAK,KAAK,WAE9BM,EAAE,kBAAkBkD,CAAS,GAC7BlD,EAAE,aAAakD,EAAU,SAAU,CAAE,KAAM,MAAO,CAAC,GAEnD1C,EAAK,eAAe,IAAI0C,EAAU,MAAM,IAAI,CAIpD,EAEA,uBAAuBxD,EAA0CC,EAAO,CAEtE,MAAMwD,EADOxD,EAAM,KAAK,SACI,gBAAkB,IAAI,IAE5CoB,EAAOrB,EAAK,IAAI,YAAY,EAE9BM,EAAE,qBAAqBe,EAAK,IAAI,GAEhCqC,EAAiBrC,EAAK,KAAMoC,CAAc,IAK9CzD,EAAK,KAAK,WAAaM,EAAE,wBAAwB,CAAA,EAAIe,EAAK,IAAI,EAChE,CACF,CACF,EACD,EAOD,SAASqC,EAAiBlC,EAAoBe,EAAiC,CAO7E,MALI,CAAA,EAAAjC,EAAE,iBAAiBkB,CAAI,GAAKlB,EAAE,aAAakB,EAAK,MAAM,GAAKe,EAAU,IAAIf,EAAK,OAAO,IAAI,GAM3FlB,EAAE,iBAAiBkB,CAAI,GACvBlB,EAAE,mBAAmBkB,EAAK,MAAM,GAChClB,EAAE,iBAAiBkB,EAAK,OAAO,MAAM,GACrClB,EAAE,aAAakB,EAAK,OAAO,OAAO,MAAM,GACxCe,EAAU,IAAIf,EAAK,OAAO,OAAO,OAAO,IAAI,EAMhD,CChEwBmC,SAAAA,EAAkB5D,EAAkC,CAC1E,OAAAA,EAAI,cAAc,CAAC,EAEZ,CACL,QAAS,CACP,CACE6D,EACA,CACE,QAAS,YACT,aAAc,aAChB,CACF,CACF,EACA,QAAS,CACP/D,EACAmD,EACAnC,EACAyB,EACAiB,CACF,CACF,CACF"}