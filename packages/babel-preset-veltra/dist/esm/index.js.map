{"version":3,"file":"index.js","sources":["../../src/plugins/loopMapPlugin.ts","../../src/plugins/logJsxPlugin.ts","../../src/plugins/suspenseWrapPlugin.ts","../../src/plugins/loopAutoWrapPlugin.ts","../../src/plugins/wrapJsxExpressionPlugin.ts","../../src/index.ts"],"sourcesContent":["import { NodePath } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\nexport const loopMapPlugin = declare((api) => {\n  api.assertVersion(7);\n  return {\n    visitor: {\n      Program(path, state) {\n        const filename = state.filename || \"\";\n\n        // Skip transforming files from Veltra's own source or installed package\n        if (\n          filename.includes(\"/veltra-router/\") ||\n          filename.includes(\"\\\\veltra-router\\\\\") || // local dev\n          filename.includes(\"/veltra-app/\") ||\n          filename.includes(\"\\\\veltra-app\\\\\") || // local dev\n          filename.includes(\"/node_modules/@veltra/app/\") ||\n          filename.includes(\"\\\\node_modules\\\\@veltra\\\\app\\\\\") // package\n        ) {\n          return;\n        }\n\n        let hasLoop = false;\n\n        path.get(\"body\").forEach((child) => {\n          if (\n            child.isImportDeclaration() &&\n            child.node.source.value === \"@veltra/app\"\n          ) {\n            child.node.specifiers.forEach((spec) => {\n              if (t.isImportSpecifier(spec)) {\n                const imported = spec.imported;\n                if (t.isIdentifier(imported)) {\n                  if (imported.name === \"loop\") hasLoop = true;\n                }\n              }\n            });\n          }\n        });\n\n        const newImports: t.ImportSpecifier[] = [];\n        if (!hasLoop)\n          newImports.push(\n            t.importSpecifier(t.identifier(\"loop\"), t.identifier(\"loop\"))\n          );\n\n        if (newImports.length) {\n          const importDecl = t.importDeclaration(\n            newImports,\n            t.stringLiteral(\"@veltra/app\")\n          );\n          path.unshiftContainer(\"body\", importDecl);\n        }\n      },\n\n      JSXExpressionContainer(path) {\n        const expr = path.get(\"expression\");\n\n        function transformMap(\n          exprPath: NodePath<t.Expression | t.JSXEmptyExpression>\n        ): t.CallExpression | null {\n          const node = exprPath.node;\n          if (\n            t.isCallExpression(node) &&\n            t.isMemberExpression(node.callee) &&\n            t.isIdentifier(node.callee.property) &&\n            node.callee.property.name === \"map\"\n          ) {\n            const mapFn = node.arguments[0];\n            const arrExpr = node.callee.object;\n\n            if (\n              t.isArrowFunctionExpression(mapFn) &&\n              mapFn.params.length >= 2\n            ) {\n              const indexParam = mapFn.params[1];\n              if (t.isIdentifier(indexParam)) {\n                t.traverseFast(mapFn.body, (n) => {\n                  if (t.isIdentifier(n) && n.name === indexParam.name) {\n                    const memberExpr = t.memberExpression(\n                      t.identifier(indexParam.name),\n                      t.identifier(\"value\")\n                    );\n                    Object.assign(n, memberExpr);\n                  }\n                });\n              }\n            }\n\n            return t.callExpression(\n              t.memberExpression(\n                t.callExpression(t.identifier(\"loop\"), [\n                  t.arrowFunctionExpression([], arrExpr),\n                ]),\n                t.identifier(\"each\")\n              ),\n              [mapFn as t.Expression]\n            );\n          }\n          return null;\n        }\n\n        function handleExpression(\n          exprPath: NodePath<t.Expression | t.JSXEmptyExpression>\n        ) {\n          const node = exprPath.node;\n\n          if (t.isLogicalExpression(node)) {\n            const right = exprPath.get(\"right\") as NodePath<\n              t.Expression | t.JSXEmptyExpression\n            >;\n            const transformedRight = transformMap(right);\n            if (transformedRight) {\n              right.replaceWith(transformedRight);\n            }\n          } else if (t.isConditionalExpression(node)) {\n            const consequent = exprPath.get(\"consequent\") as NodePath<\n              t.Expression | t.JSXEmptyExpression\n            >;\n            const alternate = exprPath.get(\"alternate\") as NodePath<\n              t.Expression | t.JSXEmptyExpression\n            >;\n\n            const transformedCons = transformMap(consequent);\n            const transformedAlt = transformMap(alternate);\n\n            if (transformedCons) {\n              consequent.replaceWith(transformedCons);\n            }\n            if (transformedAlt) {\n              alternate.replaceWith(transformedAlt);\n            }\n          } else {\n            const transformed = transformMap(exprPath);\n            if (transformed) {\n              exprPath.replaceWith(transformed);\n            }\n          }\n        }\n\n        handleExpression(expr);\n      },\n    },\n  };\n});\n","import { NodePath } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\nexport const logJsxPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    visitor: {\n      Program(path, state) {\n        const filename = state.filename || \"\";\n\n        // Skip Veltra internal or installed files\n        if (\n          filename.includes(\"/veltra-router/\") ||\n          filename.includes(\"\\\\veltra-router\\\\\") ||\n          filename.includes(\"/veltra-app/\") ||\n          filename.includes(\"\\\\veltra-app\\\\\") ||\n          filename.includes(\"/node_modules/@veltra/app/\") ||\n          filename.includes(\"\\\\node_modules\\\\@veltra\\\\app\\\\\")\n        ) {\n          return;\n        }\n\n        let hasLogJsx = false;\n\n        // Check existing imports\n        path.get(\"body\").forEach((child) => {\n          if (\n            child.isImportDeclaration() &&\n            child.node.source.value === \"@veltra/app\"\n          ) {\n            child.node.specifiers.forEach((spec) => {\n              if (t.isImportSpecifier(spec)) {\n                const imported = spec.imported;\n                if (t.isIdentifier(imported) && imported.name === \"logJsx\") {\n                  hasLogJsx = true;\n                }\n              }\n            });\n          }\n        });\n\n        // Insert import if missing\n        if (!hasLogJsx) {\n          const importDecl = t.importDeclaration(\n            [t.importSpecifier(t.identifier(\"logJsx\"), t.identifier(\"logJsx\"))],\n            t.stringLiteral(\"@veltra/app\")\n          );\n          path.unshiftContainer(\"body\", importDecl);\n        }\n      },\n\n      CallExpression(path: NodePath<t.CallExpression>) {\n        const callee = path.get(\"callee\");\n\n        // Detect console.* calls\n        if (\n          t.isMemberExpression(callee.node) &&\n          t.isIdentifier(callee.node.object, { name: \"console\" }) &&\n          t.isIdentifier(callee.node.property)\n        ) {\n          // For each argument, check if JSX\n          const newArgs = path.node.arguments.map((arg) => {\n            if (t.isJSXElement(arg) || t.isJSXFragment(arg)) {\n              return t.callExpression(t.identifier(\"logJsx\"), [arg]);\n            }\n            return arg;\n          });\n\n          // Replace arguments if any JSX was wrapped\n          if (newArgs.some((arg, i) => arg !== path.node.arguments[i])) {\n            path.node.arguments = newArgs;\n          }\n        }\n      },\n    },\n  };\n});\n","import { NodePath } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\nexport const suspenseWrapPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    visitor: {\n      Program(path) {\n        let suspenseNames = new Set<string>([\"Suspense\"]);\n\n        // Detect imported Suspense aliases\n        path.traverse({\n          ImportDeclaration(importPath) {\n            if (importPath.node.source.value === \"@veltra/app\") {\n              importPath.node.specifiers.forEach((spec) => {\n                if (\n                  t.isImportSpecifier(spec) &&\n                  t.isIdentifier(spec.imported) &&\n                  spec.imported.name === \"Suspense\"\n                ) {\n                  suspenseNames.add(spec.local.name);\n                }\n              });\n            }\n          },\n        });\n\n        path.traverse({\n          JSXElement(jsxPath: NodePath<t.JSXElement>) {\n            const openingElement = jsxPath.node.openingElement;\n\n            if (\n              t.isJSXIdentifier(openingElement.name) &&\n              suspenseNames.has(openingElement.name.name)\n            ) {\n              const children = jsxPath.node.children;\n\n              if (children.length === 0) return;\n\n              // If the first child is already an expression container, skip\n              if (t.isJSXExpressionContainer(children[0])) return;\n\n              // Wrap original children in a Fragment inside an ExpressionContainer\n              const wrappedExpression = t.jSXExpressionContainer(\n                t.jSXFragment(\n                  t.jSXOpeningFragment(),\n                  t.jSXClosingFragment(),\n                  children\n                )\n              );\n\n              // Replace all children with single wrapped fragment\n              jsxPath.node.children = [wrappedExpression];\n            }\n          },\n        });\n      },\n    },\n  };\n});\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\nimport { PluginObj } from \"@babel/core\";\n\ntype Metadata = {\n  importedLoops: Set<string>;\n  localLoops: Set<string>;\n};\n\nexport const loopAutoWrapPlugin = declare((api) => {\n  api.assertVersion(7);\n  return {\n    pre() {\n      // Initialize metadata storage per file\n      const meta = this.file.metadata as Partial<Metadata>;\n      meta.importedLoops = new Set();\n      meta.localLoops = new Set();\n    },\n    visitor: {\n      Program(path, state) {\n        const meta = state.file.metadata as Metadata;\n        const importedLoops = meta.importedLoops;\n        const localLoops = meta.localLoops;\n\n        path.get(\"body\").forEach((child) => {\n          if (\n            child.isImportDeclaration() &&\n            child.node.source.value === \"@veltra/app\"\n          ) {\n            child.node.specifiers.forEach((spec) => {\n              if (\n                t.isImportSpecifier(spec) &&\n                t.isIdentifier(spec.imported, { name: \"loop\" })\n              ) {\n                importedLoops.add(spec.local.name);\n              }\n            });\n          }\n\n          if (child.isFunctionDeclaration() && t.isIdentifier(child.node.id)) {\n            localLoops.add(child.node.id.name);\n          }\n\n          if (child.isVariableDeclaration()) {\n            child.node.declarations.forEach((decl) => {\n              if (t.isIdentifier(decl.id)) {\n                localLoops.add(decl.id.name);\n              }\n            });\n          }\n        });\n      },\n\n      CallExpression(path, state) {\n        const meta = state.file.metadata as Metadata;\n        const importedLoops = meta.importedLoops;\n        const localLoops = meta.localLoops;\n\n        const callee = path.get(\"callee\");\n        if (!callee.isIdentifier()) return;\n\n        const name = callee.node.name;\n\n        if (importedLoops.has(name) && !localLoops.has(name)) {\n          if (path.node.arguments.length === 1) {\n            const arg = path.node.arguments[0];\n            if (!t.isArrowFunctionExpression(arg) && t.isExpression(arg)) {\n              path.node.arguments[0] = t.arrowFunctionExpression([], arg);\n            }\n          }\n        }\n      },\n    },\n  } satisfies PluginObj;\n});\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\n// Second plugin: Wrap every JSX expression in arrow function\nexport const wrapJSXExpressionsPlugin = declare((api) => {\n  api.assertVersion(7);\n  return {\n    visitor: {\n      JSXExpressionContainer(path) {\n        const expr = path.get(\"expression\");\n\n        // Skip wrapping if it's an empty expression (like in fragments or empty slots)\n        if (t.isJSXEmptyExpression(expr.node)) return;\n\n        path.node.expression = t.arrowFunctionExpression([], expr.node);\n      },\n    },\n  };\n});\n","import { TransformOptions, ConfigAPI } from \"@babel/core\";\n// @ts-ignore\nimport babelReactPlugin from \"@babel/preset-react\";\nimport {\n  logJsxPlugin,\n  loopAutoWrapPlugin,\n  loopMapPlugin,\n  suspenseWrapPlugin,\n  wrapJSXExpressionsPlugin,\n} from \"./plugins\";\n\n// Main preset function\nexport default function babelPresetVeltra(api: ConfigAPI): TransformOptions {\n  api.assertVersion(7);\n\n  return {\n    presets: [\n      [\n        babelReactPlugin,\n        {\n          runtime: \"automatic\",\n          importSource: \"@veltra/app\",\n        },\n      ],\n    ],\n    plugins: [\n      logJsxPlugin,\n      // loopMapPlugin,\n      loopAutoWrapPlugin,\n      suspenseWrapPlugin,\n      wrapJSXExpressionsPlugin,\n    ],\n  };\n}\n"],"names":["declare","api","path","state","filename","hasLoop","child","spec","t","imported","newImports","importDecl","expr","transformMap","exprPath","node","mapFn","arrExpr","indexParam","n","memberExpr","handleExpression","right","transformedRight","consequent","alternate","transformedCons","transformedAlt","transformed","logJsxPlugin","hasLogJsx","callee","newArgs","arg","i","suspenseWrapPlugin","suspenseNames","importPath","jsxPath","openingElement","children","wrappedExpression","loopAutoWrapPlugin","meta","importedLoops","localLoops","decl","name","wrapJSXExpressionsPlugin","babelPresetVeltra","babelReactPlugin"],"mappings":"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"}