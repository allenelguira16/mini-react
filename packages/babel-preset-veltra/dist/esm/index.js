import g from"@babel/preset-react";import{declare as f}from"@babel/helper-plugin-utils";import*as e from"@babel/types";const E=f(p=>(p.assertVersion(7),{visitor:{Program(i,a){const s=a.filename||"";if(s.includes("/veltra-router/")||s.includes("\\veltra-router\\")||s.includes("/veltra-app/")||s.includes("\\veltra-app\\")||s.includes("/node_modules/@veltra/app/")||s.includes("\\node_modules\\@veltra\\app\\"))return;let n=!1;if(i.get("body").forEach(r=>{r.isImportDeclaration()&&r.node.source.value==="@veltra/app"&&r.node.specifiers.forEach(o=>{if(e.isImportSpecifier(o)){const t=o.imported;e.isIdentifier(t)&&t.name==="logJsx"&&(n=!0)}})}),!n){const r=e.importDeclaration([e.importSpecifier(e.identifier("logJsx"),e.identifier("logJsx"))],e.stringLiteral("@veltra/app"));i.unshiftContainer("body",r)}},CallExpression(i){const a=i.get("callee");if(e.isMemberExpression(a.node)&&e.isIdentifier(a.node.object,{name:"console"})&&e.isIdentifier(a.node.property)){const s=i.node.arguments.map(n=>e.isJSXElement(n)||e.isJSXFragment(n)?e.callExpression(e.identifier("logJsx"),[n]):n);s.some((n,r)=>n!==i.node.arguments[r])&&(i.node.arguments=s)}}}})),h=f(p=>(p.assertVersion(7),{pre(){const i=this.file.metadata;i.importedLoops=new Set,i.localLoops=new Set},visitor:{Program(i,a){const s=a.file.metadata,n=s.importedLoops,r=s.localLoops;i.get("body").forEach(o=>{o.isImportDeclaration()&&o.node.source.value==="@veltra/app"&&o.node.specifiers.forEach(t=>{e.isImportSpecifier(t)&&e.isIdentifier(t.imported,{name:"loop"})&&n.add(t.local.name)}),o.isFunctionDeclaration()&&e.isIdentifier(o.node.id)&&r.add(o.node.id.name),o.isVariableDeclaration()&&o.node.declarations.forEach(t=>{e.isIdentifier(t.id)&&r.add(t.id.name)})})},CallExpression(i,a){const s=a.file.metadata,n=s.importedLoops,r=s.localLoops,o=i.get("callee");if(!o.isIdentifier())return;const t=o.node.name;if(n.has(t)&&!r.has(t)&&i.node.arguments.length===1){const l=i.node.arguments[0];!e.isArrowFunctionExpression(l)&&e.isExpression(l)&&(i.node.arguments[0]=e.arrowFunctionExpression([],l))}}}}));f(p=>(p.assertVersion(7),{visitor:{Program(i,a){const s=a.filename||"";if(s.includes("/veltra-router/")||s.includes("\\veltra-router\\")||s.includes("/veltra-app/")||s.includes("\\veltra-app\\")||s.includes("/node_modules/@veltra/app/")||s.includes("\\node_modules\\@veltra\\app\\"))return;let n=!1;i.get("body").forEach(o=>{o.isImportDeclaration()&&o.node.source.value==="@veltra/app"&&o.node.specifiers.forEach(t=>{if(e.isImportSpecifier(t)){const l=t.imported;e.isIdentifier(l)&&l.name==="loop"&&(n=!0)}})});const r=[];if(n||r.push(e.importSpecifier(e.identifier("loop"),e.identifier("loop"))),r.length){const o=e.importDeclaration(r,e.stringLiteral("@veltra/app"));i.unshiftContainer("body",o)}},JSXExpressionContainer(i){const a=i.get("expression");function s(r){const o=r.node;if(e.isCallExpression(o)&&e.isMemberExpression(o.callee)&&e.isIdentifier(o.callee.property)&&o.callee.property.name==="map"){const t=o.arguments[0],l=o.callee.object;if(e.isArrowFunctionExpression(t)&&t.params.length>=2){const c=t.params[1];e.isIdentifier(c)&&e.traverseFast(t.body,m=>{if(e.isIdentifier(m)&&m.name===c.name){const d=e.memberExpression(e.identifier(c.name),e.identifier("value"));Object.assign(m,d)}})}return e.callExpression(e.memberExpression(e.callExpression(e.identifier("loop"),[e.arrowFunctionExpression([],l)]),e.identifier("each")),[t])}return null}function n(r){const o=r.node;if(e.isLogicalExpression(o)){const t=r.get("right"),l=s(t);l&&t.replaceWith(l)}else if(e.isConditionalExpression(o)){const t=r.get("consequent"),l=r.get("alternate"),c=s(t),m=s(l);c&&t.replaceWith(c),m&&l.replaceWith(m)}else{const t=s(r);t&&r.replaceWith(t)}}n(a)}}}));const v=f(p=>(p.assertVersion(7),{name:"wrap-loop-in-memo",pre(){const i=this.file.metadata;i.importedLoops=new Set,i.hasMemoImport=!1},visitor:{Program(i,a){const s=a.file.metadata;i.get("body").forEach(n=>{if(n.isImportDeclaration()&&n.node.source.value==="@veltra/app")for(const r of n.node.specifiers)e.isImportSpecifier(r)&&e.isIdentifier(r.imported)&&(r.imported.name==="loop"&&s.importedLoops.add(r.local.name),r.imported.name==="memo"&&(s.hasMemoImport=!0))}),s.hasMemoImport||i.unshiftContainer("body",e.importDeclaration([e.importSpecifier(e.identifier("memo"),e.identifier("memo"))],e.stringLiteral("@veltra/app")))},JSXExpressionContainer(i,a){const s=a.file.metadata.importedLoops;let n=!1;i.traverse({CallExpression(r){if(n)return;const o=r.node;if(e.isMemberExpression(o.callee)&&e.isCallExpression(o.callee.object)&&e.isIdentifier(o.callee.object.callee)&&s.has(o.callee.object.callee.name)&&e.isIdentifier(o.callee.property,{name:"each"})){const t=o.callee.object,l=t.arguments[0];l&&!e.isArrowFunctionExpression(l)&&e.isExpression(l)&&(t.arguments[0]=e.arrowFunctionExpression([],l));const c=i.scope.generateUidIdentifier("loopMemo"),m=e.variableDeclaration("const",[e.variableDeclarator(c,e.callExpression(e.identifier("memo"),[e.arrowFunctionExpression([],o)]))]);i.findParent(d=>d.isBlockStatement()||d.isProgram()).unshiftContainer("body",m),r.replaceWith(e.callExpression(c,[])),n=!0}}})}}}));let I=0;const S=f(p=>(p.assertVersion(7),{name:"suspense-memo-wrapper",visitor:{Program(i){const a=new Set(["Suspense"]);let s=!1;i.traverse({ImportDeclaration(n){if(n.node.source.value==="@veltra/app")for(const r of n.node.specifiers)e.isImportSpecifier(r)&&e.isIdentifier(r.imported)&&(r.imported.name==="Suspense"&&a.add(r.local.name),r.imported.name==="memo"&&(s=!0))}}),s||i.unshiftContainer("body",e.importDeclaration([e.importSpecifier(e.identifier("memo"),e.identifier("memo"))],e.stringLiteral("@veltra/app"))),i.traverse({JSXElement(n){const r=n.node.openingElement;if(!e.isJSXIdentifier(r.name)||!a.has(r.name.name))return;const o=n.node.children.filter(u=>!e.isJSXText(u)||u.value.trim().length>0);if(o.length===0||o.length===1&&e.isJSXExpressionContainer(o[0])&&e.isArrowFunctionExpression(o[0].expression))return;const t=o.length>1?e.jsxFragment(e.jsxOpeningFragment(),e.jsxClosingFragment(),o):o[0];let l;if(e.isJSXExpressionContainer(t)){if(e.isJSXEmptyExpression(t.expression))return;l=t.expression}else l=e.parenthesizedExpression(t);const c=e.arrowFunctionExpression([],l),m=n.scope.generateUidIdentifier(`memoizedComponent${I++}`),d=e.variableDeclaration("const",[e.variableDeclarator(m,e.callExpression(e.identifier("memo"),[c]))]);n.node.children=[e.jsxExpressionContainer(e.arrowFunctionExpression([],e.callExpression(m,[])))];const x=n.findParent(u=>u.isBlockStatement()||u.isProgram());x&&(x.isProgram()||x.isBlockStatement())&&x.unshiftContainer("body",d)}})}}})),b=f(p=>(p.assertVersion(7),{name:"wrap-jsx-expressions-except-loop",pre(){const i=this.file.metadata;i.loopLocalNames=new Set},visitor:{ImportDeclaration(i,a){const s=a.file.metadata;if(i.node.source.value==="@veltra/app")for(const n of i.node.specifiers)e.isImportSpecifier(n)&&e.isIdentifier(n.imported,{name:"loop"})&&s.loopLocalNames.add(n.local.name)},JSXExpressionContainer(i,a){const s=a.file.metadata.loopLocalNames??new Set,n=i.get("expression");e.isJSXEmptyExpression(n.node)||C(n.node,s)||(i.node.expression=e.arrowFunctionExpression([],n.node))}}}));function C(p,i){return!!(e.isCallExpression(p)&&e.isIdentifier(p.callee)&&i.has(p.callee.name)||e.isCallExpression(p)&&e.isMemberExpression(p.callee)&&e.isCallExpression(p.callee.object)&&e.isIdentifier(p.callee.object.callee)&&i.has(p.callee.object.callee.name))}function w(p){return p.assertVersion(7),{presets:[[g,{runtime:"automatic",importSource:"@veltra/app"}]],plugins:[E,S,h,v,b]}}export{w as default};
//# sourceMappingURL=index.js.map
