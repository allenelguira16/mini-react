import u from"@babel/preset-react";import{declare as m}from"@babel/helper-plugin-utils";import*as e from"@babel/types";const g=m(l=>(l.assertVersion(7),{visitor:{Program(i,a){const o=a.filename||"";if(o.includes("/veltra-router/")||o.includes("\\veltra-router\\")||o.includes("/veltra-app/")||o.includes("\\veltra-app\\")||o.includes("/node_modules/@veltra/app/")||o.includes("\\node_modules\\@veltra\\app\\"))return;let r=!1;if(i.get("body").forEach(s=>{s.isImportDeclaration()&&s.node.source.value==="@veltra/app"&&s.node.specifiers.forEach(n=>{if(e.isImportSpecifier(n)){const t=n.imported;e.isIdentifier(t)&&t.name==="logJsx"&&(r=!0)}})}),!r){const s=e.importDeclaration([e.importSpecifier(e.identifier("logJsx"),e.identifier("logJsx"))],e.stringLiteral("@veltra/app"));i.unshiftContainer("body",s)}},CallExpression(i){const a=i.get("callee");if(e.isMemberExpression(a.node)&&e.isIdentifier(a.node.object,{name:"console"})&&e.isIdentifier(a.node.property)){const o=i.node.arguments.map(r=>e.isJSXElement(r)||e.isJSXFragment(r)?e.callExpression(e.identifier("logJsx"),[r]):r);o.some((r,s)=>r!==i.node.arguments[s])&&(i.node.arguments=o)}}}})),E=m(l=>(l.assertVersion(7),{pre(){const i=this.file.metadata;i.importedLoops=new Set,i.localLoops=new Set},visitor:{Program(i,a){const o=a.file.metadata,r=o.importedLoops,s=o.localLoops;i.get("body").forEach(n=>{n.isImportDeclaration()&&n.node.source.value==="@veltra/app"&&n.node.specifiers.forEach(t=>{e.isImportSpecifier(t)&&e.isIdentifier(t.imported,{name:"loop"})&&r.add(t.local.name)}),n.isFunctionDeclaration()&&e.isIdentifier(n.node.id)&&s.add(n.node.id.name),n.isVariableDeclaration()&&n.node.declarations.forEach(t=>{e.isIdentifier(t.id)&&s.add(t.id.name)})})},CallExpression(i,a){const o=a.file.metadata,r=o.importedLoops,s=o.localLoops,n=i.get("callee");if(!n.isIdentifier())return;const t=n.node.name;if(r.has(t)&&!s.has(t)&&i.node.arguments.length===1){const p=i.node.arguments[0];!e.isArrowFunctionExpression(p)&&e.isExpression(p)&&(i.node.arguments[0]=e.arrowFunctionExpression([],p))}}}}));m(l=>(l.assertVersion(7),{visitor:{Program(i,a){const o=a.filename||"";if(o.includes("/veltra-router/")||o.includes("\\veltra-router\\")||o.includes("/veltra-app/")||o.includes("\\veltra-app\\")||o.includes("/node_modules/@veltra/app/")||o.includes("\\node_modules\\@veltra\\app\\"))return;let r=!1;i.get("body").forEach(n=>{n.isImportDeclaration()&&n.node.source.value==="@veltra/app"&&n.node.specifiers.forEach(t=>{if(e.isImportSpecifier(t)){const p=t.imported;e.isIdentifier(p)&&p.name==="loop"&&(r=!0)}})});const s=[];if(r||s.push(e.importSpecifier(e.identifier("loop"),e.identifier("loop"))),s.length){const n=e.importDeclaration(s,e.stringLiteral("@veltra/app"));i.unshiftContainer("body",n)}},JSXExpressionContainer(i){const a=i.get("expression");function o(s){const n=s.node;if(e.isCallExpression(n)&&e.isMemberExpression(n.callee)&&e.isIdentifier(n.callee.property)&&n.callee.property.name==="map"){const t=n.arguments[0],p=n.callee.object;if(e.isArrowFunctionExpression(t)&&t.params.length>=2){const c=t.params[1];e.isIdentifier(c)&&e.traverseFast(t.body,d=>{if(e.isIdentifier(d)&&d.name===c.name){const f=e.memberExpression(e.identifier(c.name),e.identifier("value"));Object.assign(d,f)}})}return e.callExpression(e.memberExpression(e.callExpression(e.identifier("loop"),[e.arrowFunctionExpression([],p)]),e.identifier("each")),[t])}return null}function r(s){const n=s.node;if(e.isLogicalExpression(n)){const t=s.get("right"),p=o(t);p&&t.replaceWith(p)}else if(e.isConditionalExpression(n)){const t=s.get("consequent"),p=s.get("alternate"),c=o(t),d=o(p);c&&t.replaceWith(c),d&&p.replaceWith(d)}else{const t=o(s);t&&s.replaceWith(t)}}r(a)}}}));const x=m(l=>(l.assertVersion(7),{name:"wrap-loop-in-memo",pre(){const i=this.file.metadata;i.importedLoops=new Set,i.hasMemoImport=!1},visitor:{Program(i,a){const o=a.file.metadata;i.get("body").forEach(r=>{if(r.isImportDeclaration()&&r.node.source.value==="@veltra/app")for(const s of r.node.specifiers)e.isImportSpecifier(s)&&e.isIdentifier(s.imported)&&(s.imported.name==="loop"&&o.importedLoops.add(s.local.name),s.imported.name==="memo"&&(o.hasMemoImport=!0))}),o.hasMemoImport||i.unshiftContainer("body",e.importDeclaration([e.importSpecifier(e.identifier("memo"),e.identifier("memo"))],e.stringLiteral("@veltra/app")))},JSXExpressionContainer(i,a){const o=a.file.metadata.importedLoops;let r=!1;i.traverse({CallExpression(s){if(r)return;const n=s.node;if(e.isMemberExpression(n.callee)&&e.isCallExpression(n.callee.object)&&e.isIdentifier(n.callee.object.callee)&&o.has(n.callee.object.callee.name)&&e.isIdentifier(n.callee.property,{name:"each"})){const t=n.callee.object,p=t.arguments[0];p&&!e.isArrowFunctionExpression(p)&&e.isExpression(p)&&(t.arguments[0]=e.arrowFunctionExpression([],p));const c=i.scope.generateUidIdentifier("loopMemo"),d=e.variableDeclaration("const",[e.variableDeclarator(c,e.callExpression(e.identifier("memo"),[e.arrowFunctionExpression([],n)]))]);i.findParent(f=>f.isBlockStatement()||f.isProgram()).unshiftContainer("body",d),s.replaceWith(e.callExpression(c,[])),r=!0}}})}}})),v=m(l=>(l.assertVersion(7),{visitor:{Program(i){const a=new Set(["Suspense"]);i.traverse({ImportDeclaration(o){o.node.source.value==="@veltra/app"&&o.node.specifiers.forEach(r=>{e.isImportSpecifier(r)&&e.isIdentifier(r.imported)&&r.imported.name==="Suspense"&&a.add(r.local.name)})}}),i.traverse({JSXElement(o){const r=o.node.openingElement;if(e.isJSXIdentifier(r.name)&&a.has(r.name.name)){const s=o.node.children;if(s.length===0||e.isJSXExpressionContainer(s[0]))return;const n=e.jSXExpressionContainer(e.jSXFragment(e.jSXOpeningFragment(),e.jSXClosingFragment(),s));o.node.children=[n]}}})}}})),h=m(l=>(l.assertVersion(7),{name:"wrap-jsx-expressions-except-loop",pre(){const i=this.file.metadata;i.loopLocalNames=new Set},visitor:{ImportDeclaration(i,a){const o=a.file.metadata;if(i.node.source.value==="@veltra/app")for(const r of i.node.specifiers)e.isImportSpecifier(r)&&e.isIdentifier(r.imported,{name:"loop"})&&o.loopLocalNames.add(r.local.name)},JSXExpressionContainer(i,a){const o=a.file.metadata.loopLocalNames??new Set,r=i.get("expression");e.isJSXEmptyExpression(r.node)||I(r.node,o)||(i.node.expression=e.arrowFunctionExpression([],r.node))}}}));function I(l,i){return!!(e.isCallExpression(l)&&e.isIdentifier(l.callee)&&i.has(l.callee.name)||e.isCallExpression(l)&&e.isMemberExpression(l.callee)&&e.isCallExpression(l.callee.object)&&e.isIdentifier(l.callee.object.callee)&&i.has(l.callee.object.callee.name))}function S(l){return l.assertVersion(7),{presets:[[u,{runtime:"automatic",importSource:"@veltra/app"}]],plugins:[g,v,E,x,h]}}export{S as default};
//# sourceMappingURL=index.js.map
