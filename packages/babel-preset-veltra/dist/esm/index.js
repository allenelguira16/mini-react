import u from"@babel/preset-react";import{declare as m}from"@babel/helper-plugin-utils";import*as e from"@babel/types";const g=m(l=>(l.assertVersion(7),{visitor:{Program(t,a){const i=a.filename||"";if(i.includes("/veltra-app/")||i.includes("\\veltra-app\\")||i.includes("/node_modules/@veltra/app/")||i.includes("\\node_modules\\@veltra\\app\\"))return;let s=!1;t.get("body").forEach(o=>{o.isImportDeclaration()&&o.node.source.value==="@veltra/app"&&o.node.specifiers.forEach(r=>{if(e.isImportSpecifier(r)){const p=r.imported;e.isIdentifier(p)&&p.name==="loop"&&(s=!0)}})});const n=[];if(s||n.push(e.importSpecifier(e.identifier("loop"),e.identifier("loop"))),n.length){const o=e.importDeclaration(n,e.stringLiteral("@veltra/app"));t.unshiftContainer("body",o)}},JSXExpressionContainer(t){const a=t.get("expression");function i(n){const o=n.node;if(e.isCallExpression(o)&&e.isMemberExpression(o.callee)&&e.isIdentifier(o.callee.property)&&o.callee.property.name==="map"){const r=o.arguments[0],p=o.callee.object;if(e.isArrowFunctionExpression(r)&&r.params.length>=2){const c=r.params[1];e.isIdentifier(c)&&e.traverseFast(r.body,d=>{if(e.isIdentifier(d)&&d.name===c.name){const f=e.memberExpression(e.identifier(c.name),e.identifier("value"));Object.assign(d,f)}})}return e.callExpression(e.memberExpression(e.callExpression(e.identifier("loop"),[e.arrowFunctionExpression([],p)]),e.identifier("each")),[r])}return null}function s(n){const o=n.node;if(e.isLogicalExpression(o)){const r=n.get("right"),p=i(r);p&&r.replaceWith(p)}else if(e.isConditionalExpression(o)){const r=n.get("consequent"),p=n.get("alternate"),c=i(r),d=i(p);c&&r.replaceWith(c),d&&p.replaceWith(d)}else{const r=i(n);r&&n.replaceWith(r)}}s(a)}}})),x=m(l=>(l.assertVersion(7),{visitor:{Program(t,a){const i=a.filename||"";if(i.includes("/veltra-app/")||i.includes("\\veltra-app\\")||i.includes("/node_modules/@veltra/app/")||i.includes("\\node_modules\\@veltra\\app\\"))return;let s=!1;if(t.get("body").forEach(n=>{n.isImportDeclaration()&&n.node.source.value==="@veltra/app"&&n.node.specifiers.forEach(o=>{if(e.isImportSpecifier(o)){const r=o.imported;e.isIdentifier(r)&&r.name==="logJsx"&&(s=!0)}})}),!s){const n=e.importDeclaration([e.importSpecifier(e.identifier("logJsx"),e.identifier("logJsx"))],e.stringLiteral("@veltra/app"));t.unshiftContainer("body",n)}},CallExpression(t){const a=t.get("callee");if(e.isMemberExpression(a.node)&&e.isIdentifier(a.node.object,{name:"console"})&&e.isIdentifier(a.node.property)){const i=t.node.arguments.map(s=>e.isJSXElement(s)||e.isJSXFragment(s)?e.callExpression(e.identifier("logJsx"),[s]):s);i.some((s,n)=>s!==t.node.arguments[n])&&(t.node.arguments=i)}}}})),E=m(l=>(l.assertVersion(7),{visitor:{Program(t){let a=new Set(["Suspense"]);t.traverse({ImportDeclaration(i){i.node.source.value==="@veltra/app"&&i.node.specifiers.forEach(s=>{e.isImportSpecifier(s)&&e.isIdentifier(s.imported)&&s.imported.name==="Suspense"&&a.add(s.local.name)})}}),t.traverse({JSXElement(i){const s=i.node.openingElement;if(e.isJSXIdentifier(s.name)&&a.has(s.name.name)){const n=i.node.children;if(n.length===0||e.isJSXExpressionContainer(n[0]))return;const o=e.jSXExpressionContainer(e.jSXFragment(e.jSXOpeningFragment(),e.jSXClosingFragment(),n));i.node.children=[o]}}})}}})),v=m(l=>(l.assertVersion(7),{visitor:{JSXExpressionContainer(t){const a=t.get("expression");e.isJSXEmptyExpression(a.node)||(t.node.expression=e.arrowFunctionExpression([],a.node))}}}));function S(l){return l.assertVersion(7),{presets:[[u,{runtime:"automatic",importSource:"@veltra/app"}]],plugins:[x,g,E,v]}}export{S as default};
//# sourceMappingURL=index.js.map
