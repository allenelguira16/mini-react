import u from"@babel/preset-react";import{declare as f}from"@babel/helper-plugin-utils";import*as e from"@babel/types";const g=f(p=>(p.assertVersion(7),{visitor:{Program(r,a){const s=a.filename||"";if(s.includes("/veltra-app/")||s.includes("\\veltra-app\\")||s.includes("/node_modules/@veltra/app/")||s.includes("\\node_modules\\@veltra\\app\\"))return;let t=!1;r.get("body").forEach(o=>{o.isImportDeclaration()&&o.node.source.value==="@veltra/app"&&o.node.specifiers.forEach(n=>{if(e.isImportSpecifier(n)){const l=n.imported;e.isIdentifier(l)&&l.name==="loop"&&(t=!0)}})});const i=[];if(t||i.push(e.importSpecifier(e.identifier("loop"),e.identifier("loop"))),i.length){const o=e.importDeclaration(i,e.stringLiteral("@veltra/app"));r.unshiftContainer("body",o)}},JSXExpressionContainer(r){const a=r.get("expression");function s(i){const o=i.node;if(e.isCallExpression(o)&&e.isMemberExpression(o.callee)&&e.isIdentifier(o.callee.property)&&o.callee.property.name==="map"){const n=o.arguments[0],l=o.callee.object;if(e.isArrowFunctionExpression(n)&&n.params.length>=2){const c=n.params[1];e.isIdentifier(c)&&e.traverseFast(n.body,d=>{if(e.isIdentifier(d)&&d.name===c.name){const m=e.memberExpression(e.identifier(c.name),e.identifier("value"));Object.assign(d,m)}})}return e.callExpression(e.memberExpression(e.callExpression(e.identifier("loop"),[e.arrowFunctionExpression([],l)]),e.identifier("each")),[n])}return null}function t(i){const o=i.node;if(e.isLogicalExpression(o)){const n=i.get("right"),l=s(n);l&&n.replaceWith(l)}else if(e.isConditionalExpression(o)){const n=i.get("consequent"),l=i.get("alternate"),c=s(n),d=s(l);c&&n.replaceWith(c),d&&l.replaceWith(d)}else{const n=s(i);n&&i.replaceWith(n)}}t(a)}}})),x=f(p=>(p.assertVersion(7),{visitor:{Program(r,a){const s=a.filename||"";if(s.includes("/veltra-app/")||s.includes("\\veltra-app\\")||s.includes("/node_modules/@veltra/app/")||s.includes("\\node_modules\\@veltra\\app\\"))return;let t=!1;if(r.get("body").forEach(i=>{i.isImportDeclaration()&&i.node.source.value==="@veltra/app"&&i.node.specifiers.forEach(o=>{if(e.isImportSpecifier(o)){const n=o.imported;e.isIdentifier(n)&&n.name==="logJsx"&&(t=!0)}})}),!t){const i=e.importDeclaration([e.importSpecifier(e.identifier("logJsx"),e.identifier("logJsx"))],e.stringLiteral("@veltra/app"));r.unshiftContainer("body",i)}},CallExpression(r){const a=r.get("callee");if(e.isMemberExpression(a.node)&&e.isIdentifier(a.node.object,{name:"console"})&&e.isIdentifier(a.node.property)){const s=r.node.arguments.map(t=>e.isJSXElement(t)||e.isJSXFragment(t)?e.callExpression(e.identifier("logJsx"),[t]):t);s.some((t,i)=>t!==r.node.arguments[i])&&(r.node.arguments=s)}}}})),E=f(p=>(p.assertVersion(7),{visitor:{JSXExpressionContainer(r){const a=r.get("expression");e.isJSXEmptyExpression(a.node)||(r.node.expression=e.arrowFunctionExpression([],a.node))}}}));function v(p){return p.assertVersion(7),{presets:[[u,{runtime:"automatic",importSource:"@veltra/app"}]],plugins:[g,x,E]}}export{v as default};
//# sourceMappingURL=index.js.map
