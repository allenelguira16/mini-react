import u from"@babel/preset-react";import{declare as m}from"@babel/helper-plugin-utils";import*as e from"@babel/types";m(p=>(p.assertVersion(7),{visitor:{Program(s,a){const i=a.filename||"";if(i.includes("/veltra-router/")||i.includes("\\veltra-router\\")||i.includes("/veltra-app/")||i.includes("\\veltra-app\\")||i.includes("/node_modules/@veltra/app/")||i.includes("\\node_modules\\@veltra\\app\\"))return;let t=!1;s.get("body").forEach(n=>{n.isImportDeclaration()&&n.node.source.value==="@veltra/app"&&n.node.specifiers.forEach(r=>{if(e.isImportSpecifier(r)){const l=r.imported;e.isIdentifier(l)&&l.name==="loop"&&(t=!0)}})});const o=[];if(t||o.push(e.importSpecifier(e.identifier("loop"),e.identifier("loop"))),o.length){const n=e.importDeclaration(o,e.stringLiteral("@veltra/app"));s.unshiftContainer("body",n)}},JSXExpressionContainer(s){const a=s.get("expression");function i(o){const n=o.node;if(e.isCallExpression(n)&&e.isMemberExpression(n.callee)&&e.isIdentifier(n.callee.property)&&n.callee.property.name==="map"){const r=n.arguments[0],l=n.callee.object;if(e.isArrowFunctionExpression(r)&&r.params.length>=2){const c=r.params[1];e.isIdentifier(c)&&e.traverseFast(r.body,d=>{if(e.isIdentifier(d)&&d.name===c.name){const f=e.memberExpression(e.identifier(c.name),e.identifier("value"));Object.assign(d,f)}})}return e.callExpression(e.memberExpression(e.callExpression(e.identifier("loop"),[e.arrowFunctionExpression([],l)]),e.identifier("each")),[r])}return null}function t(o){const n=o.node;if(e.isLogicalExpression(n)){const r=o.get("right"),l=i(r);l&&r.replaceWith(l)}else if(e.isConditionalExpression(n)){const r=o.get("consequent"),l=o.get("alternate"),c=i(r),d=i(l);c&&r.replaceWith(c),d&&l.replaceWith(d)}else{const r=i(o);r&&o.replaceWith(r)}}t(a)}}}));const g=m(p=>(p.assertVersion(7),{visitor:{Program(s,a){const i=a.filename||"";if(i.includes("/veltra-router/")||i.includes("\\veltra-router\\")||i.includes("/veltra-app/")||i.includes("\\veltra-app\\")||i.includes("/node_modules/@veltra/app/")||i.includes("\\node_modules\\@veltra\\app\\"))return;let t=!1;if(s.get("body").forEach(o=>{o.isImportDeclaration()&&o.node.source.value==="@veltra/app"&&o.node.specifiers.forEach(n=>{if(e.isImportSpecifier(n)){const r=n.imported;e.isIdentifier(r)&&r.name==="logJsx"&&(t=!0)}})}),!t){const o=e.importDeclaration([e.importSpecifier(e.identifier("logJsx"),e.identifier("logJsx"))],e.stringLiteral("@veltra/app"));s.unshiftContainer("body",o)}},CallExpression(s){const a=s.get("callee");if(e.isMemberExpression(a.node)&&e.isIdentifier(a.node.object,{name:"console"})&&e.isIdentifier(a.node.property)){const i=s.node.arguments.map(t=>e.isJSXElement(t)||e.isJSXFragment(t)?e.callExpression(e.identifier("logJsx"),[t]):t);i.some((t,o)=>t!==s.node.arguments[o])&&(s.node.arguments=i)}}}})),E=m(p=>(p.assertVersion(7),{visitor:{Program(s){let a=new Set(["Suspense"]);s.traverse({ImportDeclaration(i){i.node.source.value==="@veltra/app"&&i.node.specifiers.forEach(t=>{e.isImportSpecifier(t)&&e.isIdentifier(t.imported)&&t.imported.name==="Suspense"&&a.add(t.local.name)})}}),s.traverse({JSXElement(i){const t=i.node.openingElement;if(e.isJSXIdentifier(t.name)&&a.has(t.name.name)){const o=i.node.children;if(o.length===0||e.isJSXExpressionContainer(o[0]))return;const n=e.jSXExpressionContainer(e.jSXFragment(e.jSXOpeningFragment(),e.jSXClosingFragment(),o));i.node.children=[n]}}})}}})),x=m(p=>(p.assertVersion(7),{pre(){const s=this.file.metadata;s.importedLoops=new Set,s.localLoops=new Set},visitor:{Program(s,a){const i=a.file.metadata,t=i.importedLoops,o=i.localLoops;s.get("body").forEach(n=>{n.isImportDeclaration()&&n.node.source.value==="@veltra/app"&&n.node.specifiers.forEach(r=>{e.isImportSpecifier(r)&&e.isIdentifier(r.imported,{name:"loop"})&&t.add(r.local.name)}),n.isFunctionDeclaration()&&e.isIdentifier(n.node.id)&&o.add(n.node.id.name),n.isVariableDeclaration()&&n.node.declarations.forEach(r=>{e.isIdentifier(r.id)&&o.add(r.id.name)})})},CallExpression(s,a){const i=a.file.metadata,t=i.importedLoops,o=i.localLoops,n=s.get("callee");if(!n.isIdentifier())return;const r=n.node.name;if(t.has(r)&&!o.has(r)&&s.node.arguments.length===1){const l=s.node.arguments[0];!e.isArrowFunctionExpression(l)&&e.isExpression(l)&&(s.node.arguments[0]=e.arrowFunctionExpression([],l))}}}})),v=m(p=>(p.assertVersion(7),{visitor:{JSXExpressionContainer(s){const a=s.get("expression");e.isJSXEmptyExpression(a.node)||(s.node.expression=e.arrowFunctionExpression([],a.node))}}}));function h(p){return p.assertVersion(7),{presets:[[u,{runtime:"automatic",importSource:"@veltra/app"}]],plugins:[g,x,E,v]}}export{h as default};
//# sourceMappingURL=index.js.map
