import{declare as d}from"@babel/helper-plugin-utils";import*as e from"@babel/types";import u from"@babel/preset-react";function x(n){const i=e.arrowFunctionExpression([],n);return i.loc=n.loc,i}const m=new Set;function E(n,i){if(i.filename&&i.filename.includes("veltra-app"))return;let r=!1,o=!1;n.traverse({ImportDeclaration(l){if(l.node.source.value==="@veltra/app"){l.node.specifiers.forEach(a=>{if(e.isImportSpecifier(a)){let p="";e.isIdentifier(a.imported)?p=a.imported.name:e.isStringLiteral(a.imported)&&(p=a.imported.value);const f=a.local.name;p==="loop"&&m.add(f)}});const t=l.node.specifiers,s=t.some(a=>e.isImportSpecifier(a)&&e.isIdentifier(a.imported,{name:"memo"})),c=t.some(a=>e.isImportSpecifier(a)&&e.isIdentifier(a.imported,{name:"cleanLog"}));s||t.push(e.importSpecifier(e.identifier("memo"),e.identifier("memo"))),c||t.push(e.importSpecifier(e.identifier("cleanLog"),e.identifier("cleanLog"))),r=r||s,o=o||c}}}),r||n.node.body.unshift(e.importDeclaration([e.importSpecifier(e.identifier("memo"),e.identifier("memo"))],e.stringLiteral("@veltra/app"))),o||n.node.body.unshift(e.importDeclaration([e.importSpecifier(e.identifier("cleanLog"),e.identifier("cleanLog"))],e.stringLiteral("@veltra/app")))}function g(n){const i=n.node.callee;if(e.isMemberExpression(i)&&e.isIdentifier(i.object,{name:"console"})){n.node.arguments=n.node.arguments.map(r=>e.isJSXElement(r)||e.isJSXFragment(r)?e.callExpression(e.identifier("cleanLog"),[r]):r);return}if(e.isCallExpression(n.node)&&e.isIdentifier(n.node.callee)&&m.has(n.node.callee.name)){const r=n.scope.getBinding(n.node.callee.name);if(r&&r.path.isImportSpecifier()&&r.path.parentPath&&r.path.parentPath.isImportDeclaration()&&r.path.parentPath.node.source.value==="@veltra/app"){const o=n.node.arguments[0];!e.isFunction(o)&&e.isExpression(o)&&(n.node.arguments[0]=e.arrowFunctionExpression([],o))}}}function S(n){const i=n.node.expression;if(e.isLogicalExpression(i)&&i.operator==="&&"&&e.isJSXElement(i.right)){const r=i.right,o=n.findParent(s=>s.isProgram()||s.isFunction()),l=n.scope.generateUidIdentifier("memoized"),t=e.variableDeclaration("const",[e.variableDeclarator(l,e.callExpression(e.identifier("memo"),[e.arrowFunctionExpression([],r)]))]);if(o){if(o.isProgram())o.unshiftContainer("body",t);else if(o.isFunctionDeclaration()||o.isFunctionExpression()||o.isArrowFunctionExpression()){const s=o.get("body");if(Array.isArray(s)){const c=s[0];c&&c.isBlockStatement()&&c.unshiftContainer("body",t)}else s.isBlockStatement()&&s.unshiftContainer("body",t)}}n.node.expression=e.arrowFunctionExpression([],e.logicalExpression("&&",i.left,e.callExpression(l,[])));return}!e.isJSXEmptyExpression(i)&&!e.isJSXElement(i)&&!e.isJSXFragment(i)&&(n.node.expression=x(i))}function b(n){const i=n.node;if(e.isJSXIdentifier(i.name,{name:"ref"})&&e.isJSXExpressionContainer(i.value)){const r=i.value.expression;if(e.isIdentifier(r)){const o=e.identifier("el"),l=e.assignmentExpression("=",r,o);i.value.expression=e.arrowFunctionExpression([o],l)}}e.isJSXExpressionContainer(i.value)&&(e.isJSXElement(i.value.expression)||e.isJSXFragment(i.value.expression))&&(i.value.expression=e.arrowFunctionExpression([],i.value.expression))}function v(n){const i=n.node.expression;if(e.isCallExpression(i)&&e.isMemberExpression(i.callee)&&e.isCallExpression(i.callee.object)&&e.isIdentifier(i.callee.object.callee)&&m.has(i.callee.object.callee.name)&&e.isIdentifier(i.callee.property,{name:"each"})){const r=n.findParent(s=>s.isProgram()||s.isFunction()),o=n.scope.generateUidIdentifier("looped"),l=e.callExpression(e.identifier("memo"),[e.arrowFunctionExpression([],i)]),t=e.variableDeclaration("const",[e.variableDeclarator(o,l)]);if(r){if(r.isProgram())r.unshiftContainer("body",t);else if(r.isFunctionDeclaration()||r.isFunctionExpression()||r.isArrowFunctionExpression()){const s=r.get("body");Array.isArray(s)?s.forEach(c=>{c.isBlockStatement()&&c.unshiftContainer("body",t)}):s.isBlockStatement()&&s.unshiftContainer("body",t)}}n.node.expression=e.callExpression(o,[])}}const h=d(n=>(n.assertVersion(7),{name:"veltra-plugin-babel",visitor:{Program(i,r){E(i,r)},JSXExpressionContainer(i){v(i),S(i)},JSXAttribute(i){b(i)},CallExpression(i){g(i)}}}));function F(n){return n.assertVersion(7),{presets:[[u,{runtime:"automatic",importSource:"@veltra/app"}]],plugins:[h]}}export{F as default};
//# sourceMappingURL=index.js.map
