import f from"@babel/preset-react";import{declare as m}from"@babel/helper-plugin-utils";import*as e from"@babel/types";const g=m(p=>(p.assertVersion(7),{visitor:{Program(t,a){const i=a.filename||"";if(i.includes("/veltra-router/")||i.includes("\\veltra-router\\")||i.includes("/veltra-app/")||i.includes("\\veltra-app\\")||i.includes("/node_modules/@veltra/app/")||i.includes("\\node_modules\\@veltra\\app\\"))return;let r=!1;t.get("body").forEach(s=>{s.isImportDeclaration()&&s.node.source.value==="@veltra/app"&&s.node.specifiers.forEach(o=>{if(e.isImportSpecifier(o)){const l=o.imported;e.isIdentifier(l)&&l.name==="loop"&&(r=!0)}})});const n=[];if(r||n.push(e.importSpecifier(e.identifier("loop"),e.identifier("loop"))),n.length){const s=e.importDeclaration(n,e.stringLiteral("@veltra/app"));t.unshiftContainer("body",s)}},JSXExpressionContainer(t){const a=t.get("expression");function i(n){const s=n.node;if(e.isCallExpression(s)&&e.isMemberExpression(s.callee)&&e.isIdentifier(s.callee.property)&&s.callee.property.name==="map"){const o=s.arguments[0],l=s.callee.object;if(e.isArrowFunctionExpression(o)&&o.params.length>=2){const c=o.params[1];e.isIdentifier(c)&&e.traverseFast(o.body,d=>{if(e.isIdentifier(d)&&d.name===c.name){const u=e.memberExpression(e.identifier(c.name),e.identifier("value"));Object.assign(d,u)}})}return e.callExpression(e.memberExpression(e.callExpression(e.identifier("loop"),[e.arrowFunctionExpression([],l)]),e.identifier("each")),[o])}return null}function r(n){const s=n.node;if(e.isLogicalExpression(s)){const o=n.get("right"),l=i(o);l&&o.replaceWith(l)}else if(e.isConditionalExpression(s)){const o=n.get("consequent"),l=n.get("alternate"),c=i(o),d=i(l);c&&o.replaceWith(c),d&&l.replaceWith(d)}else{const o=i(n);o&&n.replaceWith(o)}}r(a)}}})),v=m(p=>(p.assertVersion(7),{visitor:{Program(t,a){const i=a.filename||"";if(i.includes("/veltra-router/")||i.includes("\\veltra-router\\")||i.includes("/veltra-app/")||i.includes("\\veltra-app\\")||i.includes("/node_modules/@veltra/app/")||i.includes("\\node_modules\\@veltra\\app\\"))return;let r=!1;if(t.get("body").forEach(n=>{n.isImportDeclaration()&&n.node.source.value==="@veltra/app"&&n.node.specifiers.forEach(s=>{if(e.isImportSpecifier(s)){const o=s.imported;e.isIdentifier(o)&&o.name==="logJsx"&&(r=!0)}})}),!r){const n=e.importDeclaration([e.importSpecifier(e.identifier("logJsx"),e.identifier("logJsx"))],e.stringLiteral("@veltra/app"));t.unshiftContainer("body",n)}},CallExpression(t){const a=t.get("callee");if(e.isMemberExpression(a.node)&&e.isIdentifier(a.node.object,{name:"console"})&&e.isIdentifier(a.node.property)){const i=t.node.arguments.map(r=>e.isJSXElement(r)||e.isJSXFragment(r)?e.callExpression(e.identifier("logJsx"),[r]):r);i.some((r,n)=>r!==t.node.arguments[n])&&(t.node.arguments=i)}}}})),x=m(p=>(p.assertVersion(7),{visitor:{Program(t){let a=new Set(["Suspense"]);t.traverse({ImportDeclaration(i){i.node.source.value==="@veltra/app"&&i.node.specifiers.forEach(r=>{e.isImportSpecifier(r)&&e.isIdentifier(r.imported)&&r.imported.name==="Suspense"&&a.add(r.local.name)})}}),t.traverse({JSXElement(i){const r=i.node.openingElement;if(e.isJSXIdentifier(r.name)&&a.has(r.name.name)){const n=i.node.children;if(n.length===0||e.isJSXExpressionContainer(n[0]))return;const s=e.jSXExpressionContainer(e.jSXFragment(e.jSXOpeningFragment(),e.jSXClosingFragment(),n));i.node.children=[s]}}})}}})),E=m(p=>(p.assertVersion(7),{visitor:{JSXExpressionContainer(t){const a=t.get("expression");e.isJSXEmptyExpression(a.node)||(t.node.expression=e.arrowFunctionExpression([],a.node))}}}));function S(p){return p.assertVersion(7),{presets:[[f,{runtime:"automatic",importSource:"@veltra/app"}]],plugins:[v,g,x,E]}}export{S as default};
//# sourceMappingURL=index.js.map
