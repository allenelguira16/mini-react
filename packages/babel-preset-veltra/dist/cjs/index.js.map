{"version":3,"file":"index.js","sources":["../../src/utils/wrapExpressionInArrow.ts","../../src/babel-plugin.ts","../../src/index.ts"],"sourcesContent":["import * as t from \"@babel/types\";\n\nexport function wrapExpressionInArrow<T extends t.Expression>(expr: T) {\n  const arrow = t.arrowFunctionExpression([], expr);\n  arrow.loc = expr.loc;\n  return arrow;\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\nimport { wrapExpressionInArrow } from \"./utils\";\nimport { NodePath, PluginPass } from \"@babel/core\";\n\nconst veltraImports = new Set<string>();\n\nfunction handleImports(path: NodePath<t.Program>, state: PluginPass) {\n  const isInVeltraApp = state.filename && state.filename.includes(\"veltra-app\");\n  if (isInVeltraApp) return;\n\n  let hasMemoImport = false;\n  let hasCleanLogImport = false;\n\n  path.traverse({\n    ImportDeclaration(importPath) {\n      const importSource = importPath.node.source.value;\n\n      if (importSource === \"@veltra/app\") {\n        importPath.node.specifiers.forEach((specifier) => {\n          if (t.isImportSpecifier(specifier)) {\n            let importedName = \"\";\n            if (t.isIdentifier(specifier.imported)) {\n              importedName = specifier.imported.name;\n            } else if (t.isStringLiteral(specifier.imported)) {\n              importedName = specifier.imported.value;\n            }\n\n            const localName = specifier.local.name; // ← actual used name (could be aliased)\n\n            if (importedName === \"loop\") {\n              veltraImports.add(localName); // ← this could now be \"loop\" or \"looper\" or any alias\n            }\n          }\n        });\n\n        const specifiers = importPath.node.specifiers;\n\n        const hasMemo = specifiers.some(\n          (s) =>\n            t.isImportSpecifier(s) &&\n            t.isIdentifier(s.imported, { name: \"memo\" })\n        );\n\n        const hasCleanLog = specifiers.some(\n          (s) =>\n            t.isImportSpecifier(s) &&\n            t.isIdentifier(s.imported, { name: \"cleanLog\" })\n        );\n\n        if (!hasMemo) {\n          specifiers.push(\n            t.importSpecifier(t.identifier(\"memo\"), t.identifier(\"memo\"))\n          );\n        }\n        if (!hasCleanLog) {\n          specifiers.push(\n            t.importSpecifier(\n              t.identifier(\"cleanLog\"),\n              t.identifier(\"cleanLog\")\n            )\n          );\n        }\n\n        hasMemoImport = hasMemoImport || hasMemo;\n        hasCleanLogImport = hasCleanLogImport || hasCleanLog;\n      }\n    },\n  });\n\n  if (!hasMemoImport) {\n    path.node.body.unshift(\n      t.importDeclaration(\n        [t.importSpecifier(t.identifier(\"memo\"), t.identifier(\"memo\"))],\n        t.stringLiteral(\"@veltra/app\")\n      )\n    );\n  }\n\n  if (!hasCleanLogImport) {\n    path.node.body.unshift(\n      t.importDeclaration(\n        [t.importSpecifier(t.identifier(\"cleanLog\"), t.identifier(\"cleanLog\"))],\n        t.stringLiteral(\"@veltra/app\")\n      )\n    );\n  }\n}\n\nfunction handleCallExpression(path: NodePath<t.CallExpression>) {\n  const callee = path.node.callee;\n\n  // Check for console.* calls\n  const isConsole =\n    t.isMemberExpression(callee) &&\n    t.isIdentifier(callee.object, { name: \"console\" });\n\n  if (isConsole) {\n    path.node.arguments = path.node.arguments.map((arg) => {\n      if (t.isJSXElement(arg) || t.isJSXFragment(arg)) {\n        return t.callExpression(t.identifier(\"cleanLog\"), [arg]);\n      }\n      return arg;\n    });\n    return;\n  }\n\n  // Handle loop().each()\n  if (\n    t.isCallExpression(path.node) &&\n    t.isIdentifier(path.node.callee) &&\n    veltraImports.has(path.node.callee.name) // check for ANY valid imported alias\n  ) {\n    const binding = path.scope.getBinding(path.node.callee.name);\n\n    if (\n      binding &&\n      binding.path.isImportSpecifier() &&\n      binding.path.parentPath &&\n      binding.path.parentPath.isImportDeclaration()\n    ) {\n      const importDecl = binding.path.parentPath.node;\n\n      if (importDecl.source.value === \"@veltra/app\") {\n        const arg = path.node.arguments[0];\n        if (!t.isFunction(arg) && t.isExpression(arg)) {\n          path.node.arguments[0] = t.arrowFunctionExpression([], arg);\n        }\n      }\n    }\n  }\n}\n\nfunction handleJSXExpressionContainer(\n  path: NodePath<t.JSXExpressionContainer>\n) {\n  const expr = path.node.expression;\n\n  // Handle cond && <JSXElement>\n  if (\n    t.isLogicalExpression(expr) &&\n    expr.operator === \"&&\" &&\n    t.isJSXElement(expr.right)\n  ) {\n    const jsxElement = expr.right;\n    const scopePath = path.findParent((p) => p.isProgram() || p.isFunction());\n    const varName = path.scope.generateUidIdentifier(\"memoized\");\n\n    const memoizedVar = t.variableDeclaration(\"const\", [\n      t.variableDeclarator(\n        varName,\n        t.callExpression(t.identifier(\"memo\"), [\n          t.arrowFunctionExpression([], jsxElement),\n        ])\n      ),\n    ]);\n\n    if (scopePath) {\n      if (scopePath.isProgram()) {\n        scopePath.unshiftContainer(\"body\", memoizedVar);\n      } else if (\n        scopePath.isFunctionDeclaration() ||\n        scopePath.isFunctionExpression() ||\n        scopePath.isArrowFunctionExpression()\n      ) {\n        const bodyPath = scopePath.get(\"body\");\n        if (Array.isArray(bodyPath)) {\n          const firstBody = bodyPath[0];\n          if (firstBody && firstBody.isBlockStatement()) {\n            firstBody.unshiftContainer(\"body\", memoizedVar);\n          }\n        } else if (bodyPath.isBlockStatement()) {\n          bodyPath.unshiftContainer(\"body\", memoizedVar);\n        }\n      }\n    }\n\n    path.node.expression = t.arrowFunctionExpression(\n      [],\n      t.logicalExpression(\"&&\", expr.left, t.callExpression(varName, []))\n    );\n\n    return;\n  }\n\n  // Wrap other non-JSX expressions\n  if (\n    !t.isJSXEmptyExpression(expr) &&\n    !t.isJSXElement(expr) &&\n    !t.isJSXFragment(expr)\n  ) {\n    path.node.expression = wrapExpressionInArrow(expr);\n  }\n}\n\nfunction handleJSXAttribute(path: NodePath<t.JSXAttribute>) {\n  const attr = path.node;\n\n  // Handle ref\n  if (\n    t.isJSXIdentifier(attr.name, { name: \"ref\" }) &&\n    t.isJSXExpressionContainer(attr.value)\n  ) {\n    const expression = attr.value.expression;\n    if (t.isIdentifier(expression)) {\n      const param = t.identifier(\"el\");\n      const body = t.assignmentExpression(\"=\", expression, param);\n      attr.value.expression = t.arrowFunctionExpression([param], body);\n    }\n  }\n\n  // Wrap JSXElement or JSXFragment in attributes\n  if (\n    t.isJSXExpressionContainer(attr.value) &&\n    (t.isJSXElement(attr.value.expression) ||\n      t.isJSXFragment(attr.value.expression))\n  ) {\n    attr.value.expression = t.arrowFunctionExpression(\n      [],\n      attr.value.expression\n    );\n  }\n}\n\nfunction handleLoopJSXExpression(path: NodePath<t.JSXExpressionContainer>) {\n  const expr = path.node.expression;\n\n  if (\n    t.isCallExpression(expr) && // loop().each()\n    t.isMemberExpression(expr.callee) &&\n    t.isCallExpression(expr.callee.object) &&\n    t.isIdentifier(expr.callee.object.callee) &&\n    veltraImports.has(expr.callee.object.callee.name) && // imported loop alias\n    t.isIdentifier(expr.callee.property, { name: \"each\" })\n  ) {\n    const scopePath = path.findParent((p) => p.isProgram() || p.isFunction());\n    const varName = path.scope.generateUidIdentifier(\"looped\");\n\n    // Wrap in memo(() => ...)\n    const memoCall = t.callExpression(t.identifier(\"memo\"), [\n      t.arrowFunctionExpression([], expr),\n    ]);\n\n    const loopedVar = t.variableDeclaration(\"const\", [\n      t.variableDeclarator(varName, memoCall),\n    ]);\n\n    // Hoist to the top of the scope\n    if (scopePath) {\n      if (scopePath.isProgram()) {\n        scopePath.unshiftContainer(\"body\", loopedVar);\n      } else if (\n        scopePath.isFunctionDeclaration() ||\n        scopePath.isFunctionExpression() ||\n        scopePath.isArrowFunctionExpression()\n      ) {\n        const bodyPath = scopePath.get(\"body\");\n\n        if (Array.isArray(bodyPath)) {\n          bodyPath.forEach((p) => {\n            if (p.isBlockStatement()) {\n              p.unshiftContainer(\"body\", loopedVar);\n            }\n          });\n        } else if (bodyPath.isBlockStatement()) {\n          bodyPath.unshiftContainer(\"body\", loopedVar);\n        }\n      }\n    }\n\n    // Replace JSX expression with looped()\n    path.node.expression = t.callExpression(varName, []);\n  }\n}\n\nexport const babelPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    name: \"veltra-plugin-babel\",\n    visitor: {\n      Program(path, state) {\n        handleImports(path, state);\n      },\n      JSXExpressionContainer(path) {\n        handleLoopJSXExpression(path);\n        handleJSXExpressionContainer(path);\n      },\n      JSXAttribute(path) {\n        handleJSXAttribute(path);\n      },\n      CallExpression(path) {\n        handleCallExpression(path);\n      },\n    },\n  };\n});\n","import { TransformOptions, ConfigAPI } from \"@babel/core\";\nimport { babelPlugin } from \"./babel-plugin\";\n// @ts-ignore\nimport babelReactPlugin from \"@babel/preset-react\";\n\n// Main preset function\nexport default function babelPresetVeltra(api: ConfigAPI): TransformOptions {\n  api.assertVersion(7);\n\n  return {\n    presets: [\n      [\n        babelReactPlugin,\n        {\n          runtime: \"automatic\",\n          importSource: \"@veltra/app\",\n        },\n      ],\n    ],\n    plugins: [babelPlugin],\n  };\n}\n"],"names":["wrapExpressionInArrow","expr","arrow","t","veltraImports","handleImports","path","state","hasMemoImport","hasCleanLogImport","importPath","specifier","importedName","localName","specifiers","hasMemo","s","hasCleanLog","handleCallExpression","callee","arg","binding","handleJSXExpressionContainer","jsxElement","scopePath","p","varName","memoizedVar","bodyPath","firstBody","handleJSXAttribute","attr","expression","param","body","handleLoopJSXExpression","memoCall","loopedVar","babelPlugin","declare","api","babelPresetVeltra","babelReactPlugin"],"mappings":"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"}