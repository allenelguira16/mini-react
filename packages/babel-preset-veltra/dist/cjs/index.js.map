{"version":3,"file":"index.js","sources":["../../src/plugins/log-jsx-plugin.ts","../../src/plugins/loop-auto-wrap-plugin.ts","../../src/plugins/loop-map-plugin.ts","../../src/plugins/suspense-wrap-plugin.ts","../../src/plugins/wrap-jsx-expression-plugin.ts","../../src/index.ts"],"sourcesContent":["import { NodePath } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\nexport const logJsxPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    visitor: {\n      Program(path, state) {\n        const filename = state.filename || \"\";\n\n        // Skip Veltra internal or installed files\n        if (\n          filename.includes(\"/veltra-router/\") ||\n          filename.includes(\"\\\\veltra-router\\\\\") ||\n          filename.includes(\"/veltra-app/\") ||\n          filename.includes(\"\\\\veltra-app\\\\\") ||\n          filename.includes(\"/node_modules/@veltra/app/\") ||\n          filename.includes(\"\\\\node_modules\\\\@veltra\\\\app\\\\\")\n        ) {\n          return;\n        }\n\n        let hasLogJsx = false;\n\n        // Check existing imports\n        path.get(\"body\").forEach((child) => {\n          if (child.isImportDeclaration() && child.node.source.value === \"@veltra/app\") {\n            child.node.specifiers.forEach((spec) => {\n              if (t.isImportSpecifier(spec)) {\n                const imported = spec.imported;\n                if (t.isIdentifier(imported) && imported.name === \"logJsx\") {\n                  hasLogJsx = true;\n                }\n              }\n            });\n          }\n        });\n\n        // Insert import if missing\n        if (!hasLogJsx) {\n          const importDecl = t.importDeclaration(\n            [t.importSpecifier(t.identifier(\"logJsx\"), t.identifier(\"logJsx\"))],\n            t.stringLiteral(\"@veltra/app\"),\n          );\n          path.unshiftContainer(\"body\", importDecl);\n        }\n      },\n\n      CallExpression(path: NodePath<t.CallExpression>) {\n        const callee = path.get(\"callee\");\n\n        // Detect console.* calls\n        if (\n          t.isMemberExpression(callee.node) &&\n          t.isIdentifier(callee.node.object, { name: \"console\" }) &&\n          t.isIdentifier(callee.node.property)\n        ) {\n          // For each argument, check if JSX\n          const newArgs = path.node.arguments.map((arg) => {\n            if (t.isJSXElement(arg) || t.isJSXFragment(arg)) {\n              return t.callExpression(t.identifier(\"logJsx\"), [arg]);\n            }\n            return arg;\n          });\n\n          // Replace arguments if any JSX was wrapped\n          if (newArgs.some((arg, i) => arg !== path.node.arguments[i])) {\n            path.node.arguments = newArgs;\n          }\n        }\n      },\n    },\n  };\n});\n","import { PluginObj } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\ntype Metadata = {\n  importedLoops: Set<string>;\n  localLoops: Set<string>;\n};\n\nexport const loopAutoWrapPlugin = declare((api) => {\n  api.assertVersion(7);\n  return {\n    pre() {\n      // Initialize metadata storage per file\n      const meta = this.file.metadata as Partial<Metadata>;\n      meta.importedLoops = new Set();\n      meta.localLoops = new Set();\n    },\n    visitor: {\n      Program(path, state) {\n        const meta = state.file.metadata as Metadata;\n        const importedLoops = meta.importedLoops;\n        const localLoops = meta.localLoops;\n\n        path.get(\"body\").forEach((child) => {\n          if (child.isImportDeclaration() && child.node.source.value === \"@veltra/app\") {\n            child.node.specifiers.forEach((spec) => {\n              if (t.isImportSpecifier(spec) && t.isIdentifier(spec.imported, { name: \"loop\" })) {\n                importedLoops.add(spec.local.name);\n              }\n            });\n          }\n\n          if (child.isFunctionDeclaration() && t.isIdentifier(child.node.id)) {\n            localLoops.add(child.node.id.name);\n          }\n\n          if (child.isVariableDeclaration()) {\n            child.node.declarations.forEach((decl) => {\n              if (t.isIdentifier(decl.id)) {\n                localLoops.add(decl.id.name);\n              }\n            });\n          }\n        });\n      },\n\n      CallExpression(path, state) {\n        const meta = state.file.metadata as Metadata;\n        const importedLoops = meta.importedLoops;\n        const localLoops = meta.localLoops;\n\n        const callee = path.get(\"callee\");\n        if (!callee.isIdentifier()) return;\n\n        const name = callee.node.name;\n\n        if (importedLoops.has(name) && !localLoops.has(name)) {\n          if (path.node.arguments.length === 1) {\n            const arg = path.node.arguments[0];\n            if (!t.isArrowFunctionExpression(arg) && t.isExpression(arg)) {\n              path.node.arguments[0] = t.arrowFunctionExpression([], arg);\n            }\n          }\n        }\n      },\n    },\n  } satisfies PluginObj;\n});\n","import { NodePath } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\nexport const loopMapPlugin = declare((api) => {\n  api.assertVersion(7);\n  return {\n    visitor: {\n      Program(path, state) {\n        const filename = state.filename || \"\";\n\n        // Skip transforming files from Veltra's own source or installed package\n        if (\n          filename.includes(\"/veltra-router/\") ||\n          filename.includes(\"\\\\veltra-router\\\\\") || // local dev\n          filename.includes(\"/veltra-app/\") ||\n          filename.includes(\"\\\\veltra-app\\\\\") || // local dev\n          filename.includes(\"/node_modules/@veltra/app/\") ||\n          filename.includes(\"\\\\node_modules\\\\@veltra\\\\app\\\\\") // package\n        ) {\n          return;\n        }\n\n        let hasLoop = false;\n\n        path.get(\"body\").forEach((child) => {\n          if (child.isImportDeclaration() && child.node.source.value === \"@veltra/app\") {\n            child.node.specifiers.forEach((spec) => {\n              if (t.isImportSpecifier(spec)) {\n                const imported = spec.imported;\n                if (t.isIdentifier(imported)) {\n                  if (imported.name === \"loop\") hasLoop = true;\n                }\n              }\n            });\n          }\n        });\n\n        const newImports: t.ImportSpecifier[] = [];\n        if (!hasLoop)\n          newImports.push(t.importSpecifier(t.identifier(\"loop\"), t.identifier(\"loop\")));\n\n        if (newImports.length) {\n          const importDecl = t.importDeclaration(newImports, t.stringLiteral(\"@veltra/app\"));\n          path.unshiftContainer(\"body\", importDecl);\n        }\n      },\n\n      JSXExpressionContainer(path) {\n        const expr = path.get(\"expression\");\n\n        function transformMap(\n          exprPath: NodePath<t.Expression | t.JSXEmptyExpression>,\n        ): t.CallExpression | null {\n          const node = exprPath.node;\n          if (\n            t.isCallExpression(node) &&\n            t.isMemberExpression(node.callee) &&\n            t.isIdentifier(node.callee.property) &&\n            node.callee.property.name === \"map\"\n          ) {\n            const mapFn = node.arguments[0];\n            const arrExpr = node.callee.object;\n\n            if (t.isArrowFunctionExpression(mapFn) && mapFn.params.length >= 2) {\n              const indexParam = mapFn.params[1];\n              if (t.isIdentifier(indexParam)) {\n                t.traverseFast(mapFn.body, (n) => {\n                  if (t.isIdentifier(n) && n.name === indexParam.name) {\n                    const memberExpr = t.memberExpression(\n                      t.identifier(indexParam.name),\n                      t.identifier(\"value\"),\n                    );\n                    Object.assign(n, memberExpr);\n                  }\n                });\n              }\n            }\n\n            return t.callExpression(\n              t.memberExpression(\n                t.callExpression(t.identifier(\"loop\"), [t.arrowFunctionExpression([], arrExpr)]),\n                t.identifier(\"each\"),\n              ),\n              [mapFn as t.Expression],\n            );\n          }\n          return null;\n        }\n\n        function handleExpression(exprPath: NodePath<t.Expression | t.JSXEmptyExpression>) {\n          const node = exprPath.node;\n\n          if (t.isLogicalExpression(node)) {\n            const right = exprPath.get(\"right\") as NodePath<t.Expression | t.JSXEmptyExpression>;\n            const transformedRight = transformMap(right);\n            if (transformedRight) {\n              right.replaceWith(transformedRight);\n            }\n          } else if (t.isConditionalExpression(node)) {\n            const consequent = exprPath.get(\"consequent\") as NodePath<\n              t.Expression | t.JSXEmptyExpression\n            >;\n            const alternate = exprPath.get(\"alternate\") as NodePath<\n              t.Expression | t.JSXEmptyExpression\n            >;\n\n            const transformedCons = transformMap(consequent);\n            const transformedAlt = transformMap(alternate);\n\n            if (transformedCons) {\n              consequent.replaceWith(transformedCons);\n            }\n            if (transformedAlt) {\n              alternate.replaceWith(transformedAlt);\n            }\n          } else {\n            const transformed = transformMap(exprPath);\n            if (transformed) {\n              exprPath.replaceWith(transformed);\n            }\n          }\n        }\n\n        handleExpression(expr);\n      },\n    },\n  };\n});\n","import { NodePath } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\nexport const suspenseWrapPlugin = declare((api) => {\n  api.assertVersion(7);\n\n  return {\n    visitor: {\n      Program(path) {\n        const suspenseNames = new Set<string>([\"Suspense\"]);\n\n        // Detect imported Suspense aliases\n        path.traverse({\n          ImportDeclaration(importPath) {\n            if (importPath.node.source.value === \"@veltra/app\") {\n              importPath.node.specifiers.forEach((spec) => {\n                if (\n                  t.isImportSpecifier(spec) &&\n                  t.isIdentifier(spec.imported) &&\n                  spec.imported.name === \"Suspense\"\n                ) {\n                  suspenseNames.add(spec.local.name);\n                }\n              });\n            }\n          },\n        });\n\n        path.traverse({\n          JSXElement(jsxPath: NodePath<t.JSXElement>) {\n            const openingElement = jsxPath.node.openingElement;\n\n            if (\n              t.isJSXIdentifier(openingElement.name) &&\n              suspenseNames.has(openingElement.name.name)\n            ) {\n              const children = jsxPath.node.children;\n\n              if (children.length === 0) return;\n\n              // If the first child is already an expression container, skip\n              if (t.isJSXExpressionContainer(children[0])) return;\n\n              // Wrap original children in a Fragment inside an ExpressionContainer\n              const wrappedExpression = t.jSXExpressionContainer(\n                t.jSXFragment(t.jSXOpeningFragment(), t.jSXClosingFragment(), children),\n              );\n\n              // Replace all children with single wrapped fragment\n              jsxPath.node.children = [wrappedExpression];\n            }\n          },\n        });\n      },\n    },\n  };\n});\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport * as t from \"@babel/types\";\n\n// Second plugin: Wrap every JSX expression in arrow function\nexport const wrapJSXExpressionsPlugin = declare((api) => {\n  api.assertVersion(7);\n  return {\n    visitor: {\n      JSXExpressionContainer(path) {\n        const expr = path.get(\"expression\");\n\n        // Skip wrapping if it's an empty expression (like in fragments or empty slots)\n        if (t.isJSXEmptyExpression(expr.node)) return;\n\n        path.node.expression = t.arrowFunctionExpression([], expr.node);\n      },\n    },\n  };\n});\n","import { ConfigAPI, TransformOptions } from \"@babel/core\";\n// @ts-expect-error - babel-preset-react is not typed\nimport babelReactPlugin from \"@babel/preset-react\";\n\nimport {\n  logJsxPlugin,\n  loopAutoWrapPlugin,\n  suspenseWrapPlugin,\n  wrapJSXExpressionsPlugin,\n} from \"./plugins\";\n\n// Main preset function\nexport default function babelPresetVeltra(api: ConfigAPI): TransformOptions {\n  api.assertVersion(7);\n\n  return {\n    presets: [\n      [\n        babelReactPlugin,\n        {\n          runtime: \"automatic\",\n          importSource: \"@veltra/app\",\n        },\n      ],\n    ],\n    plugins: [\n      logJsxPlugin,\n      // loopMapPlugin,\n      loopAutoWrapPlugin,\n      suspenseWrapPlugin,\n      wrapJSXExpressionsPlugin,\n    ],\n  };\n}\n"],"names":["logJsxPlugin","declare","api","path","state","filename","hasLogJsx","child","spec","t","imported","importDecl","callee","newArgs","arg","i","loopAutoWrapPlugin","meta","importedLoops","localLoops","decl","name","hasLoop","newImports","expr","transformMap","exprPath","node","mapFn","arrExpr","indexParam","n","memberExpr","handleExpression","right","transformedRight","consequent","alternate","transformedCons","transformedAlt","transformed","suspenseWrapPlugin","suspenseNames","importPath","jsxPath","openingElement","children","wrappedExpression","wrapJSXExpressionsPlugin","babelPresetVeltra","babelReactPlugin"],"mappings":"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"}