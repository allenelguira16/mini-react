"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var m=require("@babel/helper-plugin-utils"),d=require("@babel/types"),x=require("@babel/preset-react");function g(r){var i=Object.create(null);return r&&Object.keys(r).forEach(function(n){if(n!=="default"){var o=Object.getOwnPropertyDescriptor(r,n);Object.defineProperty(i,n,o.get?o:{enumerable:!0,get:function(){return r[n]}})}}),i.default=r,Object.freeze(i)}var e=g(d);function E(r){const i=e.arrowFunctionExpression([],r);return i.loc=r.loc,i}const f=new Set;function b(r,i){if(i.filename&&i.filename.includes("veltra-app"))return;let n=!1,o=!1;r.traverse({ImportDeclaration(l){if(l.node.source.value==="@veltra/app"){l.node.specifiers.forEach(a=>{if(e.isImportSpecifier(a)){let p="";e.isIdentifier(a.imported)?p=a.imported.name:e.isStringLiteral(a.imported)&&(p=a.imported.value);const u=a.local.name;p==="loop"&&f.add(u)}});const s=l.node.specifiers,t=s.some(a=>e.isImportSpecifier(a)&&e.isIdentifier(a.imported,{name:"memo"})),c=s.some(a=>e.isImportSpecifier(a)&&e.isIdentifier(a.imported,{name:"cleanLog"}));t||s.push(e.importSpecifier(e.identifier("memo"),e.identifier("memo"))),c||s.push(e.importSpecifier(e.identifier("cleanLog"),e.identifier("cleanLog"))),n=n||t,o=o||c}}}),n||r.node.body.unshift(e.importDeclaration([e.importSpecifier(e.identifier("memo"),e.identifier("memo"))],e.stringLiteral("@veltra/app"))),o||r.node.body.unshift(e.importDeclaration([e.importSpecifier(e.identifier("cleanLog"),e.identifier("cleanLog"))],e.stringLiteral("@veltra/app")))}function v(r){const i=r.node.callee;if(e.isMemberExpression(i)&&e.isIdentifier(i.object,{name:"console"})){r.node.arguments=r.node.arguments.map(n=>e.isJSXElement(n)||e.isJSXFragment(n)?e.callExpression(e.identifier("cleanLog"),[n]):n);return}if(e.isCallExpression(r.node)&&e.isIdentifier(r.node.callee)&&f.has(r.node.callee.name)){const n=r.scope.getBinding(r.node.callee.name);if(n&&n.path.isImportSpecifier()&&n.path.parentPath&&n.path.parentPath.isImportDeclaration()&&n.path.parentPath.node.source.value==="@veltra/app"){const o=r.node.arguments[0];!e.isFunction(o)&&e.isExpression(o)&&(r.node.arguments[0]=e.arrowFunctionExpression([],o))}}}function S(r){const i=r.node.expression;if(e.isLogicalExpression(i)&&i.operator==="&&"&&e.isJSXElement(i.right)){const n=i.right,o=r.findParent(t=>t.isProgram()||t.isFunction()),l=r.scope.generateUidIdentifier("memoized"),s=e.variableDeclaration("const",[e.variableDeclarator(l,e.callExpression(e.identifier("memo"),[e.arrowFunctionExpression([],n)]))]);if(o){if(o.isProgram())o.unshiftContainer("body",s);else if(o.isFunctionDeclaration()||o.isFunctionExpression()||o.isArrowFunctionExpression()){const t=o.get("body");if(Array.isArray(t)){const c=t[0];c&&c.isBlockStatement()&&c.unshiftContainer("body",s)}else t.isBlockStatement()&&t.unshiftContainer("body",s)}}r.node.expression=e.arrowFunctionExpression([],e.logicalExpression("&&",i.left,e.callExpression(l,[])));return}!e.isJSXEmptyExpression(i)&&!e.isJSXElement(i)&&!e.isJSXFragment(i)&&(r.node.expression=E(i))}function h(r){const i=r.node;if(e.isJSXIdentifier(i.name,{name:"ref"})&&e.isJSXExpressionContainer(i.value)){const n=i.value.expression;if(e.isIdentifier(n)){const o=e.identifier("el"),l=e.assignmentExpression("=",n,o);i.value.expression=e.arrowFunctionExpression([o],l)}}e.isJSXExpressionContainer(i.value)&&(e.isJSXElement(i.value.expression)||e.isJSXFragment(i.value.expression))&&(i.value.expression=e.arrowFunctionExpression([],i.value.expression))}function y(r){const i=r.node.expression;if(e.isCallExpression(i)&&e.isMemberExpression(i.callee)&&e.isCallExpression(i.callee.object)&&e.isIdentifier(i.callee.object.callee)&&f.has(i.callee.object.callee.name)&&e.isIdentifier(i.callee.property,{name:"each"})){const n=r.findParent(t=>t.isProgram()||t.isFunction()),o=r.scope.generateUidIdentifier("looped"),l=e.callExpression(e.identifier("memo"),[e.arrowFunctionExpression([],i)]),s=e.variableDeclaration("const",[e.variableDeclarator(o,l)]);if(n){if(n.isProgram())n.unshiftContainer("body",s);else if(n.isFunctionDeclaration()||n.isFunctionExpression()||n.isArrowFunctionExpression()){const t=n.get("body");Array.isArray(t)?t.forEach(c=>{c.isBlockStatement()&&c.unshiftContainer("body",s)}):t.isBlockStatement()&&t.unshiftContainer("body",s)}}r.node.expression=e.callExpression(o,[])}}const F=m.declare(r=>(r.assertVersion(7),{name:"veltra-plugin-babel",visitor:{Program(i,n){b(i,n)},JSXExpressionContainer(i){y(i),S(i)},JSXAttribute(i){h(i)},CallExpression(i){v(i)}}}));function I(r){return r.assertVersion(7),{presets:[[x,{runtime:"automatic",importSource:"@veltra/app"}]],plugins:[F]}}exports.default=I;
//# sourceMappingURL=index.js.map
