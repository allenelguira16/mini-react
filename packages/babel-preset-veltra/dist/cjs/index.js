"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var u=require("@babel/preset-react"),m=require("@babel/helper-plugin-utils"),g=require("@babel/types");function E(l){var i=Object.create(null);return l&&Object.keys(l).forEach(function(a){if(a!=="default"){var r=Object.getOwnPropertyDescriptor(l,a);Object.defineProperty(i,a,r.get?r:{enumerable:!0,get:function(){return l[a]}})}}),i.default=l,Object.freeze(i)}var e=E(g);const x=m.declare(l=>(l.assertVersion(7),{visitor:{Program(i,a){const r=a.filename||"";if(r.includes("/veltra-router/")||r.includes("\\veltra-router\\")||r.includes("/veltra-app/")||r.includes("\\veltra-app\\")||r.includes("/node_modules/@veltra/app/")||r.includes("\\node_modules\\@veltra\\app\\"))return;let o=!1;if(i.get("body").forEach(t=>{t.isImportDeclaration()&&t.node.source.value==="@veltra/app"&&t.node.specifiers.forEach(n=>{if(e.isImportSpecifier(n)){const s=n.imported;e.isIdentifier(s)&&s.name==="logJsx"&&(o=!0)}})}),!o){const t=e.importDeclaration([e.importSpecifier(e.identifier("logJsx"),e.identifier("logJsx"))],e.stringLiteral("@veltra/app"));i.unshiftContainer("body",t)}},CallExpression(i){const a=i.get("callee");if(e.isMemberExpression(a.node)&&e.isIdentifier(a.node.object,{name:"console"})&&e.isIdentifier(a.node.property)){const r=i.node.arguments.map(o=>e.isJSXElement(o)||e.isJSXFragment(o)?e.callExpression(e.identifier("logJsx"),[o]):o);r.some((o,t)=>o!==i.node.arguments[t])&&(i.node.arguments=r)}}}})),v=m.declare(l=>(l.assertVersion(7),{pre(){const i=this.file.metadata;i.importedLoops=new Set,i.localLoops=new Set},visitor:{Program(i,a){const r=a.file.metadata,o=r.importedLoops,t=r.localLoops;i.get("body").forEach(n=>{n.isImportDeclaration()&&n.node.source.value==="@veltra/app"&&n.node.specifiers.forEach(s=>{e.isImportSpecifier(s)&&e.isIdentifier(s.imported,{name:"loop"})&&o.add(s.local.name)}),n.isFunctionDeclaration()&&e.isIdentifier(n.node.id)&&t.add(n.node.id.name),n.isVariableDeclaration()&&n.node.declarations.forEach(s=>{e.isIdentifier(s.id)&&t.add(s.id.name)})})},CallExpression(i,a){const r=a.file.metadata,o=r.importedLoops,t=r.localLoops,n=i.get("callee");if(!n.isIdentifier())return;const s=n.node.name;if(o.has(s)&&!t.has(s)&&i.node.arguments.length===1){const p=i.node.arguments[0];!e.isArrowFunctionExpression(p)&&e.isExpression(p)&&(i.node.arguments[0]=e.arrowFunctionExpression([],p))}}}}));m.declare(l=>(l.assertVersion(7),{visitor:{Program(i,a){const r=a.filename||"";if(r.includes("/veltra-router/")||r.includes("\\veltra-router\\")||r.includes("/veltra-app/")||r.includes("\\veltra-app\\")||r.includes("/node_modules/@veltra/app/")||r.includes("\\node_modules\\@veltra\\app\\"))return;let o=!1;i.get("body").forEach(n=>{n.isImportDeclaration()&&n.node.source.value==="@veltra/app"&&n.node.specifiers.forEach(s=>{if(e.isImportSpecifier(s)){const p=s.imported;e.isIdentifier(p)&&p.name==="loop"&&(o=!0)}})});const t=[];if(o||t.push(e.importSpecifier(e.identifier("loop"),e.identifier("loop"))),t.length){const n=e.importDeclaration(t,e.stringLiteral("@veltra/app"));i.unshiftContainer("body",n)}},JSXExpressionContainer(i){const a=i.get("expression");function r(t){const n=t.node;if(e.isCallExpression(n)&&e.isMemberExpression(n.callee)&&e.isIdentifier(n.callee.property)&&n.callee.property.name==="map"){const s=n.arguments[0],p=n.callee.object;if(e.isArrowFunctionExpression(s)&&s.params.length>=2){const c=s.params[1];e.isIdentifier(c)&&e.traverseFast(s.body,d=>{if(e.isIdentifier(d)&&d.name===c.name){const f=e.memberExpression(e.identifier(c.name),e.identifier("value"));Object.assign(d,f)}})}return e.callExpression(e.memberExpression(e.callExpression(e.identifier("loop"),[e.arrowFunctionExpression([],p)]),e.identifier("each")),[s])}return null}function o(t){const n=t.node;if(e.isLogicalExpression(n)){const s=t.get("right"),p=r(s);p&&s.replaceWith(p)}else if(e.isConditionalExpression(n)){const s=t.get("consequent"),p=t.get("alternate"),c=r(s),d=r(p);c&&s.replaceWith(c),d&&p.replaceWith(d)}else{const s=r(t);s&&t.replaceWith(s)}}o(a)}}}));const h=m.declare(l=>(l.assertVersion(7),{name:"wrap-loop-in-memo",pre(){const i=this.file.metadata;i.importedLoops=new Set,i.hasMemoImport=!1},visitor:{Program(i,a){const r=a.file.metadata;i.get("body").forEach(o=>{if(o.isImportDeclaration()&&o.node.source.value==="@veltra/app")for(const t of o.node.specifiers)e.isImportSpecifier(t)&&e.isIdentifier(t.imported)&&(t.imported.name==="loop"&&r.importedLoops.add(t.local.name),t.imported.name==="memo"&&(r.hasMemoImport=!0))}),r.hasMemoImport||i.unshiftContainer("body",e.importDeclaration([e.importSpecifier(e.identifier("memo"),e.identifier("memo"))],e.stringLiteral("@veltra/app")))},JSXExpressionContainer(i,a){const r=a.file.metadata.importedLoops;let o=!1;i.traverse({CallExpression(t){if(o)return;const n=t.node;if(e.isMemberExpression(n.callee)&&e.isCallExpression(n.callee.object)&&e.isIdentifier(n.callee.object.callee)&&r.has(n.callee.object.callee.name)&&e.isIdentifier(n.callee.property,{name:"each"})){const s=n.callee.object,p=s.arguments[0];p&&!e.isArrowFunctionExpression(p)&&e.isExpression(p)&&(s.arguments[0]=e.arrowFunctionExpression([],p));const c=i.scope.generateUidIdentifier("loopMemo"),d=e.variableDeclaration("const",[e.variableDeclarator(c,e.callExpression(e.identifier("memo"),[e.arrowFunctionExpression([],n)]))]);i.findParent(f=>f.isBlockStatement()||f.isProgram()).unshiftContainer("body",d),t.replaceWith(e.callExpression(c,[])),o=!0}}})}}})),b=m.declare(l=>(l.assertVersion(7),{visitor:{Program(i){const a=new Set(["Suspense"]);i.traverse({ImportDeclaration(r){r.node.source.value==="@veltra/app"&&r.node.specifiers.forEach(o=>{e.isImportSpecifier(o)&&e.isIdentifier(o.imported)&&o.imported.name==="Suspense"&&a.add(o.local.name)})}}),i.traverse({JSXElement(r){const o=r.node.openingElement;if(e.isJSXIdentifier(o.name)&&a.has(o.name.name)){const t=r.node.children;if(t.length===0||e.isJSXExpressionContainer(t[0]))return;const n=e.jSXExpressionContainer(e.jSXFragment(e.jSXOpeningFragment(),e.jSXClosingFragment(),t));r.node.children=[n]}}})}}})),I=m.declare(l=>(l.assertVersion(7),{name:"wrap-jsx-expressions-except-loop",pre(){const i=this.file.metadata;i.loopLocalNames=new Set},visitor:{ImportDeclaration(i,a){const r=a.file.metadata;if(i.node.source.value==="@veltra/app")for(const o of i.node.specifiers)e.isImportSpecifier(o)&&e.isIdentifier(o.imported,{name:"loop"})&&r.loopLocalNames.add(o.local.name)},JSXExpressionContainer(i,a){const r=a.file.metadata.loopLocalNames??new Set,o=i.get("expression");e.isJSXEmptyExpression(o.node)||S(o.node,r)||(i.node.expression=e.arrowFunctionExpression([],o.node))}}}));function S(l,i){return!!(e.isCallExpression(l)&&e.isIdentifier(l.callee)&&i.has(l.callee.name)||e.isCallExpression(l)&&e.isMemberExpression(l.callee)&&e.isCallExpression(l.callee.object)&&e.isIdentifier(l.callee.object.callee)&&i.has(l.callee.object.callee.name))}function j(l){return l.assertVersion(7),{presets:[[u,{runtime:"automatic",importSource:"@veltra/app"}]],plugins:[x,b,v,h,I]}}exports.default=j;
//# sourceMappingURL=index.js.map
