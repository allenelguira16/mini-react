"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var x=require("@babel/preset-react"),f=require("@babel/helper-plugin-utils"),E=require("@babel/types");function v(l){var i=Object.create(null);return l&&Object.keys(l).forEach(function(a){if(a!=="default"){var o=Object.getOwnPropertyDescriptor(l,a);Object.defineProperty(i,a,o.get?o:{enumerable:!0,get:function(){return l[a]}})}}),i.default=l,Object.freeze(i)}var e=v(E);const h=f.declare(l=>(l.assertVersion(7),{visitor:{Program(i,a){const o=a.filename||"";if(o.includes("/veltra-router/")||o.includes("\\veltra-router\\")||o.includes("/veltra-app/")||o.includes("\\veltra-app\\")||o.includes("/node_modules/@veltra/app/")||o.includes("\\node_modules\\@veltra\\app\\"))return;let t=!1;if(i.get("body").forEach(n=>{n.isImportDeclaration()&&n.node.source.value==="@veltra/app"&&n.node.specifiers.forEach(r=>{if(e.isImportSpecifier(r)){const s=r.imported;e.isIdentifier(s)&&s.name==="logJsx"&&(t=!0)}})}),!t){const n=e.importDeclaration([e.importSpecifier(e.identifier("logJsx"),e.identifier("logJsx"))],e.stringLiteral("@veltra/app"));i.unshiftContainer("body",n)}},CallExpression(i){const a=i.get("callee");if(e.isMemberExpression(a.node)&&e.isIdentifier(a.node.object,{name:"console"})&&e.isIdentifier(a.node.property)){const o=i.node.arguments.map(t=>e.isJSXElement(t)||e.isJSXFragment(t)?e.callExpression(e.identifier("logJsx"),[t]):t);o.some((t,n)=>t!==i.node.arguments[n])&&(i.node.arguments=o)}}}})),b=f.declare(l=>(l.assertVersion(7),{pre(){const i=this.file.metadata;i.importedLoops=new Set,i.localLoops=new Set},visitor:{Program(i,a){const o=a.file.metadata,t=o.importedLoops,n=o.localLoops;i.get("body").forEach(r=>{r.isImportDeclaration()&&r.node.source.value==="@veltra/app"&&r.node.specifiers.forEach(s=>{e.isImportSpecifier(s)&&e.isIdentifier(s.imported,{name:"loop"})&&t.add(s.local.name)}),r.isFunctionDeclaration()&&e.isIdentifier(r.node.id)&&n.add(r.node.id.name),r.isVariableDeclaration()&&r.node.declarations.forEach(s=>{e.isIdentifier(s.id)&&n.add(s.id.name)})})},CallExpression(i,a){const o=a.file.metadata,t=o.importedLoops,n=o.localLoops,r=i.get("callee");if(!r.isIdentifier())return;const s=r.node.name;if(t.has(s)&&!n.has(s)&&i.node.arguments.length===1){const p=i.node.arguments[0];!e.isArrowFunctionExpression(p)&&e.isExpression(p)&&(i.node.arguments[0]=e.arrowFunctionExpression([],p))}}}}));f.declare(l=>(l.assertVersion(7),{visitor:{Program(i,a){const o=a.filename||"";if(o.includes("/veltra-router/")||o.includes("\\veltra-router\\")||o.includes("/veltra-app/")||o.includes("\\veltra-app\\")||o.includes("/node_modules/@veltra/app/")||o.includes("\\node_modules\\@veltra\\app\\"))return;let t=!1;i.get("body").forEach(r=>{r.isImportDeclaration()&&r.node.source.value==="@veltra/app"&&r.node.specifiers.forEach(s=>{if(e.isImportSpecifier(s)){const p=s.imported;e.isIdentifier(p)&&p.name==="loop"&&(t=!0)}})});const n=[];if(t||n.push(e.importSpecifier(e.identifier("loop"),e.identifier("loop"))),n.length){const r=e.importDeclaration(n,e.stringLiteral("@veltra/app"));i.unshiftContainer("body",r)}},JSXExpressionContainer(i){const a=i.get("expression");function o(n){const r=n.node;if(e.isCallExpression(r)&&e.isMemberExpression(r.callee)&&e.isIdentifier(r.callee.property)&&r.callee.property.name==="map"){const s=r.arguments[0],p=r.callee.object;if(e.isArrowFunctionExpression(s)&&s.params.length>=2){const c=s.params[1];e.isIdentifier(c)&&e.traverseFast(s.body,d=>{if(e.isIdentifier(d)&&d.name===c.name){const m=e.memberExpression(e.identifier(c.name),e.identifier("value"));Object.assign(d,m)}})}return e.callExpression(e.memberExpression(e.callExpression(e.identifier("loop"),[e.arrowFunctionExpression([],p)]),e.identifier("each")),[s])}return null}function t(n){const r=n.node;if(e.isLogicalExpression(r)){const s=n.get("right"),p=o(s);p&&s.replaceWith(p)}else if(e.isConditionalExpression(r)){const s=n.get("consequent"),p=n.get("alternate"),c=o(s),d=o(p);c&&s.replaceWith(c),d&&p.replaceWith(d)}else{const s=o(n);s&&n.replaceWith(s)}}t(a)}}}));const I=f.declare(l=>(l.assertVersion(7),{name:"wrap-loop-in-memo",pre(){const i=this.file.metadata;i.importedLoops=new Set,i.hasMemoImport=!1},visitor:{Program(i,a){const o=a.file.metadata;i.get("body").forEach(t=>{if(t.isImportDeclaration()&&t.node.source.value==="@veltra/app")for(const n of t.node.specifiers)e.isImportSpecifier(n)&&e.isIdentifier(n.imported)&&(n.imported.name==="loop"&&o.importedLoops.add(n.local.name),n.imported.name==="memo"&&(o.hasMemoImport=!0))}),o.hasMemoImport||i.unshiftContainer("body",e.importDeclaration([e.importSpecifier(e.identifier("memo"),e.identifier("memo"))],e.stringLiteral("@veltra/app")))},JSXExpressionContainer(i,a){const o=a.file.metadata.importedLoops;let t=!1;i.traverse({CallExpression(n){if(t)return;const r=n.node;if(e.isMemberExpression(r.callee)&&e.isCallExpression(r.callee.object)&&e.isIdentifier(r.callee.object.callee)&&o.has(r.callee.object.callee.name)&&e.isIdentifier(r.callee.property,{name:"each"})){const s=r.callee.object,p=s.arguments[0];p&&!e.isArrowFunctionExpression(p)&&e.isExpression(p)&&(s.arguments[0]=e.arrowFunctionExpression([],p));const c=i.scope.generateUidIdentifier("loopMemo"),d=e.variableDeclaration("const",[e.variableDeclarator(c,e.callExpression(e.identifier("memo"),[e.arrowFunctionExpression([],r)]))]);i.findParent(m=>m.isBlockStatement()||m.isProgram()).unshiftContainer("body",d),n.replaceWith(e.callExpression(c,[])),t=!0}}})}}}));let S=0;const C=f.declare(l=>(l.assertVersion(7),{name:"suspense-memo-wrapper",visitor:{Program(i){const a=new Set(["Suspense"]);let o=!1;i.traverse({ImportDeclaration(t){if(t.node.source.value==="@veltra/app")for(const n of t.node.specifiers)e.isImportSpecifier(n)&&e.isIdentifier(n.imported)&&(n.imported.name==="Suspense"&&a.add(n.local.name),n.imported.name==="memo"&&(o=!0))}}),o||i.unshiftContainer("body",e.importDeclaration([e.importSpecifier(e.identifier("memo"),e.identifier("memo"))],e.stringLiteral("@veltra/app"))),i.traverse({JSXElement(t){const n=t.node.openingElement;if(!e.isJSXIdentifier(n.name)||!a.has(n.name.name))return;const r=t.node.children.filter(u=>!e.isJSXText(u)||u.value.trim().length>0);if(r.length===0||r.length===1&&e.isJSXExpressionContainer(r[0])&&e.isArrowFunctionExpression(r[0].expression))return;const s=r.length>1?e.jsxFragment(e.jsxOpeningFragment(),e.jsxClosingFragment(),r):r[0];let p;if(e.isJSXExpressionContainer(s)){if(e.isJSXEmptyExpression(s.expression))return;p=s.expression}else p=e.parenthesizedExpression(s);const c=e.arrowFunctionExpression([],p),d=t.scope.generateUidIdentifier(`memoizedComponent${S++}`),m=e.variableDeclaration("const",[e.variableDeclarator(d,e.callExpression(e.identifier("memo"),[c]))]);t.node.children=[e.jsxExpressionContainer(e.arrowFunctionExpression([],e.callExpression(d,[])))];const g=t.findParent(u=>u.isBlockStatement()||u.isProgram());g&&(g.isProgram()||g.isBlockStatement())&&g.unshiftContainer("body",m)}})}}})),w=f.declare(l=>(l.assertVersion(7),{name:"wrap-jsx-expressions-except-loop",pre(){const i=this.file.metadata;i.loopLocalNames=new Set},visitor:{ImportDeclaration(i,a){const o=a.file.metadata;if(i.node.source.value==="@veltra/app")for(const t of i.node.specifiers)e.isImportSpecifier(t)&&e.isIdentifier(t.imported,{name:"loop"})&&o.loopLocalNames.add(t.local.name)},JSXExpressionContainer(i,a){const o=a.file.metadata.loopLocalNames??new Set,t=i.get("expression");e.isJSXEmptyExpression(t.node)||j(t.node,o)||(i.node.expression=e.arrowFunctionExpression([],t.node))}}}));function j(l,i){return!!(e.isCallExpression(l)&&e.isIdentifier(l.callee)&&i.has(l.callee.name)||e.isCallExpression(l)&&e.isMemberExpression(l.callee)&&e.isCallExpression(l.callee.object)&&e.isIdentifier(l.callee.object.callee)&&i.has(l.callee.object.callee.name))}function y(l){return l.assertVersion(7),{presets:[[x,{runtime:"automatic",importSource:"@veltra/app"}]],plugins:[h,C,b,I,w]}}exports.default=y;
//# sourceMappingURL=index.js.map
