"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var m=require("@babel/preset-react"),d=require("@babel/helper-plugin-utils"),g=require("@babel/types");function v(l){var t=Object.create(null);return l&&Object.keys(l).forEach(function(o){if(o!=="default"){var i=Object.getOwnPropertyDescriptor(l,o);Object.defineProperty(t,o,i.get?i:{enumerable:!0,get:function(){return l[o]}})}}),t.default=l,Object.freeze(t)}var e=v(g);const x=d.declare(l=>(l.assertVersion(7),{visitor:{Program(t,o){const i=o.filename||"";if(i.includes("/veltra-app/")||i.includes("\\veltra-app\\")||i.includes("/node_modules/@veltra/app/")||i.includes("\\node_modules\\@veltra\\app\\"))return;let a=!1;t.get("body").forEach(s=>{s.isImportDeclaration()&&s.node.source.value==="@veltra/app"&&s.node.specifiers.forEach(n=>{if(e.isImportSpecifier(n)){const p=n.imported;e.isIdentifier(p)&&p.name==="loop"&&(a=!0)}})});const r=[];if(a||r.push(e.importSpecifier(e.identifier("loop"),e.identifier("loop"))),r.length){const s=e.importDeclaration(r,e.stringLiteral("@veltra/app"));t.unshiftContainer("body",s)}},JSXExpressionContainer(t){const o=t.get("expression");function i(r){const s=r.node;if(e.isCallExpression(s)&&e.isMemberExpression(s.callee)&&e.isIdentifier(s.callee.property)&&s.callee.property.name==="map"){const n=s.arguments[0],p=s.callee.object;if(e.isArrowFunctionExpression(n)&&n.params.length>=2){const c=n.params[1];e.isIdentifier(c)&&e.traverseFast(n.body,u=>{if(e.isIdentifier(u)&&u.name===c.name){const f=e.memberExpression(e.identifier(c.name),e.identifier("value"));Object.assign(u,f)}})}return e.callExpression(e.memberExpression(e.callExpression(e.identifier("loop"),[e.arrowFunctionExpression([],p)]),e.identifier("each")),[n])}return null}function a(r){const s=r.node;if(e.isLogicalExpression(s)){const n=r.get("right"),p=i(n);p&&n.replaceWith(p)}else if(e.isConditionalExpression(s)){const n=r.get("consequent"),p=r.get("alternate"),c=i(n),u=i(p);c&&n.replaceWith(c),u&&p.replaceWith(u)}else{const n=i(r);n&&r.replaceWith(n)}}a(o)}}})),E=d.declare(l=>(l.assertVersion(7),{visitor:{Program(t,o){const i=o.filename||"";if(i.includes("/veltra-app/")||i.includes("\\veltra-app\\")||i.includes("/node_modules/@veltra/app/")||i.includes("\\node_modules\\@veltra\\app\\"))return;let a=!1;if(t.get("body").forEach(r=>{r.isImportDeclaration()&&r.node.source.value==="@veltra/app"&&r.node.specifiers.forEach(s=>{if(e.isImportSpecifier(s)){const n=s.imported;e.isIdentifier(n)&&n.name==="logJsx"&&(a=!0)}})}),!a){const r=e.importDeclaration([e.importSpecifier(e.identifier("logJsx"),e.identifier("logJsx"))],e.stringLiteral("@veltra/app"));t.unshiftContainer("body",r)}},CallExpression(t){const o=t.get("callee");if(e.isMemberExpression(o.node)&&e.isIdentifier(o.node.object,{name:"console"})&&e.isIdentifier(o.node.property)){const i=t.node.arguments.map(a=>e.isJSXElement(a)||e.isJSXFragment(a)?e.callExpression(e.identifier("logJsx"),[a]):a);i.some((a,r)=>a!==t.node.arguments[r])&&(t.node.arguments=i)}}}})),b=d.declare(l=>(l.assertVersion(7),{visitor:{JSXExpressionContainer(t){const o=t.get("expression");e.isJSXEmptyExpression(o.node)||(t.node.expression=e.arrowFunctionExpression([],o.node))}}}));function h(l){return l.assertVersion(7),{presets:[[m,{runtime:"automatic",importSource:"@veltra/app"}]],plugins:[x,E,b]}}exports.default=h;
//# sourceMappingURL=index.js.map
