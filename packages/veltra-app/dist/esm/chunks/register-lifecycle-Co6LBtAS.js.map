{"version":3,"file":"register-lifecycle-Co6LBtAS.js","sources":["../../../src/runtime/life-cycle/on-mount.ts","../../../src/runtime/life-cycle/on-destroy.ts","../../../src/runtime/state/effect.ts","../../../src/runtime/life-cycle/init-lifecycle.ts","../../../src/runtime/life-cycle/component-cleanup.ts","../../../src/const/element-tags.ts","../../../src/const/unit-less-props.ts","../../../src/const/index.ts","../../../src/jsx-runtime.ts","../../../src/runtime/render/component-props.ts","../../../src/runtime/render/mount-component.ts","../../../src/runtime/render/patch.ts","../../../src/runtime/render/render-children.ts","../../../src/runtime/render/apply-props.ts","../../../src/runtime/render/h.ts","../../../src/runtime/render/ssr.ts","../../../src/util/is-node-nil.ts","../../../src/util/get-node.ts","../../../src/util/to-array.ts","../../../src/util/on-node-reattached.ts","../../../src/runtime/life-cycle/register-lifecycle.ts"],"sourcesContent":["export type MountFn = () => void | (() => void);\n\nlet mountContext: MountFn[] | null = null;\n\nexport function setMountContext(stack: (() => void)[]) {\n  mountContext = stack;\n}\n\nexport function detachMountContext() {\n  mountContext = null;\n}\n\nexport function onMount(fn: () => () => void): void;\nexport function onMount(fn: () => void): void;\nexport function onMount(fn: MountFn): void {\n  if (mountContext) {\n    mountContext.push(fn);\n  } else {\n    throw new Error(\"onMount called outside of component\");\n  }\n}\n","export type DestroyFn = () => void;\n\nlet destroyContext: DestroyFn[] | null = null;\n\nexport function setDestroyContext(stack: (() => void)[]) {\n  destroyContext = stack;\n}\n\nexport function detachDestroyContext() {\n  destroyContext = null;\n}\n\nexport function onDestroy(fn: () => void) {\n  if (destroyContext) {\n    destroyContext.push(fn);\n  } else {\n    throw new Error(\"onDestroy called outside of component\");\n  }\n}\n","// Effect function type with dependency tracking\nexport type EffectFn = (() => void) & { deps?: Set<EffectFn>[] };\n\n// Currently active effect (global context for dependency collection)\nexport let activeEffect: EffectFn | null = null;\n\nlet effectContext: EffectFn[] | null = null;\n\nexport function setActiveEffect(newActiveEffect: EffectFn | null) {\n  activeEffect = newActiveEffect;\n}\n\nexport function setEffectContext(newEffectContext: EffectFn[] | null) {\n  effectContext = newEffectContext;\n}\n\nexport function detachEffectContext() {\n  effectContext = null;\n}\n\nexport function effect(fn: () => void): () => void {\n  const wrappedEffect: EffectFn = () => {\n    removeEffect(wrappedEffect);\n\n    const previousEffect = activeEffect; // save previous activeEffect\n    activeEffect = wrappedEffect;\n\n    if (effectContext) {\n      effectContext.push(wrappedEffect); // keep your effectContext intact\n    }\n\n    try {\n      fn();\n    } finally {\n      activeEffect = previousEffect; // restore outer activeEffect\n    }\n  };\n\n  wrappedEffect.deps = [];\n  wrappedEffect();\n\n  return () => removeEffect(wrappedEffect);\n}\n\nexport function removeEffect(effect: EffectFn) {\n  if (effect.deps) {\n    for (const depSet of effect.deps) {\n      depSet.delete(effect); // Remove this effect from all dependency sets\n    }\n    effect.deps.length = 0; // Reset dependency list\n  }\n}\n","import { setEffectContext } from \"../state\";\nimport { setDestroyContext } from \"./on-destroy\";\nimport { setMountContext } from \"./on-mount\";\nimport { LifecycleContext } from \"./register-lifecycle\";\n\nexport function initializeLifecycleContext(context: LifecycleContext) {\n  setMountContext(context.mount);\n  setEffectContext(context.effect);\n  // setReactorContext(context.reactor);\n  setDestroyContext(context.destroy);\n}\n","const cleanupMap = new Map<Node, (() => void)[]>();\n\nexport function registerComponentCleanup(node: Node, cleanups: (() => void)[]) {\n  cleanupMap.set(node, cleanups);\n}\n\nexport function runComponentCleanup($node: Node) {\n  const cleanups = cleanupMap.get($node) || [];\n  for (const cleanup of cleanups) {\n    cleanup();\n  }\n}\n","export const SVG_TAGS = new Set([\n  \"a\",\n  \"animate\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"defs\",\n  \"desc\",\n  \"discard\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"foreignObject\",\n  \"g\",\n  \"hatch\",\n  \"hatchpath\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"mesh\",\n  \"meshgradient\",\n  \"meshpatch\",\n  \"meshrow\",\n  \"metadata\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"script\",\n  \"set\",\n  \"solidcolor\",\n  \"stop\",\n  \"style\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"title\",\n  \"tref\",\n  \"tspan\",\n  \"unknown\",\n  \"use\",\n  \"view\",\n]);\n\nexport const MATH_ML_TAGS = new Set([\n  \"math\",\n  \"maction\",\n  \"maligngroup\",\n  \"malignmark\",\n  \"menclose\",\n  \"merror\",\n  \"mfenced\",\n  \"mfrac\",\n  \"mglyph\",\n  \"mi\",\n  \"mlabeledtr\",\n  \"mmultiscripts\",\n  \"mn\",\n  \"mo\",\n  \"mover\",\n  \"mpadded\",\n  \"mphantom\",\n  \"mroot\",\n  \"mrow\",\n  \"ms\",\n  \"mscarries\",\n  \"mscarry\",\n  \"msgroup\",\n  \"mstack\",\n  \"mstyle\",\n  \"msub\",\n  \"msubsup\",\n  \"msup\",\n  \"mtable\",\n  \"mtd\",\n  \"mtext\",\n  \"mtr\",\n  \"munder\",\n  \"munderover\",\n  \"semantics\",\n  \"annotation\",\n  \"annotation-xml\",\n]);\n","export const UNIT_LESS_PROPS = [\n  \"animationIterationCount\",\n  \"borderImageOutset\",\n  \"borderImageSlice\",\n  \"borderImageWidth\",\n  \"boxFlex\",\n  \"boxFlexGroup\",\n  \"boxOrdinalGroup\",\n  \"columnCount\",\n  \"flex\",\n  \"flexGrow\",\n  \"flexPositive\",\n  \"flexShrink\",\n  \"flexNegative\",\n  \"flexOrder\",\n  \"gridRow\",\n  \"gridColumn\",\n  \"fontWeight\",\n  \"lineClamp\",\n  \"lineHeight\",\n  \"opacity\",\n  \"order\",\n  \"orphans\",\n  \"tabSize\",\n  \"widows\",\n  \"zIndex\",\n  \"zoom\",\n  \"fillOpacity\",\n  \"floodOpacity\",\n  \"stopOpacity\",\n  \"strokeDasharray\",\n  \"strokeDashoffset\",\n  \"strokeMiterlimit\",\n  \"strokeOpacity\",\n  \"strokeWidth\",\n];\n","export * from \"./element-tags\";\nexport * from \"./unit-less-props\";\nexport const IS_SSR = typeof document === \"undefined\";\n","// import { Fragment } from \"./components\";\nimport { IS_SSR } from \"./const\";\nimport { h, hSSR } from \"./runtime\";\nimport { toArray } from \"./util\";\n\nimport \"./jsx.d\";\n\n// Transform jsx to use h\nconst jsx = (type: any, { children = [], ...props }: any) => {\n  if (IS_SSR) {\n    return hSSR(type, props, toArray(children));\n  }\n\n  return h(type, props, toArray(children));\n};\n\nfunction Fragment({ children }: { children: any[] }) {\n  return children;\n}\n\nexport { jsx, jsx as jsxs, Fragment };\n","export function resolveComponentProps(props: Record<string, any>) {\n  for (const key in props) {\n    props[key] = props[key] instanceof Function ? props[key]() : props[key];\n  }\n}\n","import {\n  LifecycleContext,\n  initializeLifecycleContext,\n  registerLifeCycles,\n} from \"../life-cycle\";\nimport { resolveComponentProps } from \"./component-props\";\n\nexport const componentRootNodes = new Set<Node>();\n\nexport function mountComponent(\n  type: Function,\n  props: Record<string, any>,\n  children: JSX.Element[]\n) {\n  resolveComponentProps(props);\n\n  const lifecycleContext: LifecycleContext = {\n    mount: [],\n    effect: [],\n    // reactor: [],\n    destroy: [],\n  };\n\n  initializeLifecycleContext(lifecycleContext);\n\n  let $node = type({ ...props, children });\n  let $target = $node;\n\n  if (Array.isArray($node)) {\n    $target = document.createTextNode(\"\");\n    $node.unshift($target);\n  }\n\n  registerLifeCycles(lifecycleContext, $target);\n\n  componentRootNodes.add($target);\n  return $node;\n}\n","import { isNil } from \"~/util\";\nimport { runComponentCleanup } from \"../life-cycle\";\n\nexport function patch(\n  $parent: Node,\n  $oldNodes: Node[],\n  $newNodes: (Node | undefined)[],\n  isFirstRender: boolean\n) {\n  const maxLength = Math.max($oldNodes.length, $newNodes.length);\n\n  for (let i = 0; i < maxLength; i++) {\n    const $oldNode = $oldNodes[i];\n    const $newNode = $newNodes[i];\n\n    if (isFirstRender) {\n      if (isNil($newNode)) continue;\n\n      $parent.appendChild($newNode);\n      $oldNodes[i] = $newNode;\n\n      continue;\n    }\n\n    // Add new node\n    if (isNil($oldNode) && !isNil($newNode)) {\n      $parent.appendChild($newNode);\n      $oldNodes[i] = $newNode;\n      continue;\n    }\n\n    // Remove old node\n    if (!isNil($oldNode) && isNil($newNode)) {\n      runComponentCleanup($oldNode);\n      $parent.removeChild($oldNodes[i]);\n      $oldNodes.splice(i, 1);\n      i--;\n      continue;\n    }\n\n    // If both empty, continue to next iteration\n    if (isNil($oldNode) && isNil($newNode)) {\n      continue;\n    }\n\n    if ($oldNode && $newNode) {\n      // Replace node with node\n      if (!$oldNode.isSameNode($newNode)) {\n        runComponentCleanup($oldNode);\n        ($oldNode as ChildNode).replaceWith($newNode);\n        $oldNodes[i] = $newNode;\n      }\n      continue;\n    }\n\n    console.log(`[veltra]: warning - unknown dom detected: `, {\n      old: $oldNode,\n      new: $newNode,\n    });\n  }\n\n  return [...$oldNodes];\n}\n","import { onMount } from \"../life-cycle\";\nimport { effect as reactor, untrack } from \"../state\";\nimport { componentRootNodes } from \"./mount-component\";\nimport { patch } from \"./patch\";\nimport { getNode, memo, toArray } from \"~/util\";\n\nexport function renderChildren($parent: Node, children: JSX.Element[]) {\n  for (const $child of children) {\n    if (typeof $child === \"function\") {\n      let $oldNodes: Node[] = [];\n      let isFirstRender = true;\n\n      reactor(() => {\n        const $newNodes = toArray($child()).map(getNode).flat();\n\n        $oldNodes = patch($parent, $oldNodes, $newNodes, isFirstRender);\n\n        isFirstRender = false;\n      });\n    } else {\n      const $node = getNode($child);\n      if (!Array.isArray($node) && $node) {\n        $parent.appendChild($node);\n      }\n    }\n  }\n}\n\nexport function Suspense(props: {\n  fallback: JSX.Element;\n  children: () => JSX.Element;\n}) {\n  const $rootNode = document.createTextNode(\"\");\n  const {\n    fallback: _fallback,\n    children: [_children],\n  } = props as unknown as {\n    fallback: () => JSX.Element;\n    children: [() => () => JSX.Element];\n  };\n  const children = _children();\n  const fallback = memo(() => _fallback());\n\n  reactor(() => {\n    try {\n      // console.log(fallback);\n      console.log(children());\n    } catch (error) {\n      console.log(error);\n    }\n  });\n\n  onMount(() => {\n    console.log(\"mounted\");\n  });\n\n  // console.log(fallback());\n  componentRootNodes.add($rootNode);\n  return $rootNode;\n  // const {\n  //   children: [children],\n  // } = props as unknown as {\n  //   fallback: () => JSX.Element;\n  //   children: [() => JSX.Element];\n  // };\n\n  // try {\n  //   const content = children(); // run child component\n  //   return content;\n  // } catch (promiseOrError) {\n  //   console.log(\"hi\");\n  //   if (promiseOrError instanceof Promise) {\n  //     promiseOrError.then(() => {\n  //       // somehow trigger re-render of Suspense\n  //       // maybe use Veltra reactor to force update?\n  //     });\n  //     return props.fallback;\n  //   } else {\n  //     throw promiseOrError; // real error\n  //   }\n  // }\n}\n","import { effect as reactor } from \"../state\";\nimport { UNIT_LESS_PROPS } from \"~/const\";\n\nexport function applyProps(\n  $element: HTMLElement | Element,\n  props: Record<string, any>\n) {\n  for (const key in props) {\n    if (key.startsWith(\"on\") && typeof props[key] === \"function\") {\n      const type = key.slice(2).toLowerCase();\n      let cleanup: () => void;\n\n      reactor(() => {\n        // Remove the previous listener if there was one\n        if (cleanup) cleanup();\n\n        const fn = props[key]();\n        if (typeof fn === \"function\") {\n          $element.addEventListener(type, fn);\n          // Setup cleanup for next effect run\n          cleanup = () => $element.removeEventListener(type, fn);\n        }\n      });\n    } else {\n      reactor(() => {\n        const value =\n          typeof props[key] === \"function\" ? props[key]() : props[key];\n\n        if (key === \"ref\" && typeof value === \"function\") {\n          value($element);\n        } else if (key === \"style\") {\n          applyStyle($element, value);\n        } else if (key === \"disabled\") {\n          $element.toggleAttribute(key, value);\n        } else {\n          $element.setAttribute(key, value);\n        }\n      });\n    }\n  }\n}\n\nfunction applyStyle(\n  $element: HTMLElement | Element,\n  style: Record<string, any>\n) {\n  for (const [key, value] of Object.entries(style)) {\n    if (typeof value === \"number\" && !isUnitLessCSSProperty(key)) {\n      // @ts-ignore\n      $element.style[key] = `${value}px`;\n    } else {\n      // @ts-ignore\n      $element.style[key] = value;\n    }\n  }\n}\n\nfunction isUnitLessCSSProperty(prop: string): boolean {\n  const unitLessProps = new Set(UNIT_LESS_PROPS);\n\n  return unitLessProps.has(prop);\n}\n","import { renderChildren } from \"./render-children\";\nimport { applyProps } from \"./apply-props\";\nimport { mountComponent } from \"./mount-component\";\nimport { MATH_ML_TAGS, SVG_TAGS } from \"~/const\";\nimport { Fragment } from \"~/jsx-runtime\";\n\nexport function h(\n  type: string | Function,\n  props: Record<string, any>,\n  children: JSX.Element[]\n) {\n  if (type === Fragment) {\n    return children;\n  }\n\n  if (typeof type === \"function\") {\n    return mountComponent(type, props, children);\n  }\n\n  const $element = createElement(type, props.xmlns);\n\n  applyProps($element, props);\n  renderChildren($element, children);\n\n  return $element;\n}\n\nfunction createElement(tag: string, namespace?: string) {\n  if ((SVG_TAGS.has(tag) || MATH_ML_TAGS.has(tag)) && namespace) {\n    return document.createElementNS(namespace, tag);\n  }\n\n  return document.createElement(tag);\n}\n","export function hSSR(\n  type: string | Function,\n  props: Record<string, any>,\n  children: JSX.Element[]\n) {\n  if (typeof type === \"function\") {\n    return type({ ...props, children });\n  }\n\n  return `<${type} ${handlePropsSSR(props)}>${handleChildrenSSR(\n    children\n  )}</${type}>`;\n}\n\nfunction handlePropsSSR(props: Record<string, any>) {\n  const transformedProps: string[] = [];\n\n  for (const key in props) {\n    if (key.startsWith(\"on\") && typeof props[key] === \"function\") {\n      continue;\n    }\n\n    const value = typeof props[key] === \"function\" ? props[key]() : props[key];\n\n    if (key === \"ref\" && typeof value === \"function\") {\n      // value($element);\n    } else if (key === \"style\") {\n      // applyStyle($element, value);\n    } else if (key === \"disabled\") {\n      value && transformedProps.push(\"disabled\");\n    } else {\n      transformedProps.push(`${key}=\\\"${value}\\\"`);\n    }\n  }\n\n  return transformedProps.join(\" \");\n}\n\nfunction handleChildrenSSR(children: JSX.Element[]) {\n  let transformedChildren: string[] = [];\n\n  for (const child of children) {\n    if (typeof child === \"function\") {\n      transformedChildren.push(child());\n    } else if (Array.isArray(child)) {\n      // RECURSIVELY flatten nested arrays\n      child.forEach((nested) =>\n        transformedChildren.push(handleChildrenSSR([nested]))\n      );\n    } else {\n      // console.log(child);\n      transformedChildren.push(child as string);\n      // return child\n      // const childRef = getNode(child) as Node;\n\n      // $parent.appendChild(childRef);\n      // mountSpecialComponent(childRef);\n    }\n  }\n\n  return transformedChildren.join(\"\");\n}\n","export const isNil = (value: unknown): value is null | undefined | false => {\n  return value === undefined || value === null || value === false;\n};\n","import { isNil } from \"./is-node-nil\";\n\nexport function getNode(\n  jsxElement: JSX.Element\n): undefined | Node | (Node | undefined)[] {\n  if (typeof jsxElement === \"string\" || typeof jsxElement === \"number\") {\n    return document.createTextNode(String(jsxElement));\n  }\n\n  if (jsxElement instanceof Node) {\n    return jsxElement;\n  }\n\n  if (isNil(jsxElement)) {\n    return undefined;\n  }\n\n  if (typeof jsxElement === \"function\") {\n    return getNode(jsxElement());\n  }\n\n  if (Array.isArray(jsxElement)) {\n    return jsxElement.map(getNode) as (Node | undefined)[];\n  }\n\n  console.log(\"Unknown JSX Element\", jsxElement);\n}\n","export const toArray = <T>(item: T) => {\n  return (Array.isArray(item) ? item : [item]).flat(Infinity) as T[];\n};\n","export function onNodeReattached(callback: () => void, $node: Node) {\n  // Create a MutationObserver instance\n  const observer = new MutationObserver((mutationsList) => {\n    for (const mutation of mutationsList) {\n      // Check for added nodes\n      for (const node of mutation.addedNodes) {\n        if (node === $node) {\n          observer.disconnect();\n          callback();\n          break;\n        }\n      }\n    }\n  });\n\n  queueMicrotask(() => {\n    if (!$node.parentNode) {\n      return;\n    }\n\n    observer.observe($node.parentNode, { childList: true, subtree: true });\n  });\n}\n","import {\n  // Subscriber,\n  detachEffectContext,\n  // detachReactorContext,\n  removeEffect,\n  // removeReactor,\n  // wrapEffect,\n  // wrapReactor,\n} from \"../state\";\nimport { EffectFn } from \"../state\";\nimport { registerComponentCleanup } from \"./component-cleanup\";\nimport { DestroyFn, detachDestroyContext } from \"./on-destroy\";\nimport { MountFn, detachMountContext } from \"./on-mount\";\nimport { onNodeReattached } from \"~/util\";\n\nexport type LifecycleContext = {\n  mount: MountFn[];\n  effect: EffectFn[];\n  // reactor: Subscriber[];\n  destroy: DestroyFn[];\n};\n\nexport function registerLifeCycles(context: LifecycleContext, $target: Node) {\n  const cleanups: (() => void)[] = [];\n\n  detachMountContext();\n  detachEffectContext();\n  // detachReactorContext();\n  detachDestroyContext();\n\n  registerComponentCleanup($target, cleanups);\n\n  // Pass cleanups once dom is painted\n  queueMicrotask(() => {\n    cleanups.push(\n      ...context.destroy,\n      ...context.mount.map((fn) => fn()).filter((c) => !!c),\n      ...context.effect.map((fn) => () => removeEffect(fn))\n      // ...context.reactor.map((fn) => () => removeReactor(fn))\n    );\n  });\n\n  // Re-run effect and memo when node is reattached\n  onNodeReattached(() => {\n    // context.effect.forEach((effect) => wrapEffect(effect));\n    // context.reactor.forEach((effect) => wrapReactor(effect));\n\n    cleanups.push(...context.mount.map((fn) => fn()).filter((c) => !!c));\n  }, $target);\n}\n"],"names":["mountContext","setMountContext","stack","detachMountContext","onMount","fn","destroyContext","setDestroyContext","detachDestroyContext","onDestroy","activeEffect","effectContext","setActiveEffect","newActiveEffect","setEffectContext","newEffectContext","detachEffectContext","effect","wrappedEffect","removeEffect","previousEffect","depSet","initializeLifecycleContext","context","cleanupMap","registerComponentCleanup","node","cleanups","runComponentCleanup","$node","cleanup","SVG_TAGS","MATH_ML_TAGS","UNIT_LESS_PROPS","IS_SSR","jsx","type","children","props","hSSR","toArray","h","Fragment","resolveComponentProps","key","componentRootNodes","mountComponent","lifecycleContext","$target","registerLifeCycles","patch","$parent","$oldNodes","$newNodes","isFirstRender","maxLength","i","$oldNode","$newNode","isNil","renderChildren","$child","reactor","getNode","Suspense","$rootNode","_fallback","_children","error","applyProps","$element","value","applyStyle","style","isUnitLessCSSProperty","prop","createElement","tag","namespace","handlePropsSSR","handleChildrenSSR","transformedProps","transformedChildren","child","nested","jsxElement","item","onNodeReattached","callback","observer","mutationsList","mutation","c"],"mappings":"AAEA,IAAIA,EAAiC,KAErB,SAAAC,EAAgBC,EAAuB,CACrDF,EAAeE,CACjB,CAEO,SAASC,GAAqB,CACnCH,EAAe,IACjB,CAIO,SAASI,EAAQC,EAAmB,CACzC,GAAIL,EACFA,EAAa,KAAKK,CAAE,MAEpB,OAAM,IAAI,MAAM,qCAAqC,CAEzD,CClBA,IAAIC,EAAqC,KAEzB,SAAAC,EAAkBL,EAAuB,CACvDI,EAAiBJ,CACnB,CAEO,SAASM,GAAuB,CACrCF,EAAiB,IACnB,CAEO,SAASG,EAAUJ,EAAgB,CACxC,GAAIC,EACFA,EAAe,KAAKD,CAAE,MAEtB,OAAM,IAAI,MAAM,uCAAuC,CAE3D,CCdO,IAAIK,EAAgC,KAEvCC,EAAmC,KAEhC,SAASC,EAAgBC,EAAkC,CAChEH,EAAeG,CACjB,UAEgBC,EAAiBC,EAAqC,CACpEJ,EAAgBI,CAClB,CAEgB,SAAAC,GAAsB,CACpCL,EAAgB,IAClB,CAEO,SAASM,EAAOZ,EAA4B,CACjD,MAAMa,EAA0B,IAAM,CACpCC,EAAaD,CAAa,EAE1B,MAAME,EAAiBV,EACvBA,EAAeQ,EAEXP,GACFA,EAAc,KAAKO,CAAa,EAGlC,GAAI,CACFb,EAAAA,CACF,QAAE,CACAK,EAAeU,CACjB,CACF,EAEA,OAAAF,EAAc,KAAO,CAAA,EACrBA,EAEO,EAAA,IAAMC,EAAaD,CAAa,CACzC,CAEO,SAASC,EAAaF,EAAkB,CAC7C,GAAIA,EAAO,KAAM,CACf,UAAWI,KAAUJ,EAAO,KAC1BI,EAAO,OAAOJ,CAAM,EAEtBA,EAAO,KAAK,OAAS,CACvB,CACF,CC9CgB,SAAAK,EAA2BC,EAA2B,CACpEtB,EAAgBsB,EAAQ,KAAK,EAC7BT,EAAiBS,EAAQ,MAAM,EAE/BhB,EAAkBgB,EAAQ,OAAO,CACnC,CCVA,MAAMC,EAAa,IAAI,IAEhB,SAASC,EAAyBC,EAAYC,EAA0B,CAC7EH,EAAW,IAAIE,EAAMC,CAAQ,CAC/B,CAEO,SAASC,EAAoBC,EAAa,CAC/C,MAAMF,EAAWH,EAAW,IAAIK,CAAK,GAAK,CAAA,EAC1C,UAAWC,KAAWH,EACpBG,EAEJ,CAAA,CCXa,MAAAC,EAAW,IAAI,IAAI,CAC9B,IACA,UACA,gBACA,mBACA,SACA,WACA,OACA,OACA,UACA,UACA,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,eACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,eACA,SACA,gBACA,IACA,QACA,YACA,QACA,OACA,iBACA,SACA,OACA,OACA,eACA,YACA,UACA,WACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,SACA,MACA,aACA,OACA,QACA,MACA,SACA,SACA,OACA,WACA,QACA,OACA,QACA,UACA,MACA,MACF,CAAC,EAEYC,EAAe,IAAI,IAAI,CAClC,OACA,UACA,cACA,aACA,WACA,SACA,UACA,QACA,SACA,KACA,aACA,gBACA,KACA,KACA,QACA,UACA,WACA,QACA,OACA,KACA,YACA,UACA,UACA,SACA,SACA,OACA,UACA,OACA,SACA,MACA,QACA,MACA,SACA,aACA,YACA,aACA,gBACF,CAAC,EClHYC,EAAkB,CAC7B,0BACA,oBACA,mBACA,mBACA,UACA,eACA,kBACA,cACA,OACA,WACA,eACA,aACA,eACA,YACA,UACA,aACA,aACA,YACA,aACA,UACA,QACA,UACA,UACA,SACA,SACA,OACA,cACA,eACA,cACA,kBACA,mBACA,mBACA,gBACA,aACF,ECjCaC,EAAS,OAAO,SAAa,ICMpCC,EAAM,CAACC,EAAW,CAAE,SAAAC,EAAW,CAAC,EAAG,GAAGC,CAAM,IAC5CJ,EACKK,EAAKH,EAAME,EAAOE,EAAQH,CAAQ,CAAC,EAGrCI,EAAEL,EAAME,EAAOE,EAAQH,CAAQ,CAAC,EAGzC,SAASK,EAAS,CAAE,SAAAL,CAAS,EAAwB,CACnD,OAAOA,CACT,CClBO,SAASM,EAAsBL,EAA4B,CAChE,UAAWM,KAAON,EAChBA,EAAMM,CAAG,EAAIN,EAAMM,CAAG,YAAa,SAAWN,EAAMM,CAAG,EAAMN,EAAAA,EAAMM,CAAG,CAE1E,OCGaC,EAAqB,IAAI,IA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"}