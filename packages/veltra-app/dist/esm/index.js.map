{"version":3,"file":"index.js","sources":["../../src/life-cycle/on-destroy.ts","../../src/reactivity/track.ts","../../src/reactivity/state.ts","../../src/reactivity/computed.ts","../../src/reactivity/resource.ts","../../src/reactivity/store.ts","../../src/render/create-root.ts","../../src/render/loop/util.ts","../../src/render/loop/loop.ts","../../src/util/log-jsx.ts","../../src/util/memo.ts","../../src/util/unwrap.ts"],"sourcesContent":["import { destroyContext } from \"~/context\";\n\nexport type DestroyFn = () => void;\n\n/**\n * on destroy\n *\n * @param fn - The function to run on destroy.\n */\nexport function onDestroy(fn: () => void) {\n  if (destroyContext) {\n    destroyContext.push(fn);\n  } else {\n    throw new Error(\"onDestroy called outside of component\");\n  }\n}\n","import { activeEffect, EffectFn } from \"./effect\";\n\n/**\n * WeakMap to track which targets/keys map to which effects\n */\nconst targetToPropertyEffectsMap: WeakMap<object, Map<PropertyKey, Set<EffectFn>>> = new WeakMap();\n\n/**\n * Track a property\n *\n * @param target - The target object.\n * @param key - The property key.\n */\nexport function track(target: object, key: PropertyKey) {\n  if (!activeEffect) return; // No effect is currently running\n\n  let propertyEffectsMap = targetToPropertyEffectsMap.get(target);\n  if (!propertyEffectsMap) {\n    propertyEffectsMap = new Map();\n    targetToPropertyEffectsMap.set(target, propertyEffectsMap);\n  }\n\n  let effects = propertyEffectsMap.get(key);\n  if (!effects) {\n    effects = new Set();\n    propertyEffectsMap.set(key, effects);\n  }\n\n  if (!effects.has(activeEffect)) {\n    effects.add(activeEffect);\n    // Record this dependency set for cleanup later\n    if (activeEffect.deps) {\n      activeEffect.deps.push(effects);\n    } else {\n      activeEffect.deps = [effects];\n    }\n  }\n}\n\n/**\n * Trigger a property\n *\n * @param target - The target object.\n * @param key - The property key.\n */\nexport function trigger(target: object, key: PropertyKey) {\n  const propertyEffectsMap = targetToPropertyEffectsMap.get(target);\n  if (!propertyEffectsMap) return;\n\n  const effects = propertyEffectsMap.get(key);\n  if (!effects) return;\n\n  // Clone the effects set to avoid infinite loops if the effect triggers itself\n  const effectsToRun = new Set(effects);\n  for (const effect of effectsToRun) {\n    effect();\n  }\n}\n","import { stateContext } from \"~/context\";\n\nimport { track, trigger } from \"./track\";\n\nexport type State<T> = { value: T };\n\n/**\n * Create a state\n *\n * @param initialValue - The initial value of the state.\n * @returns The state object.\n */\nexport function state<T>(initialValue: T): State<T>;\nexport function state<T = undefined>(): State<T | undefined>;\nexport function state<T>(initialValue?: T): State<T | undefined> {\n  if (stateContext) {\n    const { states, index } = stateContext;\n    if (states.length <= index) {\n      // Create new state if it doesn't exist\n      const s = createState(initialValue);\n      states.push(s);\n    }\n    // Return existing state and increment index\n    return states[stateContext.index++];\n  }\n  // fallback: not in a component context\n  return createState(initialValue);\n}\n\nfunction createState<T>(initialValue?: T): State<T | undefined> {\n  const state = { value: initialValue };\n\n  return new Proxy(state, {\n    get(target, key, receiver) {\n      track(target, key);\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, newValue, receiver) {\n      const oldValue = target[key as keyof typeof target];\n      const result = Reflect.set(target, key, newValue, receiver);\n\n      if (oldValue !== newValue) {\n        trigger(target, key);\n      }\n\n      return result;\n    },\n  });\n}\n","import { effect } from \"./effect\";\nimport { state } from \"./state\"; // your Veltra's state()\n\nexport type Computed<T> = {\n  readonly value: T;\n};\n\n/**\n * Create a computed value\n *\n * @param getter - The getter function that returns the computed value from a reactive value.\n * @returns The computed value.\n */\nexport function computed<T>(getter: () => T): Computed<T> {\n  const result = state<T>();\n\n  effect(() => {\n    result.value = getter();\n  });\n\n  return {\n    get value() {\n      return result.value as T;\n    },\n  };\n}\n","import { effect, state, untrack } from \"~/reactivity\";\n\nexport type ResourceReturn<T> = {\n  readonly loading: boolean;\n  readonly error: Error | null;\n  readonly data: T;\n  refetch: () => Promise<void>;\n  mutate: (newValue: T) => void;\n};\n\n/**\n * Create a reactive resource\n *\n * @param fetcher - The function to fetch the data.\n * @returns The resource.\n */\nexport function resource<T>(fetcher: () => Promise<T>): ResourceReturn<T> {\n  const loading = state(true);\n\n  let error = null as Error | null;\n  let data = undefined as T | undefined;\n  let realPromise: Promise<T> | null = null;\n  let promiseStatus = \"pending\" as \"pending\" | \"fulfilled\" | \"rejected\";\n\n  const version = state(0);\n\n  const refetch = async () => {\n    loading.value = true;\n    error = null;\n    data = undefined as T | undefined;\n    promiseStatus = \"pending\";\n    realPromise = fetcher();\n\n    realPromise\n      .then((result) => {\n        data = result;\n        error = null;\n        loading.value = false;\n        promiseStatus = \"fulfilled\";\n        // untrack(() => version.value++);\n      })\n      .catch((err) => {\n        data = undefined as T | undefined;\n        error = err;\n        promiseStatus = \"rejected\";\n        loading.value = false;\n        // untrack(() => version.value++);\n      });\n\n    untrack(() => version.value++);\n  };\n\n  effect(() => {\n    refetch();\n  });\n\n  return {\n    get loading() {\n      return loading.value;\n    },\n    get error() {\n      return error;\n    },\n    get data() {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      version.value;\n      if (promiseStatus === \"pending\") throw realPromise;\n      if (promiseStatus === \"rejected\") throw error;\n\n      return data as T;\n    },\n    refetch,\n    mutate(newValue: T) {\n      data = newValue;\n      version.value++;\n    },\n  };\n}\n","import { track, trigger } from \"./track\";\n\nexport type Store<T extends object> = T;\n\nconst proxyMap = new WeakMap<object, unknown>();\n\nexport function store<T extends object>(initialObject: T): Store<T> {\n  function createReactiveObject(obj: T): T {\n    if (proxyMap.has(obj)) return proxyMap.get(obj) as T;\n\n    const proxy = new Proxy(obj, {\n      get(target, key, receiver) {\n        // track every property access\n        track(target, key);\n\n        const result = Reflect.get(target, key, receiver);\n\n        // Auto-bind methods to the Proxy itself to avoid 'this' becoming DOM or global\n        if (typeof result === \"function\") {\n          return result.bind(receiver);\n        }\n\n        // Handle getters (derived properties)\n        const descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n        if (descriptor?.get) {\n          return descriptor.get.call(receiver);\n        }\n\n        // Deep reactivity\n        if (typeof result === \"object\" && result !== null) {\n          return createReactiveObject(result as T);\n        }\n\n        return result;\n      },\n\n      set(target, key, value, receiver) {\n        const oldValue = target[key as keyof T];\n        const result = Reflect.set(target, key, value, receiver);\n\n        if (oldValue !== value) {\n          trigger(target, key);\n        }\n\n        return result;\n      },\n    });\n\n    proxyMap.set(obj, proxy);\n    return proxy;\n  }\n\n  return createReactiveObject(initialObject);\n}\n","import { toArray } from \"~/util\";\n\nimport { renderChildren } from \"./render-children\";\n\n/**\n * create a root element\n *\n * @param rootElement - The root element.\n * @param App - The app to render.\n */\nexport function createRoot(rootElement: HTMLElement, App: () => JSX.Element) {\n  renderChildren(rootElement, toArray(App()));\n}\n","import { runComponentCleanup } from \"~/life-cycle\";\nimport { state, untrack } from \"~/reactivity\";\nimport { toArray } from \"~/util\";\n\nimport { Entry } from \"./loop\";\n\n/**\n * remove the entry nodes\n *\n * @param parentNode - The parent node.\n * @param entry - The entry to remove.\n */\nexport function removeEntryNodes<T>(parentNode: Node, entry: Entry<T>) {\n  for (const node of entry.nodes) {\n    if (parentNode.contains(node)) {\n      runComponentCleanup(node);\n      parentNode.removeChild(node);\n    }\n  }\n}\n\n/**\n * insert the nodes\n *\n * @param parentNode - The parent node.\n * @param nodes - The nodes to insert.\n * @param referenceNode - The reference node.\n */\nexport function insertNodes(parentNode: Node, nodes: Node[], referenceNode: Node | null) {\n  for (const node of nodes) {\n    parentNode.insertBefore(node, referenceNode);\n  }\n}\n\n/**\n * reorder the entries\n *\n * @param rootNode - The root node.\n * @param parentNode - The parent node.\n * @param entries - The entries to reorder.\n * @param items - The items to reorder.\n */\nexport function reorderEntries<T>(\n  rootNode: Node,\n  parentNode: Node,\n  entries: Entry<T>[],\n  items: T[],\n) {\n  const placeCounts = new Map<T, number>();\n  let ref: Node | null = rootNode.nextSibling;\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    placeCounts.set(item, (placeCounts.get(item) || 0) + 1);\n    let count = 0;\n    const entry = entries.find((e) => e.item === item && ++count === placeCounts.get(item));\n    if (!entry) continue;\n    untrack(() => (entry.index.value = i));\n    insertNodes(parentNode, entry.nodes, ref);\n    ref = entry.nodes[entry.nodes.length - 1].nextSibling;\n  }\n}\n\n/**\n * count the occurrences of an item in a list\n *\n * @param list - The list to count the occurrences of.\n * @returns The occurrences of the item in the list.\n */\nexport function countOccurrences<T>(list: T[]) {\n  const counts = new Map<T, number>();\n  for (const item of list) counts.set(item, (counts.get(item) || 0) + 1);\n  return counts;\n}\n\n/**\n * remove the old nodes\n *\n * @param parentNode - The parent node.\n * @param items - The items to remove.\n * @param entries - The entries to remove.\n */\nexport function removeOldNodes<T>(parentNode: Node, items: T[], entries: Entry<T>[]) {\n  const newCounts = countOccurrences(items);\n  const oldCounts = countOccurrences(entries.map((e) => e.item));\n\n  return entries.filter((entry) => {\n    if ((oldCounts.get(entry.item) ?? 0) > (newCounts.get(entry.item) ?? 0)) {\n      removeEntryNodes(parentNode, entry);\n      oldCounts.set(entry.item, (oldCounts.get(entry.item) ?? 0) - 1);\n      return false;\n    }\n    return true;\n  });\n}\n\n/**\n * create new entries\n *\n * @param items - The items to create new entries for.\n * @param entries - The entries to create new entries for.\n * @param children - The children to create new entries for.\n * @param idCounter - The id counter.\n * @returns The new entries.\n */\nexport function newEntries<T>(\n  items: T[],\n  entries: Entry<T>[],\n  children: (\n    item: T,\n    index: {\n      value: number;\n    },\n  ) => JSX.Element,\n  idCounter: number,\n) {\n  const addedEntries: Entry<T>[] = [];\n  const seenCounts = new Map<T, number>();\n  for (const item of items) {\n    seenCounts.set(item, (seenCounts.get(item) || 0) + 1);\n    const exists =\n      entries.filter((e) => e.item === item).length +\n      addedEntries.filter((e) => e.item === item).length;\n    if (exists < (seenCounts.get(item) || 0)) {\n      const indexState = state(-1);\n      const nodes = toArray(children(item, indexState)) as Node[];\n      addedEntries.push({\n        id: idCounter++,\n        item,\n        nodes,\n        index: indexState,\n      });\n    }\n  }\n\n  return addedEntries;\n}\n","import { jsx } from \"~/jsx-runtime\";\nimport { onDestroy, onMount } from \"~/life-cycle\";\nimport { effect, State } from \"~/reactivity\";\nimport { componentRootNodes } from \"~/render\";\n\nimport { newEntries, removeEntryNodes, removeOldNodes, reorderEntries } from \"./util\";\n\nexport type Entry<T> = {\n  id: number;\n  item: T;\n  nodes: Node[];\n  index: { value: number };\n};\n\n/**\n * create a loop component\n *\n * @param items - The items to loop through.\n * @returns The loop component.\n */\nexport function loop<T>(items: T[]) {\n  // const handler = getCurrentSuspenseHandler();\n\n  return {\n    each: (children: (item: T, index: State<number>) => JSX.Element) => {\n      const each = items as unknown as () => T[];\n      children = children as unknown as [(item: T, index: State<number>) => JSX.Element][0];\n      // Use jsx to register it as a component\n      // That way we can use life cycles hooks\n      // const trigger = state(() => each());\n      // effect(() => {\n      //   console.log(trigger.value());\n      // });\n\n      // untrack(() => each());\n\n      return jsx(() => {\n        const rootNode = document.createTextNode(\"\");\n\n        let entries: Entry<T>[] = [];\n        // eslint-disable-next-line\n        let idCounter = 0;\n\n        function reconcile(parentNode: Node, items: T[]) {\n          // Remove extra\n          entries = removeOldNodes(parentNode, items, entries);\n          // Add new\n          entries.push(...newEntries(items, entries, children, idCounter));\n\n          reorderEntries(rootNode, parentNode, entries, items);\n        }\n\n        const render = () => {\n          const parentNode = rootNode.parentNode;\n          if (!parentNode) return;\n\n          const list = each();\n          if (!list) return;\n\n          reconcile(parentNode, [...list]);\n        };\n\n        onMount(() => {\n          effect(() => {\n            render();\n          });\n        });\n\n        onDestroy(() => {\n          for (const entry of entries) {\n            removeEntryNodes(rootNode.parentNode!, entry);\n          }\n        });\n\n        componentRootNodes.add(rootNode);\n        return rootNode;\n      }, {});\n    },\n  };\n}\n","import { componentRootNodes } from \"../render\";\n\n/**\n * log the JSX elements\n *\n * @param nodes - The nodes to log.\n * @returns The nodes that are not text nodes and are not in the componentRootNodes set.\n */\nexport function logJsx(nodes: Node[]) {\n  const newNodes = [\n    ...nodes.filter((node) => !(node instanceof Text && componentRootNodes.has(node))),\n  ];\n\n  return newNodes.length === 1 ? newNodes[0] : newNodes;\n}\n","/**\n * memoize a function\n *\n * @param fn - The function to memoize.\n * @returns The memoized function.\n */\nexport function memo<T>(fn: () => T) {\n  let cachedResult: T;\n  let firstRun = true;\n\n  return () => {\n    if (firstRun) {\n      cachedResult = fn();\n      firstRun = false;\n    }\n    return cachedResult;\n  };\n}\n","/**\n * unwraps proxy objects\n *\n * @param value - The value to unwrap.\n * @returns The unwrapped value.\n */\nexport function unwrap<T>(value: any): Partial<T> {\n  function deepUnwrap(obj: any): any {\n    if (obj === null || typeof obj !== \"object\") return obj;\n\n    if (typeof obj === \"function\") return obj;\n\n    const result: any = {};\n    for (const key of Reflect.ownKeys(obj)) {\n      const value = obj[key];\n      result[key] = deepUnwrap(value);\n    }\n    return result;\n  }\n\n  return deepUnwrap(value);\n}\n"],"names":["onDestroy","fn","destroyContext","targetToPropertyEffectsMap","track","target","key","activeEffect","propertyEffectsMap","effects","trigger","effectsToRun","effect","state","initialValue","stateContext","states","index","s","createState","receiver","newValue","oldValue","result","computed","getter","resource","fetcher","loading","error","data","realPromise","promiseStatus","version","refetch","err","untrack","proxyMap","store","initialObject","createReactiveObject","obj","proxy","descriptor","value","createRoot","rootElement","App","renderChildren","toArray","removeEntryNodes","parentNode","entry","node","runComponentCleanup","insertNodes","nodes","referenceNode","reorderEntries","rootNode","entries","items","placeCounts","ref","i","item","count","e","countOccurrences","list","counts","removeOldNodes","newCounts","oldCounts","newEntries","children","idCounter","addedEntries","seenCounts","indexState","loop","each","jsx","reconcile","render","onMount","componentRootNodes","logJsx","newNodes","memo","cachedResult","firstRun","unwrap","deepUnwrap"],"mappings":"6LASgB,SAAAA,EAAUC,EAAgB,CACxC,GAAIC,EACFA,EAAe,KAAKD,CAAE,aAEhB,IAAI,MAAM,uCAAuC,CAE3D,CCVA,MAAME,EAA+E,IAAI,QAQzE,SAAAC,EAAMC,EAAgBC,EAAkB,CACtD,GAAI,CAACC,EAAc,OAEnB,IAAIC,EAAqBL,EAA2B,IAAIE,CAAM,EACzDG,IACHA,EAAqB,IAAI,IACzBL,EAA2B,IAAIE,EAAQG,CAAkB,GAG3D,IAAIC,EAAUD,EAAmB,IAAIF,CAAG,EACnCG,IACHA,EAAU,IAAI,IACdD,EAAmB,IAAIF,EAAKG,CAAO,GAGhCA,EAAQ,IAAIF,CAAY,IAC3BE,EAAQ,IAAIF,CAAY,EAEpBA,EAAa,KACfA,EAAa,KAAK,KAAKE,CAAO,EAE9BF,EAAa,KAAO,CAACE,CAAO,EAGlC,UAQgBC,EAAQL,EAAgBC,EAAkB,CACxD,MAAME,EAAqBL,EAA2B,IAAIE,CAAM,EAChE,GAAI,CAACG,EAAoB,OAEzB,MAAMC,EAAUD,EAAmB,IAAIF,CAAG,EAC1C,GAAI,CAACG,EAAS,OAGd,MAAME,EAAe,IAAI,IAAIF,CAAO,EACpC,UAAWG,KAAUD,EACnBC,EAEJ,CAAA,CC3CO,SAASC,EAASC,EAAwC,CAC/D,GAAIC,EAAc,CAChB,KAAM,CAAE,OAAAC,EAAQ,MAAAC,CAAM,EAAIF,EAC1B,GAAIC,EAAO,QAAUC,EAAO,CAE1B,MAAMC,EAAIC,EAAYL,CAAY,EAClCE,EAAO,KAAKE,CAAC,CACf,CAEA,OAAOF,EAAOD,EAAa,OAAO,CACpC,CAEA,OAAOI,EAAYL,CAAY,CACjC,CAEA,SAASK,EAAeL,EAAwC,CAC9D,MAAMD,EAAQ,CAAE,MAAOC,CAAa,EAEpC,OAAO,IAAI,MAAMD,EAAO,CACtB,IAAIR,EAAQC,EAAKc,EAAU,CACzB,OAAAhB,EAAMC,EAAQC,CAAG,EACV,QAAQ,IAAID,EAAQC,EAAKc,CAAQ,CAC1C,EACA,IAAIf,EAAQC,EAAKe,EAAUD,EAAU,CACnC,MAAME,EAAWjB,EAAOC,CAA0B,EAC5CiB,EAAS,QAAQ,IAAIlB,EAAQC,EAAKe,EAAUD,CAAQ,EAE1D,OAAIE,IAAaD,GACfX,EAAQL,EAAQC,CAAG,EAGdiB,CACT,CACF,CAAC,CACH,CCnCgB,SAAAC,EAAYC,EAA8B,CACxD,MAAMF,EAASV,IAEf,OAAAD,EAAO,IAAM,CACXW,EAAO,MAAQE,EAAAA,CACjB,CAAC,EAEM,CACL,IAAI,OAAQ,CACV,OAAOF,EAAO,KAChB,CACF,CACF,CCTO,SAASG,EAAYC,EAA8C,CACxE,MAAMC,EAAUf,EAAM,EAAI,EAE1B,IAAIgB,EAAQ,KACRC,EACAC,EAAiC,KACjCC,EAAgB,UAEpB,MAAMC,EAAUpB,EAAM,CAAC,EAEjBqB,EAAU,SAAY,CAC1BN,EAAQ,MAAQ,GAChBC,EAAQ,KACRC,EAAO,OACPE,EAAgB,UAChBD,EAAcJ,IAEdI,EACG,KAAMR,GAAW,CAChBO,EAAOP,EACPM,EAAQ,KACRD,EAAQ,MAAQ,GAChBI,EAAgB,WAElB,CAAC,EACA,MAAOG,GAAQ,CACdL,EAAO,OACPD,EAAQM,EACRH,EAAgB,WAChBJ,EAAQ,MAAQ,EAElB,CAAC,EAEHQ,EAAQ,IAAMH,EAAQ,OAAO,CAC/B,EAEA,OAAArB,EAAO,IAAM,CACXsB,GACF,CAAC,EAEM,CACL,IAAI,SAAU,CACZ,OAAON,EAAQ,KACjB,EACA,IAAI,OAAQ,CACV,OAAOC,CACT,EACA,IAAI,MAAO,CAGT,GADAI,EAAQ,MACJD,IAAkB,UAAW,MAAMD,EACvC,GAAIC,IAAkB,WAAY,MAAMH,EAExC,OAAOC,CACT,EACA,QAAAI,EACA,OAAOb,EAAa,CAClBS,EAAOT,EACPY,EAAQ,OACV,CACF,CACF,CCzEA,MAAMI,EAAW,IAAI,QAEd,SAASC,EAAwBC,EAA4B,CAClE,SAASC,EAAqBC,EAAW,CACvC,GAAIJ,EAAS,IAAII,CAAG,EAAG,OAAOJ,EAAS,IAAII,CAAG,EAE9C,MAAMC,EAAQ,IAAI,MAAMD,EAAK,CAC3B,IAAIpC,EAAQC,EAAKc,EAAU,CAEzBhB,EAAMC,EAAQC,CAAG,EAEjB,MAAMiB,EAAS,QAAQ,IAAIlB,EAAQC,EAAKc,CAAQ,EAGhD,GAAI,OAAOG,GAAW,WACpB,OAAOA,EAAO,KAAKH,CAAQ,EAI7B,MAAMuB,EAAa,QAAQ,yBAAyBtC,EAAQC,CAAG,EAC/D,OAAIqC,GAAY,IACPA,EAAW,IAAI,KAAKvB,CAAQ,EAIjC,OAAOG,GAAW,UAAYA,IAAW,KACpCiB,EAAqBjB,CAAW,EAGlCA,CACT,EAEA,IAAIlB,EAAQC,EAAKsC,EAAOxB,EAAU,CAChC,MAAME,EAAWjB,EAAOC,CAAc,EAChCiB,EAAS,QAAQ,IAAIlB,EAAQC,EAAKsC,EAAOxB,CAAQ,EAEvD,OAAIE,IAAasB,GACflC,EAAQL,EAAQC,CAAG,EAGdiB,CACT,CACF,CAAC,EAED,OAAAc,EAAS,IAAII,EAAKC,CAAK,EAChBA,CACT,CAEA,OAAOF,EAAqBD,CAAa,CAC3C,CC3CgB,SAAAM,EAAWC,EAA0BC,EAAwB,CAC3EC,EAAeF,EAAaG,EAAQF,EAAI,CAAC,CAAC,CAC5C,UCAgBG,EAAoBC,EAAkBC,EAAiB,CACrE,UAAWC,KAAQD,EAAM,MACnBD,EAAW,SAASE,CAAI,IAC1BC,EAAoBD,CAAI,EACxBF,EAAW,YAAYE,CAAI,EAGjC,CASgB,SAAAE,EAAYJ,EAAkBK,EAAeC,EAA4B,CACvF,UAAWJ,KAAQG,EACjBL,EAAW,aAAaE,EAAMI,CAAa,CAE/C,UAUgBC,EACdC,EACAR,EACAS,EACAC,EACA,CACA,MAAMC,EAAc,IAAI,IACxB,IAAIC,EAAmBJ,EAAS,YAEhC,QAASK,EAAI,EAAGA,EAAIH,EAAM,OAAQG,IAAK,CACrC,MAAMC,EAAOJ,EAAMG,CAAC,EACpBF,EAAY,IAAIG,GAAOH,EAAY,IAAIG,CAAI,GAAK,GAAK,CAAC,EACtD,IAAIC,EAAQ,EACZ,MAAMd,EAAQQ,EAAQ,KAAMO,GAAMA,EAAE,OAASF,GAAQ,EAAEC,IAAUJ,EAAY,IAAIG,CAAI,CAAC,EACjFb,IACLhB,EAAQ,IAAOgB,EAAM,MAAM,MAAQY,CAAE,EACrCT,EAAYJ,EAAYC,EAAM,MAAOW,CAAG,EACxCA,EAAMX,EAAM,MAAMA,EAAM,MAAM,OAAS,CAAC,EAAE,YAC5C,CACF,UAQgBgB,EAAoBC,EAAW,CAC7C,MAAMC,EAAS,IAAI,IACnB,UAAWL,KAAQI,EAAMC,EAAO,IAAIL,GAAOK,EAAO,IAAIL,CAAI,GAAK,GAAK,CAAC,EACrE,OAAOK,CACT,CASgB,SAAAC,EAAkBpB,EAAkBU,EAAYD,EAAqB,CACnF,MAAMY,EAAYJ,EAAiBP,CAAK,EAClCY,EAAYL,EAAiBR,EAAQ,IAAKO,GAAMA,EAAE,IAAI,CAAC,EAE7D,OAAOP,EAAQ,OAAQR,IAChBqB,EAAU,IAAIrB,EAAM,IAAI,GAAK,IAAMoB,EAAU,IAAIpB,EAAM,IAAI,GAAK,IACnEF,EAAiBC,EAAYC,CAAK,EAClCqB,EAAU,IAAIrB,EAAM,MAAOqB,EAAU,IAAIrB,EAAM,IAAI,GAAK,GAAK,CAAC,EACvD,IAEF,EACR,CACH,CAWO,SAASsB,EACdb,EACAD,EACAe,EAMAC,EACA,CACA,MAAMC,EAA2B,GAC3BC,EAAa,IAAI,IACvB,UAAWb,KAAQJ,EAKjB,GAJAiB,EAAW,IAAIb,GAAOa,EAAW,IAAIb,CAAI,GAAK,GAAK,CAAC,EAElDL,EAAQ,OAAQO,GAAMA,EAAE,OAASF,CAAI,EAAE,OACvCY,EAAa,OAAQV,GAAMA,EAAE,OAASF,CAAI,EAAE,QAChCa,EAAW,IAAIb,CAAI,GAAK,GAAI,CACxC,MAAMc,EAAalE,EAAM,EAAE,EACrB2C,EAAQP,EAAQ0B,EAASV,EAAMc,CAAU,CAAC,EAChDF,EAAa,KAAK,CAChB,GAAID,IACJ,KAAAX,EACA,MAAAT,EACA,MAAOuB,CACT,CAAC,CACH,CAGF,OAAOF,CACT,UCpHgBG,EAAQnB,EAAY,CAGlC,MAAO,CACL,KAAOc,GAA6D,CAClE,MAAMM,EAAOpB,EACb,OAAAc,EAAWA,EAUJO,EAAI,IAAM,CACf,MAAMvB,EAAW,SAAS,eAAe,EAAE,EAE3C,IAAIC,EAAsB,CAAA,EAEtBgB,EAAY,EAEhB,SAASO,EAAUhC,EAAkBU,EAAY,CAE/CD,EAAUW,EAAepB,EAAYU,EAAOD,CAAO,EAEnDA,EAAQ,KAAK,GAAGc,EAAWb,EAAOD,EAASe,EAAUC,CAAS,CAAC,EAE/DlB,EAAeC,EAAUR,EAAYS,EAASC,CAAK,CACrD,CAEA,MAAMuB,EAAS,IAAM,CACnB,MAAMjC,EAAaQ,EAAS,WAC5B,GAAI,CAACR,EAAY,OAEjB,MAAMkB,EAAOY,IACRZ,GAELc,EAAUhC,EAAY,CAAC,GAAGkB,CAAI,CAAC,CACjC,EAEA,OAAAgB,EAAQ,IAAM,CACZzE,EAAO,IAAM,CACXwE,EAAO,CACT,CAAC,CACH,CAAC,EAEDpF,EAAU,IAAM,CACd,UAAWoD,KAASQ,EAClBV,EAAiBS,EAAS,WAAaP,CAAK,CAEhD,CAAC,EAEDkC,EAAmB,IAAI3B,CAAQ,EACxBA,CACT,EAAG,CAAE,CAAA,CACP,CACF,CACF,CCvEO,SAAS4B,EAAO/B,EAAe,CACpC,MAAMgC,EAAW,CACf,GAAGhC,EAAM,OAAQH,GAAS,EAAEA,aAAgB,MAAQiC,EAAmB,IAAIjC,CAAI,EAAE,CACnF,EAEA,OAAOmC,EAAS,SAAW,EAAIA,EAAS,CAAC,EAAIA,CAC/C,CCRO,SAASC,EAAQxF,EAAa,CACnC,IAAIyF,EACAC,EAAW,GAEf,MAAO,KACDA,IACFD,EAAezF,EACf0F,EAAAA,EAAW,IAEND,EAEX,CCXgB,SAAAE,EAAUhD,EAAwB,CAChD,SAASiD,EAAWpD,EAAe,CAGjC,GAFIA,IAAQ,MAAQ,OAAOA,GAAQ,UAE/B,OAAOA,GAAQ,WAAY,OAAOA,EAEtC,MAAMlB,EAAc,GACpB,UAAWjB,KAAO,QAAQ,QAAQmC,CAAG,EAAG,CACtC,MAAMG,EAAQH,EAAInC,CAAG,EACrBiB,EAAOjB,CAAG,EAAIuF,EAAWjD,CAAK,CAChC,CACA,OAAOrB,CACT,CAEA,OAAOsE,EAAWjD,CAAK,CACzB"}