{"version":3,"file":"index.js","sources":["../../src/life-cycle/on-destroy.ts","../../src/life-cycle/on-mount.ts","../../src/reactivity/computed.ts","../../src/reactivity/resource.ts","../../src/reactivity/store.ts","../../src/render/create-root.ts","../../src/render/loop/util.ts","../../src/render/loop/loop.ts","../../src/util/log-jsx.ts","../../src/util/memo.ts","../../src/util/unwrap.ts"],"sourcesContent":["import { destroyContext } from \"~/context\";\n\nexport type DestroyFn = () => void;\n\nexport function onDestroy(fn: () => void) {\n  if (destroyContext) {\n    destroyContext.push(fn);\n  } else {\n    throw new Error(\"onDestroy called outside of component\");\n  }\n}\n","import { mountContext } from \"~/context\";\n\nexport type MountFn = () => void | (() => void);\n\nexport function onMount(fn: () => () => void): void;\nexport function onMount(fn: () => void): void;\nexport function onMount(fn: MountFn): void {\n  if (mountContext) {\n    mountContext.push(fn);\n  } else {\n    throw new Error(\"onMount called outside of component\");\n  }\n}\n","import { effect } from \"./effect\";\nimport { state } from \"./state\"; // your Veltra's state()\n\nexport type Computed<T> = {\n  readonly value: T;\n};\n\nexport function computed<T>(getter: () => T): Computed<T> {\n  const result = state<T>(); // Real state that reactors and effects can track\n\n  effect(() => {\n    result.value = getter(); // when dependencies change, recompute and trigger .value\n  });\n\n  return {\n    get value() {\n      return result.value as T; // will track this as a true state()\n    },\n  };\n}\n","import { effect, store } from \"~/reactivity\";\n\nexport function resource<T>(fetcher: () => Promise<T>) {\n  const data = store({\n    loading: true,\n    error: null as Error | null,\n    data: undefined as T,\n  });\n\n  let realPromise: Promise<void> | null = null;\n\n  const refetch = () => {\n    data.loading = true;\n\n    realPromise = new Promise<void>((resolve, reject) => {\n      fetcher()\n        .then((result) => {\n          data.data = result;\n          data.loading = false;\n          data.error = null;\n          resolve();\n        })\n        .catch((err) => {\n          data.error = err;\n          data.loading = false;\n          reject(err);\n        });\n    });\n\n    return realPromise;\n  };\n\n  effect(() => {\n    refetch();\n  });\n\n  return {\n    get loading() {\n      return data.loading;\n    },\n    get error() {\n      return data.error;\n    },\n    get data() {\n      if (data.loading) throw realPromise;\n      if (!data.loading && data.error) throw data.error;\n      return data.data;\n    },\n    refetch,\n    mutate(newValue: T) {\n      data.data = newValue;\n    },\n  };\n}\n","import { track, trigger } from \"./track\";\n\nexport type Store<T extends object> = T;\n\nconst proxyMap = new WeakMap<object, unknown>();\n\nexport function store<T extends object>(initialObject: T): Store<T> {\n  function createReactiveObject(obj: T): T {\n    if (proxyMap.has(obj)) return proxyMap.get(obj) as T;\n\n    const proxy = new Proxy(obj, {\n      get(target, key, receiver) {\n        // track every property access\n        track(target, key);\n\n        const result = Reflect.get(target, key, receiver);\n\n        // Auto-bind methods to the Proxy itself to avoid 'this' becoming DOM or global\n        if (typeof result === \"function\") {\n          return result.bind(receiver);\n        }\n\n        // Handle getters (derived properties)\n        const descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n        if (descriptor?.get) {\n          return descriptor.get.call(receiver);\n        }\n\n        // Deep reactivity, but avoid DOM Nodes\n        if (typeof result === \"object\" && result !== null && !(result instanceof Node)) {\n          return createReactiveObject(result as T);\n        }\n\n        return result;\n      },\n\n      set(target, key, value, receiver) {\n        const oldValue = target[key as keyof T];\n        const result = Reflect.set(target, key, value, receiver);\n\n        if (oldValue !== value) {\n          trigger(target, key);\n        }\n\n        return result;\n      },\n    });\n\n    proxyMap.set(obj, proxy);\n    return proxy;\n  }\n\n  return createReactiveObject(initialObject);\n}\n","import { toArray } from \"~/util\";\n\nimport { renderChildren } from \"./render-children\";\n\n/**\n * create a root element\n *\n * @param $root - The root element.\n * @param App - The app to render.\n */\nexport function createRoot($root: HTMLElement, App: () => JSX.Element) {\n  renderChildren($root, toArray(App()));\n}\n","import { runComponentCleanup } from \"~/life-cycle\";\nimport { state, untrack } from \"~/reactivity\";\nimport { toArray } from \"~/util\";\n\nimport { Entry } from \"./loop\";\n\n/**\n * remove the entry nodes\n *\n * @param $parent - The parent node.\n * @param entry - The entry to remove.\n */\nexport function removeEntryNodes<T>($parent: Node, entry: Entry<T>) {\n  for (const node of entry.nodes) {\n    if ($parent.contains(node)) {\n      runComponentCleanup(node);\n      $parent.removeChild(node);\n    }\n  }\n}\n\n/**\n * insert the nodes\n *\n * @param $parent - The parent node.\n * @param nodes - The nodes to insert.\n * @param referenceNode - The reference node.\n */\nexport function insertNodes($parent: Node, nodes: Node[], referenceNode: Node | null) {\n  for (const node of nodes) {\n    $parent.insertBefore(node, referenceNode);\n  }\n}\n\n/**\n * reorder the entries\n *\n * @param $rootNode - The root node.\n * @param $parent - The parent node.\n * @param entries - The entries to reorder.\n * @param items - The items to reorder.\n */\nexport function reorderEntries<T>($rootNode: Node, $parent: Node, entries: Entry<T>[], items: T[]) {\n  const placeCounts = new Map<T, number>();\n  let ref: Node | null = $rootNode.nextSibling;\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    placeCounts.set(item, (placeCounts.get(item) || 0) + 1);\n    let count = 0;\n    const entry = entries.find((e) => e.item === item && ++count === placeCounts.get(item));\n    if (!entry) continue;\n    untrack(() => (entry.index.value = i));\n    insertNodes($parent, entry.nodes, ref);\n    ref = entry.nodes[entry.nodes.length - 1].nextSibling;\n  }\n}\n\n/**\n * count the occurrences of an item in a list\n *\n * @param list - The list to count the occurrences of.\n * @returns The occurrences of the item in the list.\n */\nexport function countOccurrences<T>(list: T[]) {\n  const counts = new Map<T, number>();\n  for (const item of list) counts.set(item, (counts.get(item) || 0) + 1);\n  return counts;\n}\n\n/**\n * remove the old nodes\n *\n * @param $parent - The parent node.\n * @param items - The items to remove.\n * @param entries - The entries to remove.\n */\nexport function removeOldNodes<T>($parent: Node, items: T[], entries: Entry<T>[]) {\n  const newCounts = countOccurrences(items);\n  const oldCounts = countOccurrences(entries.map((e) => e.item));\n\n  return entries.filter((entry) => {\n    if ((oldCounts.get(entry.item) ?? 0) > (newCounts.get(entry.item) ?? 0)) {\n      removeEntryNodes($parent, entry);\n      oldCounts.set(entry.item, (oldCounts.get(entry.item) ?? 0) - 1);\n      return false;\n    }\n    return true;\n  });\n}\n\n/**\n * create new entries\n *\n * @param items - The items to create new entries for.\n * @param entries - The entries to create new entries for.\n * @param children - The children to create new entries for.\n * @param idCounter - The id counter.\n * @returns The new entries.\n */\nexport function newEntries<T>(\n  items: T[],\n  entries: Entry<T>[],\n  children: (\n    item: T,\n    index: {\n      value: number;\n    },\n  ) => JSX.Element,\n  idCounter: number,\n) {\n  const addedEntries: Entry<T>[] = [];\n  const seenCounts = new Map<T, number>();\n  for (const item of items) {\n    seenCounts.set(item, (seenCounts.get(item) || 0) + 1);\n    const exists =\n      entries.filter((e) => e.item === item).length +\n      addedEntries.filter((e) => e.item === item).length;\n    if (exists < (seenCounts.get(item) || 0)) {\n      const indexState = state(-1);\n      const nodes = toArray(children(item, indexState)) as Node[];\n      addedEntries.push({\n        id: idCounter++,\n        item,\n        nodes,\n        index: indexState,\n      });\n    }\n  }\n\n  return addedEntries;\n}\n","import { jsx } from \"~/jsx-runtime\";\nimport { onDestroy, onMount } from \"~/life-cycle\";\nimport { effect, State } from \"~/reactivity\";\nimport { componentRootNodes, suspensePromise } from \"~/render\";\n\nimport { newEntries, removeEntryNodes, removeOldNodes, reorderEntries } from \"./util\";\n\ntype ForProps<T> = {\n  items: () => T[];\n  children: [(item: T, index: { value: number }) => JSX.Element];\n};\n\nexport type Entry<T> = {\n  id: number;\n  item: T;\n  nodes: Node[];\n  index: { value: number };\n};\n\n/**\n * create a loop component\n *\n * @param items - The items to loop through.\n * @returns The loop component.\n */\nexport function loop<T>(items: T[]) {\n  return {\n    each: (children: (item: T, index: State<number>) => JSX.Element) => {\n      // Use jsx to register it as a component\n      // That way we can use life cycles hooks\n      return jsx(\n        (props: ForProps<T>) => {\n          const {\n            items: each,\n            children: [children],\n          } = props;\n\n          const $rootNode = document.createTextNode(\"\");\n\n          let entries: Entry<T>[] = [];\n          const idCounter = 0;\n\n          function reconcile($parent: Node, items: T[]) {\n            // Remove extra\n            entries = removeOldNodes($parent, items, entries);\n            // Add new\n            entries.push(...newEntries(items, entries, children, idCounter));\n\n            reorderEntries($rootNode, $parent, entries, items);\n          }\n\n          onMount(() => {\n            effect(() => {\n              const $parent = $rootNode.parentNode;\n              if (!$parent) return;\n\n              try {\n                const list = each();\n                if (!list) return;\n\n                reconcile($parent, [...list]);\n              } catch (errorOrPromise) {\n                if (errorOrPromise instanceof Promise) {\n                  suspensePromise.value = errorOrPromise;\n                } else {\n                  throw errorOrPromise;\n                }\n              }\n            });\n          });\n\n          onDestroy(() => {\n            for (const entry of entries) {\n              removeEntryNodes($rootNode.parentNode!, entry);\n            }\n          });\n\n          componentRootNodes.add($rootNode);\n          return $rootNode;\n        },\n        {\n          items: () => items,\n          children,\n        },\n      );\n    },\n  };\n}\n","import { componentRootNodes } from \"../render\";\n\n/**\n * log the JSX elements\n *\n * @param $nodes - The nodes to log.\n * @returns The nodes that are not text nodes and are not in the componentRootNodes set.\n */\nexport function logJsx($nodes: Node[]) {\n  const $newNodes = [\n    ...$nodes.filter(($node) => !($node instanceof Text && componentRootNodes.has($node))),\n  ];\n\n  return $newNodes.length === 1 ? $newNodes[0] : $newNodes;\n}\n","/**\n * memoize a function\n *\n * @param fn - The function to memoize.\n * @returns The memoized function.\n */\nexport function memo<T>(fn: () => T) {\n  let cachedResult: T;\n  let firstRun = true;\n\n  return () => {\n    if (firstRun) {\n      cachedResult = fn();\n      firstRun = false;\n    }\n    return cachedResult;\n  };\n}\n","/**\n * unwraps proxy objects\n *\n * @param value - The value to unwrap.\n * @returns The unwrapped value.\n */\nexport function unwrap<T>(value: any): Partial<T> {\n  function deepUnwrap(obj: any): any {\n    if (obj === null || typeof obj !== \"object\") return obj;\n\n    if (typeof obj === \"function\") return obj;\n\n    const result: any = {};\n    for (const key of Reflect.ownKeys(obj)) {\n      const value = obj[key];\n      result[key] = deepUnwrap(value);\n    }\n    return result;\n  }\n\n  return deepUnwrap(value);\n}\n"],"names":["onDestroy","fn","destroyContext","onMount","mountContext","computed","getter","result","state","effect","resource","fetcher","data","store","realPromise","refetch","resolve","reject","err","newValue","proxyMap","initialObject","createReactiveObject","obj","proxy","target","key","receiver","track","descriptor","value","oldValue","trigger","createRoot","$root","App","renderChildren","toArray","removeEntryNodes","$parent","entry","node","runComponentCleanup","insertNodes","nodes","referenceNode","reorderEntries","$rootNode","entries","items","placeCounts","ref","i","item","count","e","untrack","countOccurrences","list","counts","removeOldNodes","newCounts","oldCounts","newEntries","children","idCounter","addedEntries","seenCounts","indexState","loop","jsx","props","each","reconcile","errorOrPromise","suspensePromise","componentRootNodes","logJsx","$nodes","$newNodes","$node","memo","cachedResult","firstRun","unwrap","deepUnwrap"],"mappings":"mNAIgB,SAAAA,EAAUC,EAAgB,CACxC,GAAIC,EACFA,EAAe,KAAKD,CAAE,aAEhB,IAAI,MAAM,uCAAuC,CAE3D,CCJgB,SAAAE,EAAQF,EAAmB,CACzC,GAAIG,EACFA,EAAa,KAAKH,CAAE,aAEd,IAAI,MAAM,qCAAqC,CAEzD,CCLgB,SAAAI,EAAYC,EAA8B,CACxD,MAAMC,EAASC,IAEf,OAAAC,EAAO,IAAM,CACXF,EAAO,MAAQD,EAAAA,CACjB,CAAC,EAEM,CACL,IAAI,OAAQ,CACV,OAAOC,EAAO,KAChB,CACF,CACF,CCjBO,SAASG,EAAYC,EAA2B,CACrD,MAAMC,EAAOC,EAAM,CACjB,QAAS,GACT,MAAO,KACP,KAAM,MACR,CAAC,EAED,IAAIC,EAAoC,KAExC,MAAMC,EAAU,KACdH,EAAK,QAAU,GAEfE,EAAc,IAAI,QAAc,CAACE,EAASC,IAAW,CACnDN,IACG,KAAMJ,GAAW,CAChBK,EAAK,KAAOL,EACZK,EAAK,QAAU,GACfA,EAAK,MAAQ,KACbI,EAAAA,CACF,CAAC,EACA,MAAOE,GAAQ,CACdN,EAAK,MAAQM,EACbN,EAAK,QAAU,GACfK,EAAOC,CAAG,CACZ,CAAC,CACL,CAAC,EAEMJ,GAGT,OAAAL,EAAO,IAAM,CACXM,EACF,CAAA,CAAC,EAEM,CACL,IAAI,SAAU,CACZ,OAAOH,EAAK,OACd,EACA,IAAI,OAAQ,CACV,OAAOA,EAAK,KACd,EACA,IAAI,MAAO,CACT,GAAIA,EAAK,QAAS,MAAME,EACxB,GAAI,CAACF,EAAK,SAAWA,EAAK,MAAO,MAAMA,EAAK,MAC5C,OAAOA,EAAK,IACd,EACA,QAAAG,EACA,OAAOI,EAAa,CAClBP,EAAK,KAAOO,CACd,CACF,CACF,CCjDA,MAAMC,EAAW,IAAI,QAEd,SAASP,EAAwBQ,EAA4B,CAClE,SAASC,EAAqBC,EAAW,CACvC,GAAIH,EAAS,IAAIG,CAAG,EAAG,OAAOH,EAAS,IAAIG,CAAG,EAE9C,MAAMC,EAAQ,IAAI,MAAMD,EAAK,CAC3B,IAAIE,EAAQC,EAAKC,EAAU,CAEzBC,EAAMH,EAAQC,CAAG,EAEjB,MAAMnB,EAAS,QAAQ,IAAIkB,EAAQC,EAAKC,CAAQ,EAGhD,GAAI,OAAOpB,GAAW,WACpB,OAAOA,EAAO,KAAKoB,CAAQ,EAI7B,MAAME,EAAa,QAAQ,yBAAyBJ,EAAQC,CAAG,EAC/D,OAAIG,GAAY,IACPA,EAAW,IAAI,KAAKF,CAAQ,EAIjC,OAAOpB,GAAW,UAAYA,IAAW,MAAQ,EAAEA,aAAkB,MAChEe,EAAqBf,CAAW,EAGlCA,CACT,EAEA,IAAIkB,EAAQC,EAAKI,EAAOH,EAAU,CAChC,MAAMI,EAAWN,EAAOC,CAAc,EAChCnB,EAAS,QAAQ,IAAIkB,EAAQC,EAAKI,EAAOH,CAAQ,EAEvD,OAAII,IAAaD,GACfE,EAAQP,EAAQC,CAAG,EAGdnB,CACT,CACF,CAAC,EAED,OAAAa,EAAS,IAAIG,EAAKC,CAAK,EAChBA,CACT,CAEA,OAAOF,EAAqBD,CAAa,CAC3C,CC3CgB,SAAAY,EAAWC,EAAoBC,EAAwB,CACrEC,EAAeF,EAAOG,EAAQF,EAAI,CAAC,CAAC,CACtC,UCAgBG,EAAoBC,EAAeC,EAAiB,CAClE,UAAWC,KAAQD,EAAM,MACnBD,EAAQ,SAASE,CAAI,IACvBC,EAAoBD,CAAI,EACxBF,EAAQ,YAAYE,CAAI,EAG9B,CASgB,SAAAE,EAAYJ,EAAeK,EAAeC,EAA4B,CACpF,UAAWJ,KAAQG,EACjBL,EAAQ,aAAaE,EAAMI,CAAa,CAE5C,UAUgBC,EAAkBC,EAAiBR,EAAeS,EAAqBC,EAAY,CACjG,MAAMC,EAAc,IAAI,IACxB,IAAIC,EAAmBJ,EAAU,YAEjC,QAASK,EAAI,EAAGA,EAAIH,EAAM,OAAQG,IAAK,CACrC,MAAMC,EAAOJ,EAAMG,CAAC,EACpBF,EAAY,IAAIG,GAAOH,EAAY,IAAIG,CAAI,GAAK,GAAK,CAAC,EACtD,IAAIC,EAAQ,EACZ,MAAMd,EAAQQ,EAAQ,KAAMO,GAAMA,EAAE,OAASF,GAAQ,EAAEC,IAAUJ,EAAY,IAAIG,CAAI,CAAC,EACjFb,IACLgB,EAAQ,IAAOhB,EAAM,MAAM,MAAQY,CAAE,EACrCT,EAAYJ,EAASC,EAAM,MAAOW,CAAG,EACrCA,EAAMX,EAAM,MAAMA,EAAM,MAAM,OAAS,CAAC,EAAE,YAC5C,CACF,UAQgBiB,EAAoBC,EAAW,CAC7C,MAAMC,EAAS,IAAI,IACnB,UAAWN,KAAQK,EAAMC,EAAO,IAAIN,GAAOM,EAAO,IAAIN,CAAI,GAAK,GAAK,CAAC,EACrE,OAAOM,CACT,CASgB,SAAAC,EAAkBrB,EAAeU,EAAYD,EAAqB,CAChF,MAAMa,EAAYJ,EAAiBR,CAAK,EAClCa,EAAYL,EAAiBT,EAAQ,IAAKO,GAAMA,EAAE,IAAI,CAAC,EAE7D,OAAOP,EAAQ,OAAQR,IAChBsB,EAAU,IAAItB,EAAM,IAAI,GAAK,IAAMqB,EAAU,IAAIrB,EAAM,IAAI,GAAK,IACnEF,EAAiBC,EAASC,CAAK,EAC/BsB,EAAU,IAAItB,EAAM,MAAOsB,EAAU,IAAItB,EAAM,IAAI,GAAK,GAAK,CAAC,EACvD,IAEF,EACR,CACH,CAWO,SAASuB,EACdd,EACAD,EACAgB,EAMAC,EACA,CACA,MAAMC,EAA2B,GAC3BC,EAAa,IAAI,IACvB,UAAWd,KAAQJ,EAKjB,GAJAkB,EAAW,IAAId,GAAOc,EAAW,IAAId,CAAI,GAAK,GAAK,CAAC,EAElDL,EAAQ,OAAQO,GAAMA,EAAE,OAASF,CAAI,EAAE,OACvCa,EAAa,OAAQX,GAAMA,EAAE,OAASF,CAAI,EAAE,QAChCc,EAAW,IAAId,CAAI,GAAK,GAAI,CACxC,MAAMe,EAAa5D,EAAM,EAAE,EACrBoC,EAAQP,EAAQ2B,EAASX,EAAMe,CAAU,CAAC,EAChDF,EAAa,KAAK,CAChB,GAAID,IACJ,KAAAZ,EACA,MAAAT,EACA,MAAOwB,CACT,CAAC,CACH,CAGF,OAAOF,CACT,CC1GO,SAASG,EAAQpB,EAAY,CAClC,MAAO,CACL,KAAOe,GAGEM,EACJC,GAAuB,CACtB,KAAM,CACJ,MAAOC,EACP,SAAU,CAACR,CAAQ,CACrB,EAAIO,EAEExB,EAAY,SAAS,eAAe,EAAE,EAE5C,IAAIC,EAAsB,GAC1B,MAAMiB,EAAY,EAElB,SAASQ,EAAUlC,EAAeU,EAAY,CAE5CD,EAAUY,EAAerB,EAASU,EAAOD,CAAO,EAEhDA,EAAQ,KAAK,GAAGe,EAAWd,EAAOD,EAASgB,EAAUC,CAAS,CAAC,EAE/DnB,EAAeC,EAAWR,EAASS,EAASC,CAAK,CACnD,CAEA,OAAA9C,EAAQ,IAAM,CACZM,EAAO,IAAM,CACX,MAAM8B,EAAUQ,EAAU,WAC1B,GAAKR,EAEL,GAAI,CACF,MAAMmB,EAAOc,EAAK,EAClB,GAAI,CAACd,EAAM,OAEXe,EAAUlC,EAAS,CAAC,GAAGmB,CAAI,CAAC,CAC9B,OAASgB,EAAgB,CACvB,GAAIA,aAA0B,QAC5BC,EAAgB,MAAQD,MAExB,OAAMA,CAEV,CACF,CAAC,CACH,CAAC,EAED1E,EAAU,IAAM,CACd,UAAWwC,KAASQ,EAClBV,EAAiBS,EAAU,WAAaP,CAAK,CAEjD,CAAC,EAEDoC,EAAmB,IAAI7B,CAAS,EACzBA,CACT,EACA,CACE,MAAO,IAAME,EACb,SAAAe,CACF,CACF,CAEJ,CACF,CC/EO,SAASa,EAAOC,EAAgB,CACrC,MAAMC,EAAY,CAChB,GAAGD,EAAO,OAAQE,GAAU,EAAEA,aAAiB,MAAQJ,EAAmB,IAAII,CAAK,EAAE,CACvF,EAEA,OAAOD,EAAU,SAAW,EAAIA,EAAU,CAAC,EAAIA,CACjD,CCRO,SAASE,EAAQhF,EAAa,CACnC,IAAIiF,EACAC,EAAW,GAEf,MAAO,KACDA,IACFD,EAAejF,EACfkF,EAAAA,EAAW,IAEND,EAEX,CCXgB,SAAAE,EAAUtD,EAAwB,CAChD,SAASuD,EAAW9D,EAAe,CAGjC,GAFIA,IAAQ,MAAQ,OAAOA,GAAQ,UAE/B,OAAOA,GAAQ,WAAY,OAAOA,EAEtC,MAAMhB,EAAc,GACpB,UAAWmB,KAAO,QAAQ,QAAQH,CAAG,EAAG,CACtC,MAAMO,EAAQP,EAAIG,CAAG,EACrBnB,EAAOmB,CAAG,EAAI2D,EAAWvD,CAAK,CAChC,CACA,OAAOvB,CACT,CAEA,OAAO8E,EAAWvD,CAAK,CACzB"}