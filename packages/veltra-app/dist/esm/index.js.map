{"version":3,"file":"index.js","sources":["../../src/runtime/state/track.ts","../../src/runtime/state/state.ts","../../src/runtime/state/computed.ts","../../src/runtime/state/untrack.ts","../../src/runtime/render/create-root.ts","../../src/util/loop.ts","../../src/util/memo.ts","../../src/util/clean-log.ts"],"sourcesContent":["import { activeEffect, EffectFn } from \"./effect\";\n\n// WeakMap to track which targets/keys map to which effects\nconst targetToPropertyEffectsMap: WeakMap<\n  object,\n  Map<PropertyKey, Set<EffectFn>>\n> = new WeakMap();\n\nexport function track(target: object, key: PropertyKey) {\n  if (!activeEffect) return; // No effect is currently running\n\n  let propertyEffectsMap = targetToPropertyEffectsMap.get(target);\n  if (!propertyEffectsMap) {\n    propertyEffectsMap = new Map();\n    targetToPropertyEffectsMap.set(target, propertyEffectsMap);\n  }\n\n  let effects = propertyEffectsMap.get(key);\n  if (!effects) {\n    effects = new Set();\n    propertyEffectsMap.set(key, effects);\n  }\n\n  if (!effects.has(activeEffect)) {\n    effects.add(activeEffect);\n    // Record this dependency set for cleanup later\n    if (activeEffect.deps) {\n      activeEffect.deps.push(effects);\n    } else {\n      activeEffect.deps = [effects];\n    }\n  }\n}\n\nexport function trigger(target: object, key: PropertyKey) {\n  const propertyEffectsMap = targetToPropertyEffectsMap.get(target);\n  if (!propertyEffectsMap) return;\n\n  const effects = propertyEffectsMap.get(key);\n  if (!effects) return;\n\n  // Clone the effects set to avoid infinite loops if the effect triggers itself\n  const effectsToRun = new Set(effects);\n  for (const effect of effectsToRun) {\n    effect();\n  }\n}\n","import { track, trigger } from \"./track\";\n\nexport type State<T> = {\n  value: T;\n};\n\nexport function state<T>(initialValue: T): State<T>;\nexport function state<T = undefined>(): State<T | undefined>;\nexport function state<T>(initialValue?: T): State<T | undefined> {\n  const state = { value: initialValue };\n\n  return new Proxy(state, {\n    get(target, key, receiver) {\n      track(target, key);\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, newValue, receiver) {\n      const oldValue = target[key as keyof typeof target];\n      const result = Reflect.set(target, key, newValue, receiver);\n\n      const isArray = Array.isArray(newValue);\n      const isObject =\n        typeof newValue === \"object\" &&\n        !Array.isArray(newValue) &&\n        newValue !== null;\n      const isPrimitive =\n        typeof newValue !== \"object\" && typeof newValue !== \"function\";\n\n      const shouldTrigger =\n        isArray || isObject || (isPrimitive && oldValue !== newValue);\n\n      if (shouldTrigger) {\n        trigger(target, key);\n      }\n\n      return result;\n    },\n  });\n}\n","import { state } from \"./state\"; // your Veltra's state()\nimport { effect } from \"./effect\";\n\nexport type Computed<T> = {\n  readonly value: T;\n};\n\nexport function computed<T>(getter: () => T): Computed<T> {\n  const result = state<T>(); // Real state that reactors and effects can track\n\n  effect(() => {\n    result.value = getter(); // when dependencies change, recompute and trigger .value\n  });\n\n  return {\n    get value() {\n      return result.value as T; // will track this as a true state()\n    },\n  };\n}\n","import { activeEffect, setActiveEffect } from \"./effect\";\n\nexport function untrack<T>(fn: () => T): T {\n  const prevEffect = activeEffect;\n  setActiveEffect(null); // disable tracking\n\n  try {\n    return fn();\n  } finally {\n    setActiveEffect(prevEffect); // restore previous tracking context\n  }\n}\n","import { toArray } from \"~/util\";\nimport { renderChildren } from \"./render-children\";\n\nexport function createRoot($root: HTMLElement, App: () => JSX.Element) {\n  renderChildren($root, toArray(App()));\n}\n","import { jsx } from \"~/jsx-runtime\";\nimport { onDestroy, onMount, runComponentCleanup } from \"~/runtime/life-cycle\";\nimport { componentRootNodes } from \"~/runtime/render\";\nimport { effect as reactor, State, state, untrack } from \"~/runtime/state\";\nimport { toArray } from \"~/util\";\n\ntype ForProps<T> = {\n  items: () => T[];\n  children: [(item: T, index: { value: number }) => JSX.Element];\n};\n\ntype Entry<T> = {\n  id: number;\n  item: T;\n  nodes: Node[];\n  index: { value: number };\n};\n\nexport function loop<T>(items: T[]) {\n  function For<T>(props: ForProps<T>) {\n    const {\n      items: each,\n      children: [children],\n    } = props;\n\n    const $rootNode = document.createTextNode(\"\");\n\n    let entries: Entry<T>[] = [];\n    let idCounter = 0;\n\n    function reconcile($parent: Node, items: T[]) {\n      const newCounts = countOccurrences(items);\n      const oldCounts = countOccurrences(entries.map((e) => e.item));\n\n      // Remove extra\n      entries = entries.filter((entry) => {\n        if (\n          (oldCounts.get(entry.item) ?? 0) > (newCounts.get(entry.item) ?? 0)\n        ) {\n          removeEntryNodes($parent, entry);\n          oldCounts.set(entry.item, (oldCounts.get(entry.item) ?? 0) - 1);\n          return false;\n        }\n        return true;\n      });\n\n      // Add new\n      const addedEntries: Entry<T>[] = [];\n      const seenCounts = new Map<T, number>();\n      for (const item of items) {\n        seenCounts.set(item, (seenCounts.get(item) || 0) + 1);\n        const exists =\n          entries.filter((e) => e.item === item).length +\n          addedEntries.filter((e) => e.item === item).length;\n        if (exists < (seenCounts.get(item) || 0)) {\n          const indexState = state(-1);\n          const nodes = toArray(children(item, indexState)) as Node[];\n          addedEntries.push({\n            id: idCounter++,\n            item,\n            nodes,\n            index: indexState,\n          });\n        }\n      }\n      entries.push(...addedEntries);\n\n      reorderEntries($rootNode, $parent, entries, items);\n    }\n\n    onMount(() => {\n      reactor(() => {\n        const $parent = $rootNode.parentNode;\n        if (!$parent) return;\n        reconcile($parent, [...each()]);\n      });\n    });\n\n    onDestroy(() => {\n      for (const entry of entries) {\n        removeEntryNodes($rootNode.parentNode!, entry);\n      }\n    });\n\n    componentRootNodes.add($rootNode);\n    return $rootNode;\n  }\n\n  return {\n    each: (children: (item: T, index: State<number>) => JSX.Element) => {\n      // Use jsx to register it as a component\n      // That way we can use life cycles hooks\n      return jsx(For, {\n        items: () => items,\n        children,\n      });\n    },\n  };\n}\n\n// Helpers\nfunction removeEntryNodes<T>($parent: Node, entry: Entry<T>) {\n  for (const node of entry.nodes) {\n    if ($parent.contains(node)) {\n      runComponentCleanup(node);\n      $parent.removeChild(node);\n    }\n  }\n}\n\nfunction insertNodes($parent: Node, nodes: Node[], referenceNode: Node | null) {\n  for (const node of nodes) {\n    $parent.insertBefore(node, referenceNode);\n  }\n}\n\nfunction reorderEntries<T>(\n  $rootNode: Node,\n  $parent: Node,\n  entries: Entry<T>[],\n  items: T[]\n) {\n  const placeCounts = new Map<T, number>();\n  let ref: Node | null = $rootNode.nextSibling;\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    placeCounts.set(item, (placeCounts.get(item) || 0) + 1);\n    let count = 0;\n    const entry = entries.find(\n      (e) => e.item === item && ++count === placeCounts.get(item)\n    );\n    if (!entry) continue;\n    untrack(() => (entry.index.value = i));\n    insertNodes($parent, entry.nodes, ref);\n    ref = entry.nodes[entry.nodes.length - 1].nextSibling;\n  }\n}\n\nfunction countOccurrences<T>(list: T[]) {\n  const counts = new Map<T, number>();\n  for (const item of list) counts.set(item, (counts.get(item) || 0) + 1);\n  return counts;\n}\n","export function memo<T>(fn: () => T) {\n  let cachedResult: T;\n  let firstRun = true;\n\n  return () => {\n    if (firstRun) {\n      cachedResult = fn();\n      firstRun = false;\n    }\n    return cachedResult;\n  };\n}\n","import { componentRootNodes } from \"~/runtime\";\n\nexport function cleanLog($nodes: Node[]) {\n  const $newNodes = [\n    ...$nodes.filter(\n      ($node) => !($node instanceof Text && componentRootNodes.has($node))\n    ),\n  ];\n\n  return $newNodes.length === 1 ? $newNodes[0] : $newNodes;\n}\n"],"names":["targetToPropertyEffectsMap","track","target","key","activeEffect","propertyEffectsMap","effects","trigger","effectsToRun","effect","state","initialValue","receiver","newValue","oldValue","result","isArray","isObject","computed","getter","untrack","fn","prevEffect","setActiveEffect","createRoot","$root","App","renderChildren","toArray","loop","items","For","props","each","children","$rootNode","entries","idCounter","reconcile","$parent","newCounts","countOccurrences","oldCounts","e","entry","removeEntryNodes","addedEntries","seenCounts","item","indexState","nodes","reorderEntries","onMount","reactor","onDestroy","componentRootNodes","jsx","node","runComponentCleanup","insertNodes","referenceNode","placeCounts","ref","i","count","list","counts","memo","cachedResult","firstRun","cleanLog","$nodes","$newNodes","$node"],"mappings":"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"}