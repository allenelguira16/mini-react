import{d as v,a as l,s as m,e as g,u as d,c as x,r as j,t as y,b as k,m as P,o as R,g as D}from"./chunks/ssr-CUZTpUeu.js";import{F as Q,S as U,f as V}from"./chunks/ssr-CUZTpUeu.js";function C(r){if(v)v.push(r);else throw new Error("onDestroy called outside of component")}const h=new WeakMap;function M(r,t){if(!l)return;let e=h.get(r);e||(e=new Map,h.set(r,e));let n=e.get(t);n||(n=new Set,e.set(t,n)),n.has(l)||(n.add(l),l.deps?l.deps.push(n):l.deps=[n])}function N(r,t){const e=h.get(r);if(!e)return;const n=e.get(t);if(!n)return;const s=new Set(n);for(const o of s)o()}function p(r){if(m){const{states:t,index:e}=m;if(t.length<=e){const n=S(r);t.push(n)}return t[m.index++]}return S(r)}function S(r){const t={value:r};return new Proxy(t,{get(e,n,s){return M(e,n),Reflect.get(e,n,s)},set(e,n,s,o){const c=e[n],u=Reflect.set(e,n,s,o);return c!==s&&N(e,n),u}})}function O(r){const t=p();return g(()=>{t.value=r()}),{get value(){return t.value}}}function F(r){let t=!0,e=null,n,s=null,o="pending";const c=p(0),u=async()=>{t=!0,e=null,n=void 0,o="pending",s=r(),s.then(i=>{n=i,e=null,o="fulfilled",t=!1,d(()=>c.value++)}).catch(i=>{n=void 0,e=i,o="rejected",t=!1,d(()=>c.value++)}),d(()=>c.value++)};return g(()=>{u()}),{get loading(){return c.value,t},get error(){return e},get data(){if(c.value,o==="pending")throw s;if(o==="rejected")throw e;return n},refetch:u,mutate(i){n=i,c.value++}}}const w=new WeakMap;function T(r){function t(e){if(w.has(e))return w.get(e);const n=new Proxy(e,{get(s,o,c){M(s,o);const u=Reflect.get(s,o,c);if(typeof u=="function")return u.bind(c);const i=Reflect.getOwnPropertyDescriptor(s,o);return i?.get?i.get.call(c):typeof u=="object"&&u!==null?t(u):u},set(s,o,c,u){const i=s[o],f=Reflect.set(s,o,c,u);return i!==c&&N(s,o),f}});return w.set(e,n),n}return t(r)}function W(r){const t=[...r.filter(e=>!(e instanceof Text&&x.has(e)))];return t.length===1?t[0]:t}function A(r){let t,e=!0;return()=>(e&&(t=r(),e=!1),t)}function B(r){function t(e){if(e===null||typeof e!="object"||typeof e=="function")return e;const n={};for(const s of Reflect.ownKeys(e)){const o=e[s];n[s]=t(o)}return n}return t(r)}function H(r,t){j(r,y(t()))}function b(r,t){for(const e of t.nodes)r.contains(e)&&(k(e),r.removeChild(e))}function J(r,t,e){for(const n of t)r.insertBefore(n,e)}function K(r,t,e,n){const s=new Map;let o=r.nextSibling;for(let c=0;c<n.length;c++){const u=n[c];s.set(u,(s.get(u)||0)+1);let i=0;const f=e.find(a=>a.item===u&&++i===s.get(u));f&&(d(()=>f.index.value=c),J(t,f.nodes,o),o=f.nodes[f.nodes.length-1].nextSibling)}}function E(r){const t=new Map;for(const e of r)t.set(e,(t.get(e)||0)+1);return t}function $(r,t,e){const n=E(t),s=E(e.map(o=>o.item));return e.filter(o=>(s.get(o.item)??0)>(n.get(o.item)??0)?(b(r,o),s.set(o.item,(s.get(o.item)??0)-1),!1):!0)}function q(r,t,e,n){const s=[],o=new Map;for(const c of r)if(o.set(c,(o.get(c)||0)+1),t.filter(u=>u.item===c).length+s.filter(u=>u.item===c).length<(o.get(c)||0)){const u=p(-1),i=y(e(c,u));s.push({id:n++,item:c,nodes:i,index:u})}return s}function z(r){const t=D();return{each:e=>{const n=r;return e=e,P(()=>{const s=document.createTextNode("");let o=[],c=0;function u(f,a){o=$(f,a,o),o.push(...q(a,o,e,c)),K(s,f,o,a)}const i=()=>{g(()=>{try{const f=s.parentNode;if(!f)return;const a=n();if(!a)return;u(f,[...a])}catch(f){if(f instanceof Promise)t(f);else throw f}})};return R(()=>{i()}),C(()=>{for(const f of o)b(s.parentNode,f)}),x.add(s),s},{})}}}export{Q as Fragment,U as Suspense,O as computed,H as createRoot,g as effect,W as logJsx,z as loop,A as memo,C as onDestroy,R as onMount,F as resource,p as state,V as stopEffect,T as store,d as untrack,B as unwrap};
//# sourceMappingURL=index.js.map
