import{d as v,a as l,s as h,e as g,u as d,c as y,r as k,t as x,b as P,m as D,o as E,g as O}from"./chunks/ssr-B1ejGqh5.js";import{F as U,S as V,f as X}from"./chunks/ssr-B1ejGqh5.js";function R(s){if(v)v.push(s);else throw new Error("onDestroy called outside of component")}const m=new WeakMap;function S(s,t){if(!l)return;let e=m.get(s);e||(e=new Map,m.set(s,e));let n=e.get(t);n||(n=new Set,e.set(t,n)),n.has(l)||(n.add(l),l.deps?l.deps.push(n):l.deps=[n])}function C(s,t){const e=m.get(s);if(!e)return;const n=e.get(t);if(!n)return;const r=new Set(n);for(const o of r)o()}function p(s){if(h){const{states:t,index:e}=h;if(t.length<=e){const n=M(s);t.push(n)}return t[h.index++]}return M(s)}function M(s){const t={value:s};return new Proxy(t,{get(e,n,r){return S(e,n),Reflect.get(e,n,r)},set(e,n,r,o){const c=e[n],u=Reflect.set(e,n,r,o);return c!==r&&C(e,n),u}})}function z(s){const t=p();return g(()=>{t.value=s()}),{get value(){return t.value}}}function F(s){let t=!0,e=null,n,r=null,o="pending";const c=p(0),u=async()=>{t=!0,e=null,n=void 0,o="pending",r=s(),r.then(i=>{n=i,e=null,o="fulfilled",t=!1,d(()=>c.value++)}).catch(i=>{n=void 0,e=i,o="rejected",t=!1,d(()=>c.value++)}),d(()=>c.value++)};return g(()=>{u()}),{get loading(){return c.value,t},get error(){return e},get data(){if(c.value,o==="pending")throw r;if(o==="rejected")throw e;return n},refetch:u,mutate(i){n=i,c.value++}}}const w=new WeakMap;function T(s){function t(e){if(w.has(e))return w.get(e);const n=new Proxy(e,{get(r,o,c){S(r,o);const u=Reflect.get(r,o,c);if(typeof u=="function")return u.bind(c);const i=Reflect.getOwnPropertyDescriptor(r,o);return i?.get?i.get.call(c):typeof u=="object"&&u!==null?t(u):u},set(r,o,c,u){const i=r[o],f=Reflect.set(r,o,c,u);return i!==c&&C(r,o),f}});return w.set(e,n),n}return t(s)}function W(s){const t=[...s.filter(e=>!(e instanceof Text&&y.has(e)))];return t.length===1?t[0]:t}function N(s){let t,e=!0;return()=>(e&&(t=s(),e=!1),t)}function $(s){function t(e){if(e===null||typeof e!="object"||typeof e=="function")return e;const n={};for(const r of Reflect.ownKeys(e)){const o=e[r];n[r]=t(o)}return n}return t(s)}function A(s,t){k(s,x(t()))}function B(s,t){let e,n,r=null;const o=t??"default",c=N(()=>{if(e)return e;throw n||(r||(r=s().then(u=>{if(!(o in u))throw new Error(`lazy(): Export "${String(o)}" not found in module`);e=u[o]}).catch(u=>{n=u})),r)});return()=>c}function b(s,t){for(const e of t.nodes)s.contains(e)&&(P(e),s.removeChild(e))}function H(s,t,e){for(const n of t)s.insertBefore(n,e)}function J(s,t,e,n){const r=new Map;let o=s.nextSibling;for(let c=0;c<n.length;c++){const u=n[c];r.set(u,(r.get(u)||0)+1);let i=0;const f=e.find(a=>a.item===u&&++i===r.get(u));f&&(d(()=>f.index.value=c),H(t,f.nodes,o),o=f.nodes[f.nodes.length-1].nextSibling)}}function j(s){const t=new Map;for(const e of s)t.set(e,(t.get(e)||0)+1);return t}function K(s,t,e){const n=j(t),r=j(e.map(o=>o.item));return e.filter(o=>(r.get(o.item)??0)>(n.get(o.item)??0)?(b(s,o),r.set(o.item,(r.get(o.item)??0)-1),!1):!0)}function q(s,t,e,n){const r=[],o=new Map;for(const c of s)if(o.set(c,(o.get(c)||0)+1),t.filter(u=>u.item===c).length+r.filter(u=>u.item===c).length<(o.get(c)||0)){const u=p(-1),i=x(e(c,u));r.push({id:n++,item:c,nodes:i,index:u})}return r}function G(s){const t=O();return{each:e=>{const n=s;return e=e,D(()=>{const r=document.createTextNode("");let o=[],c=0;function u(f,a){o=K(f,a,o),o.push(...q(a,o,e,c)),J(r,f,o,a)}const i=()=>{g(()=>{try{const f=r.parentNode;if(!f)return;const a=n();if(!a)return;u(f,[...a])}catch(f){if(f instanceof Promise)t&&t(f);else throw f}})};return E(()=>{i()}),R(()=>{for(const f of o)b(r.parentNode,f)}),y.add(r),r},{})}}}export{U as Fragment,V as Suspense,z as computed,A as createRoot,g as effect,B as lazy,W as logJsx,G as loop,N as memo,R as onDestroy,E as onMount,F as resource,p as state,X as stopEffect,T as store,d as untrack,$ as unwrap};
//# sourceMappingURL=index.js.map
