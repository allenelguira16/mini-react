{"version":3,"file":"index.js","sources":["../../src/life-cycle/on-mount.ts","../../src/life-cycle/on-destroy.ts","../../src/reactivity/store.ts","../../src/reactivity/computed.ts","../../src/reactivity/resource.ts","../../src/util/memo.ts","../../src/util/unwrap.ts","../../src/render/loop/util.ts","../../src/render/loop/loop.ts","../../src/render/create-root.ts","../../src/util/log-jsx.ts"],"sourcesContent":["import { mountContext } from \"~/context\";\n\nexport type MountFn = () => void | (() => void);\n\nexport function onMount(fn: () => () => void): void;\nexport function onMount(fn: () => void): void;\nexport function onMount(fn: MountFn): void {\n  if (mountContext) {\n    mountContext.push(fn);\n  } else {\n    throw new Error(\"onMount called outside of component\");\n  }\n}\n","import { destroyContext } from \"~/context\";\n\nexport type DestroyFn = () => void;\n\nexport function onDestroy(fn: () => void) {\n  if (destroyContext) {\n    destroyContext.push(fn);\n  } else {\n    throw new Error(\"onDestroy called outside of component\");\n  }\n}\n","import { track, trigger } from \"./track\";\n\nexport type Store<T extends object> = T;\n\nconst proxyMap = new WeakMap<object, any>();\n\nexport function store<T extends object>(initialObject: T): Store<T> {\n  function createReactiveObject(obj: T): T {\n    if (proxyMap.has(obj)) return proxyMap.get(obj);\n\n    const proxy = new Proxy(obj, {\n      get(target, key, receiver) {\n        // track every property access\n        track(target, key);\n\n        const result = Reflect.get(target, key, receiver);\n\n        // Auto-bind methods to the Proxy itself to avoid 'this' becoming DOM or global\n        if (typeof result === \"function\") {\n          return result.bind(receiver);\n        }\n\n        // Handle getters (derived properties)\n        const descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n        if (descriptor?.get) {\n          return descriptor.get.call(receiver);\n        }\n\n        // Deep reactivity, but avoid DOM Nodes\n        if (\n          typeof result === \"object\" &&\n          result !== null &&\n          !(result instanceof Node)\n        ) {\n          return createReactiveObject(result as any);\n        }\n\n        return result;\n      },\n\n      set(target, key, value, receiver) {\n        const oldValue = target[key as keyof T];\n        const result = Reflect.set(target, key, value, receiver);\n\n        if (oldValue !== value) {\n          trigger(target, key);\n        }\n\n        return result;\n      },\n    });\n\n    proxyMap.set(obj, proxy);\n    return proxy;\n  }\n\n  return createReactiveObject(initialObject);\n}\n","import { state } from \"./state\"; // your Veltra's state()\nimport { effect } from \"./effect\";\n\nexport type Computed<T> = {\n  readonly value: T;\n};\n\nexport function computed<T>(getter: () => T): Computed<T> {\n  const result = state<T>(); // Real state that reactors and effects can track\n\n  effect(() => {\n    result.value = getter(); // when dependencies change, recompute and trigger .value\n  });\n\n  return {\n    get value() {\n      return result.value as T; // will track this as a true state()\n    },\n  };\n}\n","import { effect, store } from \"~/reactivity\";\n\nexport function resource<T>(fetcher: () => Promise<T>) {\n  const data = store({\n    loading: true,\n    error: null as any,\n    data: undefined as T,\n  });\n\n  let realPromise: Promise<void> | null = null;\n\n  const refetch = () => {\n    data.loading = true;\n\n    realPromise = new Promise<void>((resolve, reject) => {\n      fetcher()\n        .then((result) => {\n          data.data = result;\n          data.loading = false;\n          data.error = null;\n          resolve();\n        })\n        .catch((err) => {\n          data.error = err;\n          data.loading = false;\n          reject(err);\n        });\n    });\n\n    return realPromise;\n  };\n\n  effect(() => {\n    refetch();\n  });\n\n  return {\n    get loading() {\n      return data.loading;\n    },\n    get error() {\n      return data.error;\n    },\n    get data() {\n      if (data.loading) throw realPromise;\n      if (!data.loading && data.error) throw data.error;\n      return data.data;\n    },\n    refetch,\n    mutate(newValue: T) {\n      data.data = newValue;\n    },\n  };\n}\n","/**\n * memoize a function\n *\n * @param fn - The function to memoize.\n * @returns The memoized function.\n */\nexport function memo<T>(fn: () => T) {\n  let cachedResult: T;\n  let firstRun = true;\n\n  return () => {\n    if (firstRun) {\n      cachedResult = fn();\n      firstRun = false;\n    }\n    return cachedResult;\n  };\n}\n","/**\n * unwraps proxy objects\n *\n * @param value - The value to unwrap.\n * @returns The unwrapped value.\n */\nexport function unwrap<T>(value: any): Partial<T> {\n  function deepUnwrap(obj: any): any {\n    if (obj === null || typeof obj !== \"object\") return obj;\n\n    if (typeof obj === \"function\") return obj;\n\n    const result: any = {};\n    for (const key of Reflect.ownKeys(obj)) {\n      const value = obj[key];\n      result[key] = deepUnwrap(value);\n    }\n    return result;\n  }\n\n  return deepUnwrap(value);\n}\n","import { runComponentCleanup } from \"~/life-cycle\";\nimport { state, untrack } from \"~/reactivity\";\nimport { toArray } from \"~/util\";\nimport { Entry } from \"./index\";\n\n/**\n * remove the entry nodes\n *\n * @param $parent - The parent node.\n * @param entry - The entry to remove.\n */\nexport function removeEntryNodes<T>($parent: Node, entry: Entry<T>) {\n  for (const node of entry.nodes) {\n    if ($parent.contains(node)) {\n      runComponentCleanup(node);\n      $parent.removeChild(node);\n    }\n  }\n}\n\n/**\n * insert the nodes\n *\n * @param $parent - The parent node.\n * @param nodes - The nodes to insert.\n * @param referenceNode - The reference node.\n */\nexport function insertNodes($parent: Node, nodes: Node[], referenceNode: Node | null) {\n  for (const node of nodes) {\n    $parent.insertBefore(node, referenceNode);\n  }\n}\n\n/**\n * reorder the entries\n *\n * @param $rootNode - The root node.\n * @param $parent - The parent node.\n * @param entries - The entries to reorder.\n * @param items - The items to reorder.\n */\nexport function reorderEntries<T>($rootNode: Node, $parent: Node, entries: Entry<T>[], items: T[]) {\n  const placeCounts = new Map<T, number>();\n  let ref: Node | null = $rootNode.nextSibling;\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    placeCounts.set(item, (placeCounts.get(item) || 0) + 1);\n    let count = 0;\n    const entry = entries.find((e) => e.item === item && ++count === placeCounts.get(item));\n    if (!entry) continue;\n    untrack(() => (entry.index.value = i));\n    insertNodes($parent, entry.nodes, ref);\n    ref = entry.nodes[entry.nodes.length - 1].nextSibling;\n  }\n}\n\n/**\n * count the occurrences of an item in a list\n *\n * @param list - The list to count the occurrences of.\n * @returns The occurrences of the item in the list.\n */\nexport function countOccurrences<T>(list: T[]) {\n  const counts = new Map<T, number>();\n  for (const item of list) counts.set(item, (counts.get(item) || 0) + 1);\n  return counts;\n}\n\n/**\n * remove the old nodes\n *\n * @param $parent - The parent node.\n * @param items - The items to remove.\n * @param entries - The entries to remove.\n */\nexport function removeOldNodes<T>($parent: Node, items: T[], entries: Entry<T>[]) {\n  const newCounts = countOccurrences(items);\n  const oldCounts = countOccurrences(entries.map((e) => e.item));\n\n  return entries.filter((entry) => {\n    if ((oldCounts.get(entry.item) ?? 0) > (newCounts.get(entry.item) ?? 0)) {\n      removeEntryNodes($parent, entry);\n      oldCounts.set(entry.item, (oldCounts.get(entry.item) ?? 0) - 1);\n      return false;\n    }\n    return true;\n  });\n}\n\n/**\n * create new entries\n *\n * @param items - The items to create new entries for.\n * @param entries - The entries to create new entries for.\n * @param children - The children to create new entries for.\n * @param idCounter - The id counter.\n * @returns The new entries.\n */\nexport function newEntries<T>(\n  items: T[],\n  entries: Entry<T>[],\n  children: (\n    item: T,\n    index: {\n      value: number;\n    },\n  ) => JSX.Element,\n  idCounter: number,\n) {\n  const addedEntries: Entry<T>[] = [];\n  const seenCounts = new Map<T, number>();\n  for (const item of items) {\n    seenCounts.set(item, (seenCounts.get(item) || 0) + 1);\n    const exists =\n      entries.filter((e) => e.item === item).length +\n      addedEntries.filter((e) => e.item === item).length;\n    if (exists < (seenCounts.get(item) || 0)) {\n      const indexState = state(-1);\n      const nodes = toArray(children(item, indexState)) as Node[];\n      addedEntries.push({\n        id: idCounter++,\n        item,\n        nodes,\n        index: indexState,\n      });\n    }\n  }\n\n  return addedEntries;\n}\n","import { jsx } from \"~/jsx-runtime\";\nimport { onDestroy, onMount } from \"~/life-cycle\";\nimport { componentRootNodes, suspensePromise } from \"~/render\";\nimport { effect, State } from \"~/reactivity\";\nimport { newEntries, removeEntryNodes, removeOldNodes, reorderEntries } from \"./util\";\n\ntype ForProps<T> = {\n  items: () => T[];\n  children: [(item: T, index: { value: number }) => JSX.Element];\n};\n\nexport type Entry<T> = {\n  id: number;\n  item: T;\n  nodes: Node[];\n  index: { value: number };\n};\n\n/**\n * create a loop component\n *\n * @param items - The items to loop through.\n * @returns The loop component.\n */\nexport function loop<T>(items: T[]) {\n  return {\n    each: (children: (item: T, index: State<number>) => JSX.Element) => {\n      // Use jsx to register it as a component\n      // That way we can use life cycles hooks\n      return jsx(\n        (props: ForProps<T>) => {\n          const {\n            items: each,\n            children: [children],\n          } = props;\n\n          const $rootNode = document.createTextNode(\"\");\n\n          let entries: Entry<T>[] = [];\n          let idCounter = 0;\n\n          function reconcile($parent: Node, items: T[]) {\n            // Remove extra\n            entries = removeOldNodes($parent, items, entries);\n            // Add new\n            entries.push(...newEntries(items, entries, children, idCounter));\n\n            reorderEntries($rootNode, $parent, entries, items);\n          }\n\n          onMount(() => {\n            effect(() => {\n              const $parent = $rootNode.parentNode;\n              if (!$parent) return;\n\n              try {\n                const list = each();\n                if (!list) return;\n\n                reconcile($parent, [...list]);\n              } catch (errorOrPromise) {\n                if (errorOrPromise instanceof Promise) {\n                  suspensePromise.value = errorOrPromise;\n                } else {\n                  throw errorOrPromise;\n                }\n              }\n            });\n          });\n\n          onDestroy(() => {\n            for (const entry of entries) {\n              removeEntryNodes($rootNode.parentNode!, entry);\n            }\n          });\n\n          componentRootNodes.add($rootNode);\n          return $rootNode;\n        },\n        {\n          items: () => items,\n          children,\n        },\n      );\n    },\n  };\n}\n","import { toArray } from \"~/util\";\nimport { renderChildren } from \"./render-children\";\n\n/**\n * create a root element\n *\n * @param $root - The root element.\n * @param App - The app to render.\n */\nexport function createRoot($root: HTMLElement, App: () => JSX.Element) {\n  renderChildren($root, toArray(App()));\n}\n","import { componentRootNodes } from \"../render\";\n\n/**\n * log the JSX elements\n *\n * @param $nodes - The nodes to log.\n * @returns The nodes that are not text nodes and are not in the componentRootNodes set.\n */\nexport function logJsx($nodes: Node[]) {\n  const $newNodes = [\n    ...$nodes.filter(($node) => !($node instanceof Text && componentRootNodes.has($node))),\n  ];\n\n  return $newNodes.length === 1 ? $newNodes[0] : $newNodes;\n}\n"],"names":["mountContext","destroyContext","track","trigger","state","effect","value","runComponentCleanup","untrack","toArray","jsx","children","items","suspensePromise","componentRootNodes","renderChildren"],"mappings":"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"}