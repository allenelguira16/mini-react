{"version":3,"file":"run-lifecycle-DB1Kq-0l.js","sources":["../../../src/life-cycle/component-cleanup.ts","../../../src/context/destroy-context.ts","../../../src/context/effect-context.ts","../../../src/context/mount-context.ts","../../../src/context/state-context.ts","../../../src/life-cycle/create-lifecycle.ts","../../../src/life-cycle/on-mount.ts","../../../src/reactivity/effect.ts","../../../src/reactivity/untrack.ts","../../../src/util/is-node-nil.ts","../../../src/util/get-node.ts","../../../src/render/render-children/patch.ts","../../../src/render/mount-component/resolve-component-props.ts","../../../src/render/mount-component/mount-component.ts","../../../src/render/suspense.ts","../../../src/render/render-children/render-children.ts","../../../src/render/fragment.ts","../../../src/const/element-tags.ts","../../../src/const/unit-less-props.ts","../../../src/const/index.ts","../../../src/jsx-runtime.ts","../../../src/render/event-registry.ts","../../../src/render/apply-props.ts","../../../src/render/h.ts","../../../src/render/ssr.ts","../../../src/util/on-node-reattached.ts","../../../src/util/to-array.ts","../../../src/life-cycle/run-lifecycle.ts"],"sourcesContent":["const cleanupMap = new Map<Node, (() => void)[]>();\n\n/**\n * set the component cleanup\n *\n * @param node - The node.\n * @param cleanups - The cleanups.\n */\nexport function setComponentCleanup(node: Node, cleanups: (() => void)[]) {\n  cleanupMap.set(node, cleanups);\n}\n\n/**\n * run the component cleanup\n *\n * @param node - The node.\n */\nexport function runComponentCleanup(node: Node) {\n  const cleanups = cleanupMap.get(node) || [];\n  for (const cleanup of cleanups) {\n    cleanup();\n  }\n}\n","import { DestroyFn } from \"~/life-cycle\";\n\nexport let destroyContext: DestroyFn[] | null = null;\n\n/**\n * set the destroy context\n *\n * @param newDestroyContext - The destroy context.\n */\nexport function setDestroyContext(newDestroyContext: (() => void)[] | null) {\n  destroyContext = newDestroyContext;\n}\n","import { EffectFn } from \"~/reactivity\";\n\nexport let effectContext: EffectFn[] | null = null;\n\n/**\n * set the effect context\n *\n * @param newEffectContext - The effect context.\n */\nexport function setEffectContext(newEffectContext: EffectFn[] | null) {\n  effectContext = newEffectContext;\n}\n","import { MountFn } from \"~/life-cycle\";\n\nexport let mountContext: MountFn[] | null = null;\n\n/**\n * set the mount context\n *\n * @param newMountStack - The mount context.\n */\nexport function setMountContext(newMountStack: (() => void)[] | null) {\n  mountContext = newMountStack;\n}\n","import { State } from \"~/reactivity\";\n\nexport let stateContext: {\n  states: State<any>[];\n  index: number;\n} | null = null;\n\n/**\n * set the state context\n *\n * @param newStateContext - The state context.\n */\nexport function setStateContext(\n  newStateContext: {\n    states: State<any>[];\n    index: number;\n  } | null = null,\n) {\n  stateContext = newStateContext;\n}\n\nconst stateMap = new Map<any, Map<any, { states: any[] }>>();\n\n/**\n * create a state context\n *\n * @param type - The type of the state.\n * @param key - The key of the state.\n * @returns The state context.\n */\nexport const createStateContext = (\n  type: (props: Record<string, any>) => any,\n  key?: number | string,\n) => {\n  let instance: { states: any[] };\n\n  if (key !== undefined) {\n    if (!stateMap.has(type)) {\n      stateMap.set(type, new Map());\n    }\n    const typeMap = stateMap.get(type)!;\n    if (!typeMap.has(key)) {\n      typeMap.set(key, { states: [] });\n    }\n    instance = typeMap.get(key)!;\n  } else {\n    instance = { states: [] };\n  }\n\n  return { ...instance, index: 0 };\n};\n","import {\n  createStateContext,\n  setDestroyContext,\n  setEffectContext,\n  setMountContext,\n  setStateContext,\n} from \"~/context\";\n\nimport { LifecycleContext } from \"./run-lifecycle\";\n\nexport function createLifeCycleContext(\n  type: (props: Record<string, any>) => any,\n  key?: number | string,\n) {\n  const context: LifecycleContext = {\n    mount: [],\n    state: createStateContext(type, key),\n    effect: [],\n    destroy: [],\n  };\n\n  setMountContext(context.mount);\n  setStateContext(context.state);\n  setEffectContext(context.effect);\n  setDestroyContext(context.destroy);\n\n  return context;\n}\n","import { mountContext } from \"~/context\";\n\nexport type MountFn = () => void | (() => void);\n\n/**\n * on mount\n *\n * @param fn - The function to run on mount.\n */\nexport function onMount(fn: () => () => void): void;\nexport function onMount(fn: () => void): void;\nexport function onMount(fn: MountFn): void {\n  if (mountContext) {\n    mountContext.push(fn);\n  } else {\n    throw new Error(\"onMount called outside of component\");\n  }\n}\n","import { effectContext } from \"~/context\";\n\n/**\n * Effect function type with dependency tracking\n *\n * @param deps - The dependencies of the effect.\n */\nexport type EffectFn = (() => void) & { deps?: Set<EffectFn>[] };\n\n/**\n * Currently active effect\n */\nexport let activeEffect: EffectFn | null = null;\n\nexport function setActiveEffect(newActiveEffect: EffectFn | null) {\n  activeEffect = newActiveEffect;\n}\n\nlet lastDisposer: (() => void) | null = null;\n\n/**\n * Create an effect\n *\n * @param fn - The effect function.\n * @returns The cleanup function.\n */\nexport function effect(fn: () => void): () => void {\n  const wrappedEffect: EffectFn = () => {\n    removeEffect(wrappedEffect);\n    const previousEffect = activeEffect;\n    activeEffect = wrappedEffect;\n\n    if (effectContext) effectContext.push(wrappedEffect);\n\n    try {\n      fn();\n    } finally {\n      activeEffect = previousEffect;\n    }\n  };\n\n  wrappedEffect.deps = [];\n  wrappedEffect();\n\n  const disposer = () => removeEffect(wrappedEffect);\n  lastDisposer = disposer; // âœ… track disposer for stopEffect\n\n  return disposer;\n}\n\nexport function stopEffect() {\n  queueMicrotask(() => {\n    if (lastDisposer) {\n      lastDisposer();\n      lastDisposer = null;\n    }\n  });\n}\n\n/**\n * Remove an effect\n *\n * @param effect - The effect to remove.\n */\nexport function removeEffect(effect: EffectFn) {\n  if (effect.deps) {\n    for (const depSet of effect.deps) {\n      depSet.delete(effect); // Remove this effect from all dependency sets\n    }\n    effect.deps.length = 0; // Reset dependency list\n  }\n}\n","import { activeEffect, setActiveEffect } from \"./effect\";\n\n/**\n * Unwrap a reactive value\n *\n * @param fn - The function that returns the reactive value.\n * @returns The reactive value.\n */\nexport function untrack<T>(fn: () => T): T {\n  const prevEffect = activeEffect;\n  setActiveEffect(null); // disable tracking\n\n  try {\n    return fn();\n  } finally {\n    setActiveEffect(prevEffect); // restore previous tracking context\n  }\n}\n","/**\n * check if a value is null, undefined, or false\n *\n * @param value - The value to check if it is null, undefined, or false.\n * @returns True if the value is null, undefined, or false.\n */\nexport const isNil = (value: unknown): value is null | undefined | false => {\n  return value === undefined || value === null || value === false;\n};\n","import { isNil } from \"./is-node-nil\";\n\n/**\n * get the node for a JSX element\n *\n * @param jsxElement - The JSX element to get the node for.\n * @returns The node for the JSX element.\n */\nexport function getNode(jsxElement: JSX.Element): undefined | Node | (Node | undefined)[] {\n  if (jsxElement instanceof Node) {\n    return jsxElement;\n  }\n\n  if (isNil(jsxElement)) {\n    return undefined;\n  }\n\n  if (typeof jsxElement === \"function\") {\n    return getNode(jsxElement());\n  }\n\n  if (Array.isArray(jsxElement)) {\n    return jsxElement.map(getNode) as (Node | undefined)[];\n  }\n\n  return document.createTextNode(String(jsxElement));\n}\n","import { runComponentCleanup } from \"~/life-cycle\";\nimport { isNil } from \"~/util\";\n\n/**\n * patch the old nodes with the new nodes\n *\n * @param parentNode - The parent node.\n * @param oldNodes - The old nodes.\n * @param newNodes - The new nodes.\n */\nexport function patch(\n  parentNode: Node,\n  oldNodes: (ChildNode | undefined)[],\n  newNodes: (ChildNode | undefined)[],\n  insertBeforeNode?: Node,\n) {\n  const maxLength = Math.max(oldNodes.length, newNodes.length);\n\n  for (let i = 0; i < maxLength; i++) {\n    const oldNode = oldNodes[i];\n    const newNode = newNodes[i];\n\n    // Add new node\n    if (isNil(oldNode) && !isNil(newNode)) {\n      if (insertBeforeNode) {\n        parentNode.insertBefore(newNode, insertBeforeNode);\n      } else {\n        parentNode.appendChild(newNode);\n      }\n      oldNodes[i] = newNode;\n      continue;\n    }\n\n    // Remove old node\n    if (!isNil(oldNode) && isNil(newNode)) {\n      runComponentCleanup(oldNode);\n      parentNode.removeChild(oldNode);\n      oldNodes[i] = undefined;\n      continue;\n    }\n\n    // If both empty, continue to next iteration\n    if (isNil(oldNode) && isNil(newNode)) {\n      continue;\n    }\n\n    if (oldNode && newNode) {\n      runComponentCleanup(oldNode);\n      oldNode.replaceWith(newNode);\n      oldNodes[i] = newNode;\n      continue;\n    }\n\n    console.warn(`[veltra]: warning - unknown dom detected: `, {\n      old: oldNode,\n      new: newNode,\n    });\n  }\n\n  return [...oldNodes];\n}\n","import { Suspense } from \"../suspense\";\n\nconst IGNORE_COMPONENT = [Suspense] as Array<(...args: any[]) => any>;\n\n/**\n * resolve the component props\n *\n * @param type - The type of the component.\n * @param props - The properties of the component.\n */\nexport function resolveComponentProps(type: (...args: any[]) => any, props: Record<string, any>) {\n  if (IGNORE_COMPONENT.includes(type)) return;\n\n  for (const key in props) {\n    props[key] = props[key] instanceof Function ? props[key]() : props[key];\n  }\n}\n","import { createLifeCycleContext, runLifecycle } from \"~/life-cycle\";\nimport { untrack } from \"~/reactivity\";\nimport { toArray } from \"~/util\";\n\nimport { resolveComponentProps } from \"./resolve-component-props\";\n\nexport const componentRootNodes = new Set<Node>();\n\n/**\n * mount a component\n *\n * @param type - The type of the component.\n * @param props - The properties of the component.\n * @param children - The children of the component.\n */\nexport function mountComponent(\n  type: (props: Record<string, any>) => any,\n  { key: _key, ...props }: { key?: () => string } & Record<string, any>,\n  children: JSX.Element[],\n) {\n  const key = _key?.();\n\n  resolveComponentProps(type, props);\n\n  const context = createLifeCycleContext(type, key);\n\n  const targetNode = document.createTextNode(\"\");\n  const node = toArray(untrack(() => type({ ...props, children })));\n\n  runLifecycle(context, targetNode);\n\n  node.unshift(targetNode);\n  componentRootNodes.add(targetNode);\n\n  return node;\n}\n","import { onMount } from \"~/life-cycle\";\n\nimport { componentRootNodes } from \"./mount-component\";\nimport { renderChildren } from \"./render-children\";\n\nconst suspenseHandlerList: ((promise: Promise<void>) => void)[] = [];\n\nexport function Suspense(props: { fallback?: JSX.Element; children: JSX.Element }) {\n  const rootNode = document.createTextNode(\"\"); // anchor\n  componentRootNodes.add(rootNode);\n\n  const {\n    fallback,\n    children: [children],\n  } = props as unknown as {\n    fallback?: () => JSX.Element;\n    children: [() => JSX.Element[]];\n  };\n\n  onMount(() => {\n    const parentNode = rootNode.parentNode!;\n\n    if (!parentNode) return;\n\n    const cleanups: (() => void)[] = [];\n\n    const handler = (promise: Promise<void>) => {\n      queueMicrotask(() => {\n        cleanups.forEach((cleanup) => cleanup());\n\n        if (fallback) {\n          cleanups.push(renderChildren(parentNode, [fallback], rootNode));\n        }\n      });\n\n      promise.then(() => {\n        cleanups.forEach((cleanup) => cleanup());\n        suspenseHandlerList.push(handler);\n        cleanups.push(renderChildren(parentNode, [children], rootNode));\n        suspenseHandlerList.pop();\n      });\n    };\n\n    suspenseHandlerList.push(handler);\n    cleanups.push(renderChildren(parentNode, [children], rootNode));\n    suspenseHandlerList.pop();\n  });\n\n  return rootNode;\n}\n\n// function reset(root: ParentNode, keepElement: Node) {\n//   console.log(root.childNodes);\n//   for (const child of Array.from(root.childNodes)) {\n//     if (child.contains(keepElement)) {\n//       reset(child as unknown as ParentNode, keepElement);\n//     } else {\n//       child.remove();\n//     }\n//   }\n// }\n\nexport function getCurrentSuspenseHandler() {\n  return suspenseHandlerList[suspenseHandlerList.length - 1];\n}\n","import { effect } from \"~/reactivity\";\nimport { getNode, toArray } from \"~/util\";\n\nimport { getCurrentSuspenseHandler } from \"../suspense\";\nimport { patch } from \"./patch\";\n\n/**\n * render the children\n *\n * @param parentNode - The parent node.\n * @param children - The children to render.\n */\nexport function renderChildren(\n  parentNode: Node,\n  children: JSX.Element[],\n  anchor: Node = document.createTextNode(\"\"),\n) {\n  if (!parentNode.contains(anchor)) {\n    parentNode.appendChild(anchor);\n  }\n\n  const cleanupDomNodes: (() => void)[] = [];\n\n  for (const child of children) {\n    let oldNodes: (ChildNode | undefined)[] = [];\n    const handler = getCurrentSuspenseHandler();\n\n    const disposer = effect(() => {\n      let result: JSX.Element;\n      let newNodes: (ChildNode | undefined)[] = [];\n\n      try {\n        result = typeof child === \"function\" ? child() : child;\n        newNodes = toArray(getNode(result)) as ChildNode[];\n      } catch (error) {\n        if (error instanceof Promise) {\n          if (handler) {\n            queueMicrotask(() => {\n              disposer();\n            });\n            handler(error);\n          }\n        } else {\n          throw error;\n        }\n      } finally {\n        oldNodes = patch(parentNode, oldNodes, newNodes, anchor);\n\n        cleanupDomNodes.push(() => {\n          patch(parentNode, oldNodes, [], anchor);\n        });\n      }\n    });\n\n    cleanupDomNodes.push(() => {\n      disposer();\n    });\n  }\n\n  return () => {\n    cleanupDomNodes.forEach((cleanup) => cleanup());\n  };\n}\n","/**\n * Create a fragment\n *\n * @param children - The children of the fragment.\n * @returns The fragment.\n */\nexport function Fragment({ children }: { children: JSX.Element[] }) {\n  return children;\n}\n","export const SVG_TAGS = new Set([\n  \"a\",\n  \"animate\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"defs\",\n  \"desc\",\n  \"discard\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"foreignObject\",\n  \"g\",\n  \"hatch\",\n  \"hatchpath\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"mesh\",\n  \"meshgradient\",\n  \"meshpatch\",\n  \"meshrow\",\n  \"metadata\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"script\",\n  \"set\",\n  \"solidcolor\",\n  \"stop\",\n  \"style\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"title\",\n  \"tref\",\n  \"tspan\",\n  \"unknown\",\n  \"use\",\n  \"view\",\n]);\n\nexport const MATH_ML_TAGS = new Set([\n  \"math\",\n  \"maction\",\n  \"maligngroup\",\n  \"malignmark\",\n  \"menclose\",\n  \"merror\",\n  \"mfenced\",\n  \"mfrac\",\n  \"mglyph\",\n  \"mi\",\n  \"mlabeledtr\",\n  \"mmultiscripts\",\n  \"mn\",\n  \"mo\",\n  \"mover\",\n  \"mpadded\",\n  \"mphantom\",\n  \"mroot\",\n  \"mrow\",\n  \"ms\",\n  \"mscarries\",\n  \"mscarry\",\n  \"msgroup\",\n  \"mstack\",\n  \"mstyle\",\n  \"msub\",\n  \"msubsup\",\n  \"msup\",\n  \"mtable\",\n  \"mtd\",\n  \"mtext\",\n  \"mtr\",\n  \"munder\",\n  \"munderover\",\n  \"semantics\",\n  \"annotation\",\n  \"annotation-xml\",\n]);\n","export const UNIT_LESS_PROPS = [\n  \"animationIterationCount\",\n  \"borderImageOutset\",\n  \"borderImageSlice\",\n  \"borderImageWidth\",\n  \"boxFlex\",\n  \"boxFlexGroup\",\n  \"boxOrdinalGroup\",\n  \"columnCount\",\n  \"flex\",\n  \"flexGrow\",\n  \"flexPositive\",\n  \"flexShrink\",\n  \"flexNegative\",\n  \"flexOrder\",\n  \"gridRow\",\n  \"gridColumn\",\n  \"fontWeight\",\n  \"lineClamp\",\n  \"lineHeight\",\n  \"opacity\",\n  \"order\",\n  \"orphans\",\n  \"tabSize\",\n  \"widows\",\n  \"zIndex\",\n  \"zoom\",\n  \"fillOpacity\",\n  \"floodOpacity\",\n  \"stopOpacity\",\n  \"strokeDasharray\",\n  \"strokeDashoffset\",\n  \"strokeMiterlimit\",\n  \"strokeOpacity\",\n  \"strokeWidth\",\n];\n","export * from \"./element-tags\";\nexport * from \"./unit-less-props\";\nexport const IS_SSR = typeof document === \"undefined\";\n","import { IS_SSR } from \"./const\";\nimport { Fragment, h, hSSR } from \"./render\";\nimport { toArray } from \"./util\";\n\n/**\n * jsx runtime\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element.\n */\nconst jsx = (\n  type: string | ((props: any) => any),\n  { children = [], ...props }: Record<string, any>,\n  key?: () => string,\n) => {\n  if (IS_SSR) {\n    return hSSR(type, props, toArray(children));\n  }\n\n  return h(type, props, toArray(children), key);\n};\n\nexport { Fragment, jsx, jsx as jsxs };\n","type EventHandlerMap = Map<string, EventListener>;\n\nconst eventRegistry = new WeakMap<HTMLElement, EventHandlerMap>();\n\n/**\n * Add an event listener\n *\n * @param element - The element to add the event listener to.\n * @param type - The type of event to listen for.\n * @param listener - The event listener function.\n */\nexport function addEventListener(element: HTMLElement, type: string, listener: EventListener) {\n  let handlers = eventRegistry.get(element);\n\n  if (!handlers) {\n    handlers = new Map();\n    eventRegistry.set(element, handlers);\n  }\n\n  // Remove old listener if any\n  if (handlers.has(type)) {\n    element.removeEventListener(type, handlers.get(type)!);\n  }\n\n  element.addEventListener(type, listener);\n  handlers.set(type, listener);\n}\n\n/**\n * Remove an event listener\n *\n * @param element - The element to remove the event listener from.\n * @param type - The type of event to remove.\n */\nexport function removeEventListener(element: HTMLElement, type: string) {\n  const handlers = eventRegistry.get(element);\n  if (!handlers) return;\n\n  const listener = handlers.get(type);\n  if (listener) {\n    element.removeEventListener(type, listener);\n    handlers.delete(type); // Remove it from the map\n  }\n\n  // Clean up if no handlers left\n  if (handlers.size === 0) {\n    eventRegistry.delete(element);\n  }\n}\n\n/**\n * Copy event listeners from one element to another\n *\n * @param from - The element to copy the event listeners from.\n * @param to - The element to copy the event listeners to.\n */\nexport function copyEventListeners(from: HTMLElement, to: HTMLElement) {\n  const handlers = eventRegistry.get(from);\n  if (!handlers) return;\n\n  handlers.forEach((listener, type) => {\n    removeEventListener(to, type);\n    addEventListener(to, type, listener);\n  });\n}\n\n/**\n * Remove all event listeners from an element\n *\n * @param element - The element to remove the event listeners from.\n */\nexport function removeEventListeners(element: HTMLElement) {\n  const handlers = eventRegistry.get(element);\n  if (!handlers) return;\n\n  handlers.forEach((listener, type) => {\n    element.removeEventListener(type, listener);\n  });\n\n  eventRegistry.delete(element);\n}\n","import { UNIT_LESS_PROPS } from \"~/const\";\n\nimport { effect } from \"../reactivity\";\nimport { addEventListener, removeEventListener } from \"./event-registry\";\n\n/**\n * apply the properties to the element\n *\n * @param element - The element to apply the properties to.\n * @param props - The properties to apply.\n */\nexport function applyProps(element: HTMLElement, props: Record<string, any>) {\n  for (const key in props) {\n    if (key.startsWith(\"on\") && typeof props[key] === \"function\") {\n      const type = key.slice(2).toLowerCase();\n      let cleanup: () => void;\n\n      effect(() => {\n        // Remove the previous listener if there was one\n        if (cleanup) cleanup();\n\n        const fn = props[key]();\n        if (typeof fn === \"function\") {\n          addEventListener(element, type, fn);\n          // Setup cleanup for next effect run\n          cleanup = () => removeEventListener(element, type);\n        }\n      });\n    } else {\n      const run = () => {\n        const value = typeof props[key] === \"function\" ? props[key]() : props[key];\n\n        if (key === \"ref\" && typeof value === \"function\") {\n          value(element);\n        } else if (key === \"style\") {\n          applyStyle(element, value);\n        } else if (key === \"disabled\") {\n          element.toggleAttribute(key, value);\n        } else {\n          element.setAttribute(key, value);\n        }\n      };\n      effect(() => {\n        try {\n          run();\n        } catch (error) {\n          if (error instanceof Promise) {\n            error.then(run);\n          } else {\n            throw error;\n          }\n        }\n      });\n    }\n  }\n}\n\n/**\n * apply the style to the element\n *\n * @param element - The element to apply the style to.\n * @param style - The style to apply.\n */\nfunction applyStyle(element: HTMLElement, style: Record<string, any>) {\n  if (!(element instanceof HTMLElement)) return;\n\n  for (const [key, value] of Object.entries(style)) {\n    const cssKey = key as keyof CSSStyleDeclaration;\n    if (cssKey === \"length\" || cssKey === \"parentRule\") continue;\n\n    const isNumber = typeof value === \"number\";\n    const needsUnit = isNumber && !isUnitLessCSSProperty(key);\n    const finalValue = needsUnit ? `${value}px` : String(value);\n\n    element.style.setProperty(String(cssKey), finalValue);\n  }\n}\n\n/**\n * check if a property is a unit less CSS property\n *\n * @param prop - The property to check.\n * @returns True if the property is a unit less CSS property.\n */\nfunction isUnitLessCSSProperty(prop: string): boolean {\n  const unitLessProps = new Set(UNIT_LESS_PROPS);\n\n  return unitLessProps.has(prop);\n}\n","import { MATH_ML_TAGS, SVG_TAGS } from \"~/const\";\nimport { Fragment } from \"~/jsx-runtime\";\n\nimport { applyProps } from \"./apply-props\";\nimport { mountComponent } from \"./mount-component\";\nimport { renderChildren } from \"./render-children\";\n\n/**\n * create a JSX element\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element.\n */\nexport function h(\n  type: string | ((props: Record<string, any>) => any),\n  props: Record<string, any>,\n  children: JSX.Element[],\n  key?: () => string,\n) {\n  if (type === Fragment) {\n    return children;\n  }\n\n  if (typeof type === \"function\") {\n    return mountComponent(type, { key, ...props }, children);\n  }\n\n  const element = createElement(type, props.xmlns);\n\n  applyProps(element, props);\n  renderChildren(element, children);\n\n  return element;\n}\n\nfunction createElement(tag: string, namespace?: string) {\n  if ((SVG_TAGS.has(tag) || MATH_ML_TAGS.has(tag)) && namespace) {\n    return document.createElementNS(namespace, tag) as HTMLElement;\n  }\n\n  return document.createElement(tag);\n}\n","/**\n * Create a JSX element for SSR\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element for SSR.\n */\nexport function hSSR(\n  type: string | ((props: Record<string, any>) => any),\n  props: Record<string, any>,\n  children: JSX.Element[],\n) {\n  if (typeof type === \"function\") {\n    return type({ ...props, children });\n  }\n\n  return `<${type} ${handlePropsSSR(props)}>${handleChildrenSSR(children)}</${type}>`;\n}\n\n/**\n * Handle the properties of the element for SSR\n *\n * @param props - The properties of the element.\n * @returns The transformed properties.\n */\nfunction handlePropsSSR(props: Record<string, any>) {\n  const transformedProps: string[] = [];\n\n  for (const key in props) {\n    if (key.startsWith(\"on\") && typeof props[key] === \"function\") {\n      continue;\n    }\n\n    const value = typeof props[key] === \"function\" ? props[key]() : props[key];\n\n    if (key === \"ref\" && typeof value === \"function\") {\n      // value($element);\n    } else if (key === \"style\") {\n      // applyStyle($element, value);\n    } else if (key === \"disabled\" && value) {\n      transformedProps.push(\"disabled\");\n    } else {\n      transformedProps.push(`${key}=\"${value}\"`);\n    }\n  }\n\n  return transformedProps.join(\" \");\n}\n\n/**\n * Handle the children of the element for SSR\n *\n * @param children - The children of the element.\n * @returns The transformed children.\n */\nfunction handleChildrenSSR(children: JSX.Element[]) {\n  const transformedChildren: string[] = [];\n\n  for (const child of children) {\n    if (typeof child === \"function\") {\n      transformedChildren.push(String(child()));\n    } else if (Array.isArray(child)) {\n      // RECURSIVELY flatten nested arrays\n      child.forEach((nested) => transformedChildren.push(handleChildrenSSR([nested])));\n    } else {\n      transformedChildren.push(child as string);\n    }\n  }\n\n  return transformedChildren.join(\"\");\n}\n","/**\n * observe a node and call a callback when it is reattached\n *\n * @param callback - The callback to call when the node is reattached.\n * @param targetNode - The node to observe.\n */\nexport function onNodeReattached(callback: () => void, targetNode: Node) {\n  // Create a MutationObserver instance\n  const observer = new MutationObserver((mutationsList) => {\n    for (const mutation of mutationsList) {\n      // Check for added nodes\n      for (const node of mutation.addedNodes) {\n        if (node === targetNode) {\n          callback();\n          break;\n        }\n      }\n    }\n  });\n\n  queueMicrotask(() => {\n    if (!targetNode.parentNode) {\n      return;\n    }\n\n    observer.observe(targetNode.parentNode, { childList: true, subtree: true });\n  });\n\n  return () => {\n    observer.disconnect();\n  };\n}\n","/**\n * convert an item to an array\n *\n * @param item - The item to convert to an array.\n * @returns The item as an array.\n */\nexport const toArray = <T>(item: T) => {\n  return (Array.isArray(item) ? item : [item]).flat(Infinity) as T[];\n};\n","import { setDestroyContext, setEffectContext, setMountContext, setStateContext } from \"~/context\";\nimport { EffectFn, removeEffect, State } from \"~/reactivity\";\nimport { onNodeReattached } from \"~/util\";\n\nimport { setComponentCleanup } from \"./component-cleanup\";\nimport { DestroyFn } from \"./on-destroy\";\nimport { MountFn } from \"./on-mount\";\n\nexport type LifecycleContext = {\n  mount: MountFn[];\n  effect: EffectFn[];\n  state: {\n    states: State<any>[];\n    index: number;\n  };\n  destroy: DestroyFn[];\n};\n\n/**\n * run the life cycle\n *\n * @param context - The lifecycle context.\n * @param targetNode - The target node.\n */\nexport function runLifecycle(context: LifecycleContext, targetNode: Node) {\n  const cleanups: (() => void)[] = [];\n\n  setMountContext(null);\n  setStateContext(null);\n  setEffectContext(null);\n  setDestroyContext(null);\n\n  setComponentCleanup(targetNode, cleanups);\n\n  // Re-run memo when node is reattached\n  onNodeReattached(() => {\n    cleanups.push(...context.mount.map((fn) => fn()).filter((c) => !!c));\n  }, targetNode);\n\n  // Pass cleanups once dom is painted\n  queueMicrotask(() => {\n    cleanups.push(\n      ...context.destroy,\n      ...context.mount.map((fn) => fn()).filter((c) => !!c),\n      ...context.effect.map((fn) => () => removeEffect(fn)),\n    );\n  });\n}\n"],"names":["cleanupMap","setComponentCleanup","node","cleanups","runComponentCleanup","cleanup","destroyContext","setDestroyContext","newDestroyContext","effectContext","setEffectContext","newEffectContext","mountContext","setMountContext","newMountStack","stateContext","setStateContext","newStateContext","stateMap","createStateContext","type","key","instance","typeMap","createLifeCycleContext","context","onMount","fn","activeEffect","setActiveEffect","newActiveEffect","lastDisposer","effect","wrappedEffect","removeEffect","previousEffect","disposer","stopEffect","depSet","untrack","prevEffect","isNil","value","getNode","jsxElement","patch","parentNode","oldNodes","newNodes","insertBeforeNode","maxLength","i","oldNode","newNode","IGNORE_COMPONENT","Suspense","resolveComponentProps","props","componentRootNodes","mountComponent","_key","children","targetNode","toArray","runLifecycle","suspenseHandlerList","rootNode","fallback","handler","promise","renderChildren","getCurrentSuspenseHandler","anchor","cleanupDomNodes","child","result","error","Fragment","SVG_TAGS","MATH_ML_TAGS","UNIT_LESS_PROPS","IS_SSR","jsx","hSSR","h","eventRegistry","addEventListener","element","listener","handlers","removeEventListener","applyProps","run","applyStyle","style","cssKey","finalValue","isUnitLessCSSProperty","prop","createElement","tag","namespace","handlePropsSSR","handleChildrenSSR","transformedProps","transformedChildren","nested","onNodeReattached","callback","observer","mutationsList","mutation","item","c"],"mappings":"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C,CAClE,OAAOA,CACT,CCRa,MAAAiB,EAAW,IAAI,IAAI,CAC9B,IACA,UACA,gBACA,mBACA,SACA,WACA,OACA,OACA,UACA,UACA,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,eACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,eACA,SACA,gBACA,IACA,QACA,YACA,QACA,OACA,iBACA,SACA,OACA,OACA,eACA,YACA,UACA,WACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,SACA,MACA,aACA,OACA,QACA,MACA,SACA,SACA,OACA,WACA,QACA,OACA,QACA,UACA,MACA,MACF,CAAC,EAEYC,EAAe,IAAI,IAAI,CAClC,OACA,UACA,cACA,aACA,WACA,SACA,UACA,QACA,SACA,KACA,aACA,gBACA,KACA,KACA,QACA,UACA,WACA,QACA,OACA,KACA,YACA,UACA,UACA,SACA,SACA,OACA,UACA,OACA,SACA,MACA,QACA,MACA,SACA,aACA,YACA,aACA,gBACF,CAAC,EClHYC,EAAkB,CAC7B,0BACA,oBACA,mBACA,mBACA,UACA,eACA,kBACA,cACA,OACA,WACA,eACA,aACA,eACA,YACA,UACA,aACA,aACA,YACA,aACA,UACA,QACA,UACA,UACA,SACA,SACA,OACA,cACA,eACA,cACA,kBACA,mBACA,mBACA,gBACA,aACF,ECjCaC,EAAS,OAAO,SAAa,ICUpCC,EAAM,CACV9D,EACA,CAAE,SAAAyC,EAAW,CAAC,EAAG,GAAGJ,CAAM,EAC1BpC,IAEI4D,EACKE,GAAK/D,EAAMqC,EAAOM,EAAQF,CAAQ,CAAC,EAGrCuB,GAAEhE,EAAMqC,EAAOM,EAAQF,CAAQ,EAAGxC,CAAG,ECnBxCgE,EAAgB,IAAI,QASnB,SAASC,EAAiBC,EAAsBnE,EAAcoE,EAAyB,CAC5F,IAAIC,EAAWJ,EAAc,IAAIE,CAAO,EAEnCE,IACHA,EAAW,IAAI,IACfJ,EAAc,IAAIE,EAASE,CAAQ,GAIjCA,EAAS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"}