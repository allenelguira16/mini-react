{"version":3,"file":"register-lifecycle-CabvQ1Pt.js","sources":["../../../src/life-cycle/component-cleanup.ts","../../../src/context/destroy-context.ts","../../../src/context/effect-context.ts","../../../src/context/mount-context.ts","../../../src/life-cycle/init-lifecycle.ts","../../../src/reactivity/effect.ts","../../../src/reactivity/track.ts","../../../src/reactivity/state.ts","../../../src/reactivity/untrack.ts","../../../src/util/is-node-nil.ts","../../../src/util/get-node.ts","../../../src/render/render-children/patch.ts","../../../src/render/render-children/suspense-effect.ts","../../../src/render/render-children/render-children.ts","../../../src/render/fragment.ts","../../../src/const/element-tags.ts","../../../src/const/unit-less-props.ts","../../../src/const/index.ts","../../../src/jsx-runtime.ts","../../../src/render/apply-props.ts","../../../src/render/suspense.ts","../../../src/render/mount-component/resolve-component-props.ts","../../../src/render/mount-component/mount-component.ts","../../../src/render/h.ts","../../../src/render/ssr.ts","../../../src/util/on-node-reattached.ts","../../../src/util/to-array.ts","../../../src/life-cycle/register-lifecycle.ts"],"sourcesContent":["const cleanupMap = new Map<Node, (() => void)[]>();\n\nexport function registerComponentCleanup(node: Node, cleanups: (() => void)[]) {\n  cleanupMap.set(node, cleanups);\n}\n\nexport function runComponentCleanup($node: Node) {\n  const cleanups = cleanupMap.get($node) || [];\n  for (const cleanup of cleanups) {\n    cleanup();\n  }\n}\n","import { DestroyFn } from \"~/life-cycle\";\n\nexport let destroyContext: DestroyFn[] | null = null;\n\nexport function setDestroyContext(stack: (() => void)[] | null) {\n  destroyContext = stack;\n}\n","import { EffectFn } from \"~/reactivity\";\n\nexport let effectContext: EffectFn[] | null = null;\n\nexport function setEffectContext(newEffectContext: EffectFn[] | null) {\n  effectContext = newEffectContext;\n}\n","import { MountFn } from \"~/life-cycle\";\n\nexport let mountContext: MountFn[] | null = null;\n\nexport function setMountContext(stack: (() => void)[] | null) {\n  mountContext = stack;\n}\n","import { setDestroyContext, setEffectContext, setMountContext } from \"~/context\";\n\nimport { LifecycleContext } from \"./register-lifecycle\";\n\nexport function initializeLifecycleContext(context: LifecycleContext) {\n  setMountContext(context.mount);\n  setEffectContext(context.effect);\n  setDestroyContext(context.destroy);\n}\n","import { effectContext } from \"~/context\";\n\n// Effect function type with dependency tracking\nexport type EffectFn = (() => void) & { deps?: Set<EffectFn>[] };\n\n// Currently active effect (global context for dependency collection)\nexport let activeEffect: EffectFn | null = null;\n\nexport function setActiveEffect(newActiveEffect: EffectFn | null) {\n  activeEffect = newActiveEffect;\n}\n\nexport function effect(fn: () => void): () => void {\n  const wrappedEffect: EffectFn = () => {\n    removeEffect(wrappedEffect);\n\n    const previousEffect = activeEffect; // save previous activeEffect\n    activeEffect = wrappedEffect;\n\n    if (effectContext) {\n      effectContext.push(wrappedEffect); // keep your effectContext intact\n    }\n\n    try {\n      fn();\n    } finally {\n      activeEffect = previousEffect; // restore outer activeEffect\n    }\n  };\n\n  wrappedEffect.deps = [];\n  wrappedEffect();\n\n  return () => removeEffect(wrappedEffect);\n}\n\nexport function removeEffect(effect: EffectFn) {\n  if (effect.deps) {\n    for (const depSet of effect.deps) {\n      depSet.delete(effect); // Remove this effect from all dependency sets\n    }\n    effect.deps.length = 0; // Reset dependency list\n  }\n}\n","import { activeEffect, EffectFn } from \"./effect\";\n\n// WeakMap to track which targets/keys map to which effects\nconst targetToPropertyEffectsMap: WeakMap<object, Map<PropertyKey, Set<EffectFn>>> = new WeakMap();\n\nexport function track(target: object, key: PropertyKey) {\n  if (!activeEffect) return; // No effect is currently running\n\n  let propertyEffectsMap = targetToPropertyEffectsMap.get(target);\n  if (!propertyEffectsMap) {\n    propertyEffectsMap = new Map();\n    targetToPropertyEffectsMap.set(target, propertyEffectsMap);\n  }\n\n  let effects = propertyEffectsMap.get(key);\n  if (!effects) {\n    effects = new Set();\n    propertyEffectsMap.set(key, effects);\n  }\n\n  if (!effects.has(activeEffect)) {\n    effects.add(activeEffect);\n    // Record this dependency set for cleanup later\n    if (activeEffect.deps) {\n      activeEffect.deps.push(effects);\n    } else {\n      activeEffect.deps = [effects];\n    }\n  }\n}\n\nexport function trigger(target: object, key: PropertyKey) {\n  const propertyEffectsMap = targetToPropertyEffectsMap.get(target);\n  if (!propertyEffectsMap) return;\n\n  const effects = propertyEffectsMap.get(key);\n  if (!effects) return;\n\n  // Clone the effects set to avoid infinite loops if the effect triggers itself\n  const effectsToRun = new Set(effects);\n  for (const effect of effectsToRun) {\n    effect();\n  }\n}\n","import { track, trigger } from \"./track\";\n\nexport type State<T> = {\n  value: T;\n};\n\nexport function state<T>(initialValue: T): State<T>;\nexport function state<T = undefined>(): State<T | undefined>;\nexport function state<T>(initialValue?: T): State<T | undefined> {\n  const state = { value: initialValue };\n\n  return new Proxy(state, {\n    get(target, key, receiver) {\n      track(target, key);\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, newValue, receiver) {\n      const oldValue = target[key as keyof typeof target];\n      const result = Reflect.set(target, key, newValue, receiver);\n\n      if (oldValue !== newValue) {\n        trigger(target, key);\n      }\n\n      return result;\n    },\n  });\n}\n","import { activeEffect, setActiveEffect } from \"./effect\";\n\nexport function untrack<T>(fn: () => T): T {\n  const prevEffect = activeEffect;\n  setActiveEffect(null); // disable tracking\n\n  try {\n    return fn();\n  } finally {\n    setActiveEffect(prevEffect); // restore previous tracking context\n  }\n}\n","/**\n * check if a value is null, undefined, or false\n *\n * @param value - The value to check if it is null, undefined, or false.\n * @returns True if the value is null, undefined, or false.\n */\nexport const isNil = (value: unknown): value is null | undefined | false => {\n  return value === undefined || value === null || value === false;\n};\n","import { isNil } from \"./is-node-nil\";\n\n/**\n * get the node for a JSX element\n *\n * @param jsxElement - The JSX element to get the node for.\n * @returns The node for the JSX element.\n */\nexport function getNode(jsxElement: JSX.Element): undefined | Node | (Node | undefined)[] {\n  if (jsxElement instanceof Node) {\n    return jsxElement;\n  }\n\n  if (isNil(jsxElement)) {\n    return undefined;\n  }\n\n  if (typeof jsxElement === \"function\") {\n    return getNode(jsxElement());\n  }\n\n  if (Array.isArray(jsxElement)) {\n    return jsxElement.map(getNode) as (Node | undefined)[];\n  }\n\n  return document.createTextNode(String(jsxElement));\n}\n","import { runComponentCleanup } from \"~/life-cycle\";\nimport { isNil } from \"~/util\";\n\n/**\n * patch the old nodes with the new nodes\n *\n * @param $parent - The parent node.\n * @param $oldNodes - The old nodes.\n * @param $newNodes - The new nodes.\n * @param isFirstRender - Whether it is the first render.\n */\nexport function patch(\n  $parent: Node,\n  $oldNodes: Node[],\n  $newNodes: (Node | undefined)[],\n  isFirstRender: boolean,\n) {\n  const maxLength = Math.max($oldNodes.length, $newNodes.length);\n\n  for (let i = 0; i < maxLength; i++) {\n    const $oldNode = $oldNodes[i];\n    const $newNode = $newNodes[i];\n\n    if (isFirstRender) {\n      if (isNil($newNode)) continue;\n\n      $parent.appendChild($newNode);\n      $oldNodes[i] = $newNode;\n\n      continue;\n    }\n\n    // Add new node\n    if (isNil($oldNode) && !isNil($newNode)) {\n      $parent.appendChild($newNode);\n      $oldNodes[i] = $newNode;\n      continue;\n    }\n\n    // Remove old node\n    if (!isNil($oldNode) && isNil($newNode)) {\n      runComponentCleanup($oldNode);\n      $parent.removeChild($oldNodes[i]);\n      $oldNodes.splice(i, 1);\n      i--;\n      continue;\n    }\n\n    // If both empty, continue to next iteration\n    if (isNil($oldNode) && isNil($newNode)) {\n      continue;\n    }\n\n    if ($oldNode && $newNode) {\n      // Replace node with node\n      if (!$oldNode.isSameNode($newNode)) {\n        runComponentCleanup($oldNode);\n        ($oldNode as ChildNode).replaceWith($newNode);\n        $oldNodes[i] = $newNode;\n      }\n      continue;\n    }\n\n    console.warn(`[veltra]: warning - unknown dom detected: `, {\n      old: $oldNode,\n      new: $newNode,\n    });\n  }\n\n  return [...$oldNodes];\n}\n","import { effect } from \"~/reactivity\";\n\nexport function suspenseReactor(fn: () => void) {\n  let cleanup: (() => void) | null = null;\n\n  const run = () => {\n    if (cleanup) cleanup();\n\n    cleanup = effect(() => {\n      try {\n        fn();\n      } catch (e) {\n        if (e instanceof Promise) {\n          e.then(run).catch(console.error);\n        } else {\n          console.error(e);\n        }\n      }\n    });\n  };\n\n  run();\n}\n","import { getNode, toArray } from \"~/util\";\n\nimport { patch } from \"./patch\";\nimport { suspenseReactor } from \"./suspense-effect\";\n\n/**\n * render the children\n *\n * @param $parent - The parent node.\n * @param children - The children to render.\n * @param index - The index to insert the children at.\n */\nexport function renderChildren($parent: Node, children: JSX.Element[], index?: number) {\n  let insertBeforeNode: ChildNode | null = null;\n\n  if (index !== undefined) {\n    insertBeforeNode = $parent.childNodes[index] as ChildNode;\n  }\n\n  for (const $child of children) {\n    if (typeof $child === \"function\") {\n      let $oldNodes: Node[] = [];\n      let isFirstRender = true;\n\n      suspenseReactor(() => {\n        const $newNodes = toArray($child()).map(getNode).flat();\n        $oldNodes = patch($parent, $oldNodes, $newNodes, isFirstRender);\n        isFirstRender = false;\n      });\n    } else {\n      const $node = getNode($child);\n      if (!Array.isArray($node) && $node) {\n        if (insertBeforeNode) {\n          $parent.insertBefore($node, insertBeforeNode);\n        } else {\n          $parent.appendChild($node);\n        }\n      }\n    }\n  }\n}\n","export function Fragment({ children }: { children: JSX.Element[] }) {\n  return children;\n}\n","export const SVG_TAGS = new Set([\n  \"a\",\n  \"animate\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"defs\",\n  \"desc\",\n  \"discard\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"foreignObject\",\n  \"g\",\n  \"hatch\",\n  \"hatchpath\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"mesh\",\n  \"meshgradient\",\n  \"meshpatch\",\n  \"meshrow\",\n  \"metadata\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"script\",\n  \"set\",\n  \"solidcolor\",\n  \"stop\",\n  \"style\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"title\",\n  \"tref\",\n  \"tspan\",\n  \"unknown\",\n  \"use\",\n  \"view\",\n]);\n\nexport const MATH_ML_TAGS = new Set([\n  \"math\",\n  \"maction\",\n  \"maligngroup\",\n  \"malignmark\",\n  \"menclose\",\n  \"merror\",\n  \"mfenced\",\n  \"mfrac\",\n  \"mglyph\",\n  \"mi\",\n  \"mlabeledtr\",\n  \"mmultiscripts\",\n  \"mn\",\n  \"mo\",\n  \"mover\",\n  \"mpadded\",\n  \"mphantom\",\n  \"mroot\",\n  \"mrow\",\n  \"ms\",\n  \"mscarries\",\n  \"mscarry\",\n  \"msgroup\",\n  \"mstack\",\n  \"mstyle\",\n  \"msub\",\n  \"msubsup\",\n  \"msup\",\n  \"mtable\",\n  \"mtd\",\n  \"mtext\",\n  \"mtr\",\n  \"munder\",\n  \"munderover\",\n  \"semantics\",\n  \"annotation\",\n  \"annotation-xml\",\n]);\n","export const UNIT_LESS_PROPS = [\n  \"animationIterationCount\",\n  \"borderImageOutset\",\n  \"borderImageSlice\",\n  \"borderImageWidth\",\n  \"boxFlex\",\n  \"boxFlexGroup\",\n  \"boxOrdinalGroup\",\n  \"columnCount\",\n  \"flex\",\n  \"flexGrow\",\n  \"flexPositive\",\n  \"flexShrink\",\n  \"flexNegative\",\n  \"flexOrder\",\n  \"gridRow\",\n  \"gridColumn\",\n  \"fontWeight\",\n  \"lineClamp\",\n  \"lineHeight\",\n  \"opacity\",\n  \"order\",\n  \"orphans\",\n  \"tabSize\",\n  \"widows\",\n  \"zIndex\",\n  \"zoom\",\n  \"fillOpacity\",\n  \"floodOpacity\",\n  \"stopOpacity\",\n  \"strokeDasharray\",\n  \"strokeDashoffset\",\n  \"strokeMiterlimit\",\n  \"strokeOpacity\",\n  \"strokeWidth\",\n];\n","export * from \"./element-tags\";\nexport * from \"./unit-less-props\";\nexport const IS_SSR = typeof document === \"undefined\";\n","/// <reference path=\"./jsx.d.ts\" />\n\nimport { IS_SSR } from \"./const\";\nimport { Fragment, h, hSSR } from \"./render\";\nimport { toArray } from \"./util\";\n\n/**\n * jsx runtime\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element.\n */\nconst jsx = (\n  type: string | ((props: Record<string, any>) => any),\n  { children = [], ...props }: Record<string, any>,\n) => {\n  if (IS_SSR) {\n    return hSSR(type, props, toArray(children));\n  }\n\n  return h(type, props, toArray(children));\n};\n\nexport { Fragment, jsx, jsx as jsxs };\n","import { UNIT_LESS_PROPS } from \"~/const\";\n\nimport { effect as reactor } from \"../reactivity\";\n\n/**\n * apply the properties to the element\n *\n * @param $element - The element to apply the properties to.\n * @param props - The properties to apply.\n */\nexport function applyProps($element: HTMLElement | Element, props: Record<string, any>) {\n  for (const key in props) {\n    if (key.startsWith(\"on\") && typeof props[key] === \"function\") {\n      const type = key.slice(2).toLowerCase();\n      let cleanup: () => void;\n\n      reactor(() => {\n        // Remove the previous listener if there was one\n        if (cleanup) cleanup();\n\n        const fn = props[key]();\n        if (typeof fn === \"function\") {\n          $element.addEventListener(type, fn);\n          // Setup cleanup for next effect run\n          cleanup = () => $element.removeEventListener(type, fn);\n        }\n      });\n    } else {\n      reactor(() => {\n        const value = typeof props[key] === \"function\" ? props[key]() : props[key];\n\n        if (key === \"ref\" && typeof value === \"function\") {\n          value($element);\n        } else if (key === \"style\") {\n          applyStyle($element, value);\n        } else if (key === \"disabled\") {\n          $element.toggleAttribute(key, value);\n        } else {\n          $element.setAttribute(key, value);\n        }\n      });\n    }\n  }\n}\n\n/**\n * apply the style to the element\n *\n * @param $element - The element to apply the style to.\n * @param style - The style to apply.\n */\nfunction applyStyle($element: HTMLElement | Element, style: Record<string, any>) {\n  if (!($element instanceof HTMLElement)) return;\n\n  for (const [key, value] of Object.entries(style)) {\n    const cssKey = key as keyof CSSStyleDeclaration;\n    if (cssKey === \"length\" || cssKey === \"parentRule\") continue;\n\n    const isNumber = typeof value === \"number\";\n    const needsUnit = isNumber && !isUnitLessCSSProperty(key);\n    const finalValue = needsUnit ? `${value}px` : String(value);\n\n    $element.style.setProperty(String(cssKey), finalValue);\n  }\n}\n\n/**\n * check if a property is a unitless CSS property\n *\n * @param prop - The property to check.\n * @returns True if the property is a unitless CSS property.\n */\nfunction isUnitLessCSSProperty(prop: string): boolean {\n  const unitLessProps = new Set(UNIT_LESS_PROPS);\n\n  return unitLessProps.has(prop);\n}\n","import { effect, state } from \"~/reactivity\";\nimport { getNode, toArray } from \"~/util\";\n\nimport { patch } from \"./render-children/patch\";\n\nexport const suspensePromise = state<Promise<void> | null>(null);\n\n/**\n * create a suspense component\n *\n * @param props - The properties of the component.\n * @returns The suspense component.\n */\nexport function Suspense(props: { fallback: JSX.Element; children: JSX.Element }) {\n  const $rootNode = document.createTextNode(\"\");\n  let $parent: Node;\n\n  // Change types since this is transformed by babel\n  const {\n    fallback: _fallback,\n    children: [children],\n  } = props as unknown as {\n    fallback: () => JSX.Element;\n    children: [() => JSX.Element[]];\n  };\n\n  const fallback = _fallback() as Node;\n\n  let isFirstRender = true;\n  let $oldNodes: Node[] = [];\n\n  const renderFallback = () => {\n    $oldNodes = patch($parent, $oldNodes, getNodes(fallback), isFirstRender);\n    isFirstRender = false;\n  };\n\n  const renderSuspenseChildren = () => {\n    const $newNodes = getNodes(children()).flat() as Node[];\n    $oldNodes = patch($parent, $oldNodes, $newNodes, isFirstRender);\n  };\n\n  queueMicrotask(() => {\n    $parent = $rootNode.parentNode as Node;\n\n    effect(() => {\n      try {\n        if (!$parent) return;\n        renderFallback();\n\n        if (suspensePromise.value) throw suspensePromise.value;\n\n        renderSuspenseChildren();\n      } catch (errorOrPromise) {\n        if (errorOrPromise instanceof Promise) {\n          errorOrPromise\n            .then(() => {\n              suspensePromise.value = null;\n              renderSuspenseChildren();\n            })\n            .catch(() => {});\n        } else {\n          throw errorOrPromise;\n        }\n      }\n    });\n  });\n\n  // initial render is fallback node\n  return $rootNode;\n}\n\nconst getNodes = <T extends JSX.Element | Node>(items: T) => {\n  const results: T[] = [];\n  const flatItems = toArray(items);\n\n  for (const item of flatItems) {\n    const node = getNode(item); // Throws here if resource.value is pending\n    if (Array.isArray(node)) {\n      results.push(...(node as T[]));\n    } else {\n      results.push(node as T);\n    }\n  }\n\n  return results;\n};\n","import { Suspense } from \"../suspense\";\n\nconst IGNORE_COMPONENT = [Suspense] as Array<(...args: any[]) => any>;\n\n/**\n * resolve the component props\n *\n * @param type - The type of the component.\n * @param props - The properties of the component.\n */\nexport function resolveComponentProps(type: (...args: any[]) => any, props: Record<string, any>) {\n  if (IGNORE_COMPONENT.includes(type)) return;\n\n  for (const key in props) {\n    props[key] = props[key] instanceof Function ? props[key]() : props[key];\n  }\n}\n","import { initializeLifecycleContext, LifecycleContext, registerLifeCycles } from \"~/life-cycle\";\nimport { untrack } from \"~/reactivity\";\n\nimport { resolveComponentProps } from \"./resolve-component-props\";\n\nexport const componentRootNodes = new Set<Node>();\n\n/**\n * mount a component\n *\n * @param type - The type of the component.\n * @param props - The properties of the component.\n * @param children - The children of the component.\n */\nexport function mountComponent(\n  type: (props: Record<string, any>) => any,\n  props: Record<string, any>,\n  children: JSX.Element[],\n) {\n  resolveComponentProps(type, props);\n\n  const lifecycleContext: LifecycleContext = {\n    mount: [],\n    effect: [],\n    destroy: [],\n  };\n\n  initializeLifecycleContext(lifecycleContext);\n\n  const $node = untrack(() => type({ ...props, children }));\n  let $target = $node;\n\n  if (Array.isArray($node)) {\n    $target = document.createTextNode(\"\");\n    $node.unshift($target);\n  }\n\n  registerLifeCycles(lifecycleContext, $target);\n\n  componentRootNodes.add($target);\n  return $node;\n}\n","import { MATH_ML_TAGS, SVG_TAGS } from \"~/const\";\nimport { Fragment } from \"~/jsx-runtime\";\n\nimport { applyProps } from \"./apply-props\";\nimport { mountComponent } from \"./mount-component\";\nimport { renderChildren } from \"./render-children\";\n\n/**\n * create a JSX element\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element.\n */\nexport function h(\n  type: string | ((props: Record<string, any>) => any),\n  props: Record<string, any>,\n  children: JSX.Element[],\n) {\n  if (type === Fragment) {\n    return children;\n  }\n\n  if (typeof type === \"function\") {\n    return mountComponent(type, props, children);\n  }\n\n  const $element = createElement(type, props.xmlns);\n\n  applyProps($element, props);\n  renderChildren($element, children);\n\n  return $element;\n}\n\nfunction createElement(tag: string, namespace?: string) {\n  if ((SVG_TAGS.has(tag) || MATH_ML_TAGS.has(tag)) && namespace) {\n    return document.createElementNS(namespace, tag);\n  }\n\n  return document.createElement(tag);\n}\n","export function hSSR(\n  type: string | ((props: Record<string, any>) => any),\n  props: Record<string, any>,\n  children: JSX.Element[],\n) {\n  if (typeof type === \"function\") {\n    return type({ ...props, children });\n  }\n\n  return `<${type} ${handlePropsSSR(props)}>${handleChildrenSSR(children)}</${type}>`;\n}\n\nfunction handlePropsSSR(props: Record<string, any>) {\n  const transformedProps: string[] = [];\n\n  for (const key in props) {\n    if (key.startsWith(\"on\") && typeof props[key] === \"function\") {\n      continue;\n    }\n\n    const value = typeof props[key] === \"function\" ? props[key]() : props[key];\n\n    if (key === \"ref\" && typeof value === \"function\") {\n      // value($element);\n    } else if (key === \"style\") {\n      // applyStyle($element, value);\n    } else if (key === \"disabled\" && value) {\n      transformedProps.push(\"disabled\");\n    } else {\n      transformedProps.push(`${key}=\"${value}\"`);\n    }\n  }\n\n  return transformedProps.join(\" \");\n}\n\nfunction handleChildrenSSR(children: JSX.Element[]) {\n  const transformedChildren: string[] = [];\n\n  for (const child of children) {\n    if (typeof child === \"function\") {\n      transformedChildren.push(String(child()));\n    } else if (Array.isArray(child)) {\n      // RECURSIVELY flatten nested arrays\n      child.forEach((nested) => transformedChildren.push(handleChildrenSSR([nested])));\n    } else {\n      // console.log(child);\n      transformedChildren.push(child as string);\n      // return child\n      // const childRef = getNode(child) as Node;\n\n      // $parent.appendChild(childRef);\n      // mountSpecialComponent(childRef);\n    }\n  }\n\n  return transformedChildren.join(\"\");\n}\n","/**\n * observe a node and call a callback when it is reattached\n *\n * @param callback - The callback to call when the node is reattached.\n * @param $node - The node to observe.\n */\nexport function onNodeReattached(callback: () => void, $node: Node) {\n  // Create a MutationObserver instance\n  const observer = new MutationObserver((mutationsList) => {\n    for (const mutation of mutationsList) {\n      // Check for added nodes\n      for (const node of mutation.addedNodes) {\n        if (node === $node) {\n          observer.disconnect();\n          callback();\n          break;\n        }\n      }\n    }\n  });\n\n  queueMicrotask(() => {\n    if (!$node.parentNode) {\n      return;\n    }\n\n    observer.observe($node.parentNode, { childList: true, subtree: true });\n  });\n}\n","/**\n * convert an item to an array\n *\n * @param item - The item to convert to an array.\n * @returns The item as an array.\n */\nexport const toArray = <T>(item: T) => {\n  return (Array.isArray(item) ? item : [item]).flat(Infinity) as T[];\n};\n","import { setDestroyContext, setEffectContext, setMountContext } from \"~/context\";\nimport { EffectFn, removeEffect } from \"~/reactivity\";\nimport { onNodeReattached } from \"~/util\";\n\nimport { registerComponentCleanup } from \"./component-cleanup\";\nimport { DestroyFn } from \"./on-destroy\";\nimport { MountFn } from \"./on-mount\";\n\nexport type LifecycleContext = {\n  mount: MountFn[];\n  effect: EffectFn[];\n  destroy: DestroyFn[];\n};\n\nexport function registerLifeCycles(context: LifecycleContext, $target: Node) {\n  const cleanups: (() => void)[] = [];\n\n  setMountContext(null);\n  setEffectContext(null);\n  setDestroyContext(null);\n\n  registerComponentCleanup($target, cleanups);\n\n  // Pass cleanups once dom is painted\n  queueMicrotask(() => {\n    cleanups.push(\n      ...context.destroy,\n      ...context.mount.map((fn) => fn()).filter((c) => !!c),\n      ...context.effect.map((fn) => () => removeEffect(fn)),\n    );\n  });\n\n  // Re-run effect and memo when node is reattached\n  onNodeReattached(() => {\n    cleanups.push(...context.mount.map((fn) => fn()).filter((c) => !!c));\n  }, $target);\n}\n"],"names":["cleanupMap","registerComponentCleanup","node","cleanups","runComponentCleanup","$node","cleanup","destroyContext","setDestroyContext","stack","effectContext","setEffectContext","newEffectContext","mountContext","setMountContext","initializeLifecycleContext","context","activeEffect","setActiveEffect","newActiveEffect","effect","fn","wrappedEffect","removeEffect","previousEffect","depSet","targetToPropertyEffectsMap","track","target","key","propertyEffectsMap","effects","trigger","effectsToRun","state","initialValue","receiver","newValue","oldValue","result","untrack","prevEffect","isNil","value","getNode","jsxElement","patch","$parent","$oldNodes","$newNodes","isFirstRender","maxLength","i","$oldNode","$newNode","suspenseReactor","run","e","renderChildren","children","index","$child","toArray","Fragment","SVG_TAGS","MATH_ML_TAGS","UNIT_LESS_PROPS","IS_SSR","jsx","type","props","hSSR","h","applyProps","$element","reactor","applyStyle","style","cssKey","finalValue","isUnitLessCSSProperty","prop","suspensePromise","Suspense","$rootNode","_fallback","fallback","renderFallback","getNodes","renderSuspenseChildren","errorOrPromise","items","results","flatItems","item","IGNORE_COMPONENT","resolveComponentProps","componentRootNodes","mountComponent","lifecycleContext","$target","registerLifeCycles","createElement","tag","namespace","handlePropsSSR","handleChildrenSSR","transformedProps","transformedChildren","child","nested","onNodeReattached","callback","observer","mutationsList","mutation","c"],"mappings":"aAAA,MAAMA,EAAa,IAAI,IAEhB,SAASC,EAAyBC,EAAYC,EAA0B,CAC7EH,EAAW,IAAIE,EAAMC,CAAQ,CAC/B,CAEO,SAASC,EAAoBC,EAAa,CAC/C,MAAMF,EAAWH,EAAW,IAAIK,CAAK,GAAK,CAAA,EAC1C,UAAWC,KAAWH,EACpBG,EAEJ,CAAA,CCTWC,uBAAqC,KAEzC,SAASC,EAAkBC,EAA8B,CAC9DF,uBAAiBE,CACnB,CCJO,IAAIC,EAAmC,KAEvC,SAASC,EAAiBC,EAAqC,CACpEF,EAAgBE,CAClB,CCJWC,qBAAiC,KAErC,SAASC,EAAgBL,EAA8B,CAC5DI,qBAAeJ,CACjB,CCFgB,SAAAM,EAA2BC,EAA2B,CACpEF,EAAgBE,EAAQ,KAAK,EAC7BL,EAAiBK,EAAQ,MAAM,EAC/BR,EAAkBQ,EAAQ,OAAO,CACnC,CCFW,IAAAC,EAAgC,KAE3B,SAAAC,EAAgBC,EAAkC,CAChEF,EAAeE,CACjB,CAEgB,SAAAC,EAAOC,EAA4B,CACjD,MAAMC,EAA0B,IAAM,CACpCC,EAAaD,CAAa,EAE1B,MAAME,EAAiBP,EACvBA,EAAeK,EAEXZ,GACFA,EAAc,KAAKY,CAAa,EAGlC,GAAI,CACFD,EACF,CAAA,QAAE,CACAJ,EAAeO,CACjB,CACF,EAEA,OAAAF,EAAc,KAAO,CAAA,EACrBA,IAEO,IAAMC,EAAaD,CAAa,CACzC,CAEgB,SAAAC,EAAaH,EAAkB,CAC7C,GAAIA,EAAO,KAAM,CACf,UAAWK,KAAUL,EAAO,KAC1BK,EAAO,OAAOL,CAAM,EAEtBA,EAAO,KAAK,OAAS,CACvB,CACF,CCxCA,MAAMM,EAA+E,IAAI,QAEzE,SAAAC,EAAMC,EAAgBC,EAAkB,CACtD,GAAI,CAACZ,EAAc,OAEnB,IAAIa,EAAqBJ,EAA2B,IAAIE,CAAM,EACzDE,IACHA,EAAqB,IAAI,IACzBJ,EAA2B,IAAIE,EAAQE,CAAkB,GAG3D,IAAIC,EAAUD,EAAmB,IAAID,CAAG,EACnCE,IACHA,EAAU,IAAI,IACdD,EAAmB,IAAID,EAAKE,CAAO,GAGhCA,EAAQ,IAAId,CAAY,IAC3Bc,EAAQ,IAAId,CAAY,EAEpBA,EAAa,KACfA,EAAa,KAAK,KAAKc,CAAO,EAE9Bd,EAAa,KAAO,CAACc,CAAO,EAGlC,UAEgBC,EAAQJ,EAAgBC,EAAkB,CACxD,MAAMC,EAAqBJ,EAA2B,IAAIE,CAAM,EAChE,GAAI,CAACE,EAAoB,OAEzB,MAAMC,EAAUD,EAAmB,IAAID,CAAG,EAC1C,GAAI,CAACE,EAAS,OAGd,MAAME,EAAe,IAAI,IAAIF,CAAO,EACpC,UAAWX,KAAUa,EACnBb,EAEJ,CAAA,CCnCO,SAASc,EAASC,EAAwC,CAC/D,MAAMD,EAAQ,CAAE,MAAOC,CAAa,EAEpC,OAAO,IAAI,MAAMD,EAAO,CACtB,IAAIN,EAAQC,EAAKO,EAAU,CACzB,OAAAT,EAAMC,EAAQC,CAAG,EACV,QAAQ,IAAID,EAAQC,EAAKO,CAAQ,CAC1C,EACA,IAAIR,EAAQC,EAAKQ,EAAUD,EAAU,CACnC,MAAME,EAAWV,EAAOC,CAA0B,EAC5CU,EAAS,QAAQ,IAAIX,EAAQC,EAAKQ,EAAUD,CAAQ,EAE1D,OAAIE,IAAaD,GACfL,EAAQJ,EAAQC,CAAG,EAGdU,CACT,CACF,CAAC,CACH,UCzBgBC,EAAWnB,EAAgB,CACzC,MAAMoB,EAAaxB,EACnBC,EAAgB,IAAI,EAEpB,GAAI,CACF,OAAOG,EACT,CAAA,QAAA,CACEH,EAAgBuB,CAAU,CAC5B,CACF,CCLO,MAAMC,EAASC,GACUA,GAAU,MAAQA,IAAU,GCC5C,SAAAC,EAAQC,EAAkE,CACxF,GAAIA,aAAsB,KACxB,OAAOA,EAGT,GAAI,CAAAH,EAAMG,CAAU,EAIpB,OAAI,OAAOA,GAAe,WACjBD,EAAQC,EAAW,CAAC,EAGzB,MAAM,QAAQA,CAAU,EACnBA,EAAW,IAAID,CAAO,EAGxB,SAAS,eAAe,OAAOC,CAAU,CAAC,CACnD,CCfgB,SAAAC,EACdC,EACAC,EACAC,EACAC,EACA,CACA,MAAMC,EAAY,KAAK,IAAIH,EAAU,OAAQC,EAAU,MAAM,EAE7D,QAASG,EAAI,EAAGA,EAAID,EAAWC,IAAK,CAClC,MAAMC,EAAWL,EAAUI,CAAC,EACtBE,EAAWL,EAAUG,CAAC,EAE5B,GAAIF,EAAe,CACjB,GAAIR,EAAMY,CAAQ,EAAG,SAErBP,EAAQ,YAAYO,CAAQ,EAC5BN,EAAUI,CAAC,EAAIE,EAEf,QACF,CAGA,GAAIZ,EAAMW,CAAQ,GAAK,CAACX,EAAMY,CAAQ,EAAG,CACvCP,EAAQ,YAAYO,CAAQ,EAC5BN,EAAUI,CAAC,EAAIE,EACf,QACF,CAGA,GAAI,CAACZ,EAAMW,CAAQ,GAAKX,EAAMY,CAAQ,EAAG,CACvClD,EAAoBiD,CAAQ,EAC5BN,EAAQ,YAAYC,EAAUI,CAAC,CAAC,EAChCJ,EAAU,OAAOI,EAAG,CAAC,EACrBA,IACA,QACF,CAGA,GAAI,EAAAV,EAAMW,CAAQ,GAAKX,EAAMY,CAAQ,GAIrC,CAAID,GAAAA,GAAYC,EAAU,CAEnBD,EAAS,WAAWC,CAAQ,IAC/BlD,EAAoBiD,CAAQ,EAC3BA,EAAuB,YAAYC,CAAQ,EAC5CN,EAAUI,CAAC,EAAIE,GAEjB,QACF,CAEA,QAAQ,KAAK,6CAA8C,CACzD,IAAKD,EACL,IAAKC,CACP,CAAC,EACH,CAEA,MAAO,CAAC,GAAGN,CAAS,CACtB,CCpEO,SAASO,EAAgBlC,EAAgB,CAC9C,IAAIf,EAA+B,KAEnC,MAAMkD,EAAM,IAAM,CACZlD,GAASA,EAAAA,EAEbA,EAAUc,EAAO,IAAM,CACrB,GAAI,CACFC,GACF,OAASoC,EAAG,CACNA,aAAa,QACfA,EAAE,KAAKD,CAAG,EAAE,MAAM,QAAQ,KAAK,EAE/B,QAAQ,MAAMC,CAAC,CAEnB,CACF,CAAC,CACH,EAEAD,EACF,CAAA,CCVgB,SAAAE,EAAeX,EAAeY,EAAyBC,EAAgB,CAOrF,UAAWC,KAAUF,EACnB,GAAI,OAAOE,GAAW,WAAY,CAChC,IAAIb,EAAoB,CAAA,EACpBE,EAAgB,GAEpBK,EAAgB,IAAM,CACpB,MAAMN,EAAYa,EAAQD,EAAO,CAAC,EAAE,IAAIjB,CAAO,EAAE,KAAK,EACtDI,EAAYF,EAAMC,EAASC,EAAWC,EAAWC,CAAa,EAC9DA,EAAgB,EAClB,CAAC,CACH,KAAO,CACL,MAAM7C,EAAQuC,EAAQiB,CAAM,EACxB,CAAC,MAAM,QAAQxD,CAAK,GAAKA,GAIzB0C,EAAQ,YAAY1C,CAAK,CAG/B,CAEJ,CCxCO,SAAS0D,EAAS,CAAE,SAAAJ,CAAS,EAAgC,CAClE,OAAOA,CACT,CCFa,MAAAK,EAAW,IAAI,IAAI,CAC9B,IACA,UACA,gBACA,mBACA,SACA,WACA,OACA,OACA,UACA,UACA,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,eACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,eACA,SACA,gBACA,IACA,QACA,YACA,QACA,OACA,iBACA,SACA,OACA,OACA,eACA,YACA,UACA,WACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,SACA,MACA,aACA,OACA,QACA,MACA,SACA,SACA,OACA,WACA,QACA,OACA,QACA,UACA,MACA,MACF,CAAC,EAEYC,EAAe,IAAI,IAAI,CAClC,OACA,UACA,cACA,aACA,WACA,SACA,UACA,QACA,SACA,KACA,aACA,gBACA,KACA,KACA,QACA,UACA,WACA,QACA,OACA,KACA,YACA,UACA,UACA,SACA,SACA,OACA,UACA,OACA,SACA,MACA,QACA,MACA,SACA,aACA,YACA,aACA,gBACF,CAAC,EClHYC,EAAkB,CAC7B,0BACA,oBACA,mBACA,mBACA,UACA,eACA,kBACA,cACA,OACA,WACA,eACA,aACA,eACA,YACA,UACA,aACA,aACA,YACA,aACA,UACA,QACA,UACA,UACA,SACA,SACA,OACA,cACA,eACA,cACA,kBACA,mBACA,mBACA,gBACA,aACF,ECjCaC,EAAS,OAAO,SAAa,ICYpCC,EAAM,CACVC,EACA,CAAE,SAAAV,EAAW,GAAI,GAAGW,CAAM,IAEtBH,EACKI,EAAKF,EAAMC,EAAOR,EAAQH,CAAQ,CAAC,EAGrCa,EAAEH,EAAMC,EAAOR,EAAQH,CAAQ,CAAC,ECZzB,SAAAc,EAAWC,EAAiCJ,EAA4B,CACtF,UAAWzC,KAAOyC,EAChB,GAAIzC,EAAI,WAAW,IAAI,GAAK,OAAOyC,EAAMzC,CA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"}