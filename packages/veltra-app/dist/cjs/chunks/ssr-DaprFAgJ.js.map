{"version":3,"file":"ssr-DaprFAgJ.js","sources":["../../../src/life-cycle/component-cleanup.ts","../../../src/context/destroy-context.ts","../../../src/context/effect-context.ts","../../../src/context/mount-context.ts","../../../src/context/state-context.ts","../../../src/life-cycle/create-lifecycle.ts","../../../src/life-cycle/on-mount.ts","../../../src/reactivity/effect.ts","../../../src/reactivity/untrack.ts","../../../src/life-cycle/run-lifecycle.ts","../../../src/util/is-node-nil.ts","../../../src/util/get-node.ts","../../../src/util/to-array.ts","../../../src/render/render-children/patch.ts","../../../src/render/mount-component/resolve-component-props.ts","../../../src/render/mount-component/mount-component.ts","../../../src/render/suspense.ts","../../../src/render/render-children/render-children.ts","../../../src/render/fragment.ts","../../../src/const/element-tags.ts","../../../src/const/unit-less-props.ts","../../../src/const/index.ts","../../../src/jsx-runtime.ts","../../../src/render/event-registry.ts","../../../src/render/apply-props.ts","../../../src/render/h.ts","../../../src/render/ssr.ts"],"sourcesContent":["const cleanupMap = new Map<Node, (() => void)[]>();\n\n/**\n * set the component cleanup\n *\n * @param node - The node.\n * @param cleanups - The cleanups.\n */\nexport function setComponentCleanup(node: Node, cleanups: (() => void)[]) {\n  cleanupMap.set(node, cleanups);\n}\n\n/**\n * run the component cleanup\n *\n * @param node - The node.\n */\nexport function runComponentCleanup(node: Node) {\n  const cleanups = cleanupMap.get(node) || [];\n  for (const cleanup of cleanups) {\n    cleanup();\n    cleanupMap.delete(node);\n  }\n}\n","import { DestroyFn } from \"~/life-cycle\";\n\nexport let destroyContext: DestroyFn[] | null = null;\n\n/**\n * set the destroy context\n *\n * @param newDestroyContext - The destroy context.\n */\nexport function setDestroyContext(newDestroyContext: (() => void)[] | null) {\n  destroyContext = newDestroyContext;\n}\n","import { EffectFn } from \"~/reactivity\";\n\nexport let effectContext: EffectFn[] | null = null;\n\n/**\n * set the effect context\n *\n * @param newEffectContext - The effect context.\n */\nexport function setEffectContext(newEffectContext: EffectFn[] | null) {\n  effectContext = newEffectContext;\n}\n","import { MountFn } from \"~/life-cycle\";\n\nexport let mountContext: MountFn[] | null = null;\n\n/**\n * set the mount context\n *\n * @param newMountStack - The mount context.\n */\nexport function setMountContext(newMountStack: (() => void)[] | null) {\n  mountContext = newMountStack;\n}\n","import { State } from \"~/reactivity\";\n\nexport let stateContext: {\n  states: State<any>[];\n  index: number;\n} | null = null;\n\n/**\n * set the state context\n *\n * @param newStateContext - The state context.\n */\nexport function setStateContext(\n  newStateContext: {\n    states: State<any>[];\n    index: number;\n  } | null = null,\n) {\n  stateContext = newStateContext;\n}\n\nconst stateMap = new Map<any, Map<any, { states: any[] }>>();\n\n/**\n * create a state context\n *\n * @param type - The type of the state.\n * @param key - The key of the state.\n * @returns The state context.\n */\nexport const createStateContext = (\n  type: (props: Record<string, any>) => any,\n  key?: number | string,\n) => {\n  let instance: { states: any[] };\n\n  if (key !== undefined) {\n    if (!stateMap.has(type)) {\n      stateMap.set(type, new Map());\n    }\n    const typeMap = stateMap.get(type)!;\n    if (!typeMap.has(key)) {\n      typeMap.set(key, { states: [] });\n    }\n    instance = typeMap.get(key)!;\n  } else {\n    instance = { states: [] };\n  }\n\n  return { ...instance, index: 0 };\n};\n","import {\n  createStateContext,\n  setDestroyContext,\n  setEffectContext,\n  setMountContext,\n  setStateContext,\n} from \"~/context\";\n\nimport { LifecycleContext } from \"./run-lifecycle\";\n\nexport function createLifeCycleContext(\n  type: (props: Record<string, any>) => any,\n  key?: number | string,\n) {\n  const context: LifecycleContext = {\n    mount: [],\n    state: createStateContext(type, key),\n    effect: [],\n    destroy: [],\n  };\n\n  setMountContext(context.mount);\n  setStateContext(context.state);\n  setEffectContext(context.effect);\n  setDestroyContext(context.destroy);\n\n  return context;\n}\n","import { mountContext } from \"~/context\";\n\nexport type MountFn = () => void | (() => void);\n\n/**\n * on mount\n *\n * @param fn - The function to run on mount.\n */\nexport function onMount(fn: () => () => void): void;\nexport function onMount(fn: () => void): void;\nexport function onMount(fn: MountFn): void {\n  if (mountContext) {\n    mountContext.push(fn);\n  } else {\n    throw new Error(\"onMount called outside of component\");\n  }\n}\n","import { effectContext } from \"~/context\";\n\n/**\n * Effect function type with dependency tracking\n *\n * @param deps - The dependencies of the effect.\n */\nexport type EffectFn = (() => void) & { deps?: Set<EffectFn>[] };\n\n/**\n * Currently active effect\n */\nexport let activeEffect: EffectFn | null = null;\n\nexport function setActiveEffect(newActiveEffect: EffectFn | null) {\n  activeEffect = newActiveEffect;\n}\n\nlet lastDisposer: (() => void) | null = null;\n\n/**\n * Create an effect\n *\n * @param fn - The effect function.\n * @returns The cleanup function.\n */\nexport function effect(fn: () => void): () => void {\n  const wrappedEffect: EffectFn = () => {\n    removeEffect(wrappedEffect);\n    const previousEffect = activeEffect;\n    activeEffect = wrappedEffect;\n\n    if (effectContext) effectContext.push(wrappedEffect);\n\n    try {\n      fn();\n    } finally {\n      activeEffect = previousEffect;\n    }\n  };\n\n  const disposer = () => removeEffect(wrappedEffect);\n  lastDisposer = disposer;\n\n  wrappedEffect.deps = [];\n  wrappedEffect();\n\n  return disposer;\n}\n\nexport function stopEffect() {\n  if (lastDisposer) {\n    lastDisposer();\n    lastDisposer = null;\n  }\n}\n\n/**\n * Remove an effect\n *\n * @param effect - The effect to remove.\n */\nexport function removeEffect(effect: EffectFn) {\n  if (effect.deps) {\n    for (const depSet of effect.deps) {\n      depSet.delete(effect); // Remove this effect from all dependency sets\n    }\n    effect.deps.length = 0; // Reset dependency list\n  }\n}\n","import { activeEffect, setActiveEffect } from \"./effect\";\n\n/**\n * Unwrap a reactive value\n *\n * @param fn - The function that returns the reactive value.\n * @returns The reactive value.\n */\nexport function untrack<T>(fn: () => T): T {\n  const prevEffect = activeEffect;\n  setActiveEffect(null); // disable tracking\n\n  try {\n    return fn();\n  } finally {\n    setActiveEffect(prevEffect); // restore previous tracking context\n  }\n}\n","import { setDestroyContext, setEffectContext, setMountContext, setStateContext } from \"~/context\";\nimport { EffectFn, removeEffect, State } from \"~/reactivity\";\n\nimport { setComponentCleanup } from \"./component-cleanup\";\nimport { DestroyFn } from \"./on-destroy\";\nimport { MountFn } from \"./on-mount\";\n\nexport type LifecycleContext = {\n  mount: MountFn[];\n  effect: EffectFn[];\n  state: {\n    states: State<any>[];\n    index: number;\n  };\n  destroy: DestroyFn[];\n};\n\nexport const componentLifecycleContexts = new Map<Node, LifecycleContext>();\n\n/**\n * run the life cycle\n *\n * @param context - The lifecycle context.\n * @param targetNode - The target node.\n */\nexport function runLifecycle(targetNode: Node) {\n  const context = componentLifecycleContexts.get(targetNode);\n  if (!context) return;\n\n  const cleanups: (() => void)[] = [];\n\n  setMountContext(null);\n  setStateContext(null);\n  setEffectContext(null);\n  setDestroyContext(null);\n\n  setComponentCleanup(targetNode, cleanups);\n\n  // Pass cleanups once dom is painted\n  queueMicrotask(() => {\n    cleanups.push(\n      ...context.destroy,\n      ...context.mount.map((fn) => fn()).filter((c) => !!c),\n      ...context.effect.map((fn) => () => removeEffect(fn)),\n    );\n  });\n}\n","/**\n * check if a value is null, undefined, or false\n *\n * @param value - The value to check if it is null, undefined, or false.\n * @returns True if the value is null, undefined, or false.\n */\nexport const isNil = (value: unknown): value is null | undefined | false => {\n  return value === undefined || value === null || value === false;\n};\n","import { isNil } from \"./is-node-nil\";\n\n/**\n * get the node for a JSX element\n *\n * @param jsxElement - The JSX element to get the node for.\n * @returns The node for the JSX element.\n */\nexport function getNode(jsxElement: JSX.Element): undefined | Node | (Node | undefined)[] {\n  if (jsxElement instanceof Node) {\n    return jsxElement;\n  }\n\n  if (isNil(jsxElement)) {\n    return undefined;\n  }\n\n  if (typeof jsxElement === \"function\") {\n    return getNode(jsxElement());\n  }\n\n  if (Array.isArray(jsxElement)) {\n    return jsxElement.map(getNode) as (Node | undefined)[];\n  }\n\n  return document.createTextNode(String(jsxElement));\n}\n","/**\n * convert an item to an array\n *\n * @param item - The item to convert to an array.\n * @returns The item as an array.\n */\nexport const toArray = <T>(item: T) => {\n  return (Array.isArray(item) ? item : [item]).flat(Infinity) as T[];\n};\n","import { runComponentCleanup, runLifecycle } from \"~/life-cycle\";\nimport { isNil } from \"~/util\";\n\n/**\n * patch the old nodes with the new nodes\n *\n * @param parentNode - The parent node.\n * @param oldNodes - The old nodes.\n * @param newNodes - The new nodes.\n */\nexport function patch(\n  parentNode: Node,\n  oldNodes: (ChildNode | undefined)[],\n  newNodes: (ChildNode | undefined)[],\n  insertBeforeNode?: Node,\n) {\n  const maxLength = Math.max(oldNodes.length, newNodes.length);\n\n  for (let i = 0; i < maxLength; i++) {\n    const oldNode = oldNodes[i];\n    const newNode = newNodes[i];\n\n    // Add new node\n    if (isNil(oldNode) && !isNil(newNode)) {\n      if (insertBeforeNode) {\n        parentNode.insertBefore(newNode, insertBeforeNode);\n      } else {\n        parentNode.appendChild(newNode);\n      }\n      runLifecycle(newNode);\n      oldNodes[i] = newNode;\n      continue;\n    }\n\n    // Remove old node\n    if (!isNil(oldNode) && isNil(newNode)) {\n      runComponentCleanup(oldNode);\n      parentNode.removeChild(oldNode);\n      oldNodes[i] = undefined;\n      continue;\n    }\n\n    // If both empty, continue to next iteration\n    if (isNil(oldNode) && isNil(newNode)) {\n      continue;\n    }\n\n    if (oldNode && newNode) {\n      runComponentCleanup(oldNode);\n      runLifecycle(newNode);\n      oldNode.replaceWith(newNode);\n      oldNodes[i] = newNode;\n      continue;\n    }\n\n    console.warn(`[veltra]: warning - unknown dom detected: `, {\n      old: oldNode,\n      new: newNode,\n    });\n  }\n\n  return [...oldNodes];\n}\n","import { Suspense } from \"../suspense\";\n\nconst IGNORE_COMPONENT = [Suspense] as Array<(...args: any[]) => any>;\n\n/**\n * resolve the component props\n *\n * @param type - The type of the component.\n * @param props - The properties of the component.\n */\nexport function resolveComponentProps(type: (...args: any[]) => any, props: Record<string, any>) {\n  if (IGNORE_COMPONENT.includes(type)) return;\n\n  for (const key in props) {\n    props[key] = props[key] instanceof Function ? props[key]() : props[key];\n  }\n}\n","import { componentLifecycleContexts, createLifeCycleContext } from \"~/life-cycle\";\nimport { untrack } from \"~/reactivity\";\nimport { toArray } from \"~/util\";\n\nimport { resolveComponentProps } from \"./resolve-component-props\";\n\nexport const componentRootNodes = new Set<Node>();\n\n/**\n * mount a component\n *\n * @param type - The type of the component.\n * @param props - The properties of the component.\n * @param children - The children of the component.\n */\nexport function mountComponent(\n  type: (props: Record<string, any>) => any,\n  { key: _key, ...props }: { key?: () => string } & Record<string, any>,\n  children: JSX.Element[],\n) {\n  const key = _key?.();\n\n  resolveComponentProps(type, props);\n\n  const context = createLifeCycleContext(type, key);\n\n  const targetNode = document.createTextNode(\"\");\n  componentRootNodes.add(targetNode);\n\n  const node = toArray(untrack(() => type({ ...props, children })));\n\n  componentLifecycleContexts.set(targetNode, context);\n  // runLifecycle(context, targetNode);\n\n  node.unshift(targetNode);\n  return node;\n}\n","import { onMount } from \"~/life-cycle\";\n\nimport { componentRootNodes } from \"./mount-component\";\nimport { renderChildren } from \"./render-children\";\n\nconst suspenseHandlerList: ((promise: Promise<void>) => void)[] = [];\n\n/**\n * Suspense component\n *\n * @param props - The props of the component.\n * @returns The root node of the component.\n */\nexport function Suspense(props: { fallback?: JSX.Element; children: JSX.Element }) {\n  const rootNode = document.createTextNode(\"\");\n  componentRootNodes.add(rootNode);\n\n  const {\n    fallback,\n    children: [children],\n  } = props as unknown as {\n    fallback?: () => JSX.Element;\n    children: [() => JSX.Element[]];\n  };\n\n  onMount(() => {\n    const parentNode = rootNode.parentNode;\n\n    if (!parentNode) return;\n\n    const cleanups: (() => void)[] = [];\n\n    const withSuspenseRender = (items: JSX.Element) => {\n      suspenseHandlerList.push(handler);\n      cleanups.push(renderChildren(parentNode, [items], rootNode));\n      suspenseHandlerList.pop();\n    };\n\n    const handler = (promise: Promise<void>) => {\n      queueMicrotask(() => {\n        cleanups.forEach((cleanup) => cleanup());\n\n        if (fallback) withSuspenseRender(fallback);\n      });\n\n      promise.then(() => {\n        cleanups.forEach((cleanup) => cleanup());\n\n        withSuspenseRender(children);\n      });\n    };\n\n    withSuspenseRender(children);\n  });\n\n  return rootNode;\n}\n\nexport function getCurrentSuspenseHandler() {\n  return suspenseHandlerList[suspenseHandlerList.length - 1] as\n    | ((promise: Promise<void>) => void)\n    | undefined;\n}\n","import { effect } from \"~/reactivity\";\nimport { getNode, toArray } from \"~/util\";\n\nimport { getCurrentSuspenseHandler } from \"../suspense\";\nimport { patch } from \"./patch\";\n\n/**\n * render the children\n *\n * @param parentNode - The parent node.\n * @param children - The children to render.\n */\nexport function renderChildren(parentNode: Node, children: JSX.Element[], baseAnchor?: Node) {\n  const cleanups: Record<\"disposer\" | \"oldNodes\", (() => void)[]> = {\n    disposer: [],\n    oldNodes: [],\n  };\n\n  for (const child of children) {\n    const anchor = document.createTextNode(\"\");\n    parentNode.insertBefore(anchor, baseAnchor ?? null); // insert before main anchor\n\n    let oldNodes: (ChildNode | undefined)[] = [];\n    const handler = getCurrentSuspenseHandler();\n\n    const run = () => {\n      const disposer = effect(() => {\n        // let result: JSX.Element;\n        let newNodes: (ChildNode | undefined)[] = [];\n\n        try {\n          // result = typeof child === \"function\" ? child() : child;\n          newNodes = toArray(getNode(child)) as ChildNode[];\n        } catch (error) {\n          if (error instanceof Promise) {\n            if (handler) {\n              handler(error);\n            } else {\n              error.then(() => {\n                disposer();\n                run();\n              });\n            }\n          } else {\n            throw error;\n          }\n        }\n\n        oldNodes = patch(parentNode, oldNodes, newNodes, anchor);\n\n        cleanups.oldNodes.push(() => {\n          patch(parentNode, oldNodes, [], baseAnchor);\n        });\n      });\n\n      cleanups.disposer.push(() => {\n        disposer();\n      });\n    };\n\n    run();\n  }\n\n  return () => {\n    cleanups.disposer.forEach((cleanup) => cleanup());\n    cleanups.oldNodes.forEach((cleanup) => cleanup());\n  };\n}\n","/**\n * Create a fragment\n *\n * @param children - The children of the fragment.\n * @returns The fragment.\n */\nexport function Fragment({ children }: { children: JSX.Element[] }) {\n  return children;\n}\n","export const SVG_TAGS = new Set([\n  \"a\",\n  \"animate\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"defs\",\n  \"desc\",\n  \"discard\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"foreignObject\",\n  \"g\",\n  \"hatch\",\n  \"hatchpath\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"mesh\",\n  \"meshgradient\",\n  \"meshpatch\",\n  \"meshrow\",\n  \"metadata\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"script\",\n  \"set\",\n  \"solidcolor\",\n  \"stop\",\n  \"style\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"title\",\n  \"tref\",\n  \"tspan\",\n  \"unknown\",\n  \"use\",\n  \"view\",\n]);\n\nexport const MATH_ML_TAGS = new Set([\n  \"math\",\n  \"maction\",\n  \"maligngroup\",\n  \"malignmark\",\n  \"menclose\",\n  \"merror\",\n  \"mfenced\",\n  \"mfrac\",\n  \"mglyph\",\n  \"mi\",\n  \"mlabeledtr\",\n  \"mmultiscripts\",\n  \"mn\",\n  \"mo\",\n  \"mover\",\n  \"mpadded\",\n  \"mphantom\",\n  \"mroot\",\n  \"mrow\",\n  \"ms\",\n  \"mscarries\",\n  \"mscarry\",\n  \"msgroup\",\n  \"mstack\",\n  \"mstyle\",\n  \"msub\",\n  \"msubsup\",\n  \"msup\",\n  \"mtable\",\n  \"mtd\",\n  \"mtext\",\n  \"mtr\",\n  \"munder\",\n  \"munderover\",\n  \"semantics\",\n  \"annotation\",\n  \"annotation-xml\",\n]);\n","export const UNIT_LESS_PROPS = [\n  \"animationIterationCount\",\n  \"borderImageOutset\",\n  \"borderImageSlice\",\n  \"borderImageWidth\",\n  \"boxFlex\",\n  \"boxFlexGroup\",\n  \"boxOrdinalGroup\",\n  \"columnCount\",\n  \"flex\",\n  \"flexGrow\",\n  \"flexPositive\",\n  \"flexShrink\",\n  \"flexNegative\",\n  \"flexOrder\",\n  \"gridRow\",\n  \"gridColumn\",\n  \"fontWeight\",\n  \"lineClamp\",\n  \"lineHeight\",\n  \"opacity\",\n  \"order\",\n  \"orphans\",\n  \"tabSize\",\n  \"widows\",\n  \"zIndex\",\n  \"zoom\",\n  \"fillOpacity\",\n  \"floodOpacity\",\n  \"stopOpacity\",\n  \"strokeDasharray\",\n  \"strokeDashoffset\",\n  \"strokeMiterlimit\",\n  \"strokeOpacity\",\n  \"strokeWidth\",\n];\n","export * from \"./element-tags\";\nexport * from \"./unit-less-props\";\nexport const IS_SSR = typeof document === \"undefined\";\n","import \"./jsx.d.ts\";\n\nimport { IS_SSR } from \"./const\";\nimport { Fragment, h, hSSR } from \"./render\";\nimport { toArray } from \"./util\";\n\n/**\n * jsx runtime\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element.\n */\nconst jsx = (\n  type: string | ((props: any) => any),\n  { children = [], ...props }: Record<string, any>,\n  key?: () => string,\n) => {\n  if (IS_SSR) {\n    return hSSR(type, props, toArray(children));\n  }\n\n  return h(type, props, toArray(children), key);\n};\n\nexport { Fragment, jsx, jsx as jsxs };\n","type EventHandlerMap = Map<string, EventListener>;\n\nconst eventRegistry = new WeakMap<HTMLElement, EventHandlerMap>();\n\n/**\n * Add an event listener\n *\n * @param element - The element to add the event listener to.\n * @param type - The type of event to listen for.\n * @param listener - The event listener function.\n */\nexport function addEventListener(element: HTMLElement, type: string, listener: EventListener) {\n  let handlers = eventRegistry.get(element);\n\n  if (!handlers) {\n    handlers = new Map();\n    eventRegistry.set(element, handlers);\n  }\n\n  // Remove old listener if any\n  if (handlers.has(type)) {\n    element.removeEventListener(type, handlers.get(type)!);\n  }\n\n  element.addEventListener(type, listener);\n  handlers.set(type, listener);\n}\n\n/**\n * Remove an event listener\n *\n * @param element - The element to remove the event listener from.\n * @param type - The type of event to remove.\n */\nexport function removeEventListener(element: HTMLElement, type: string) {\n  const handlers = eventRegistry.get(element);\n  if (!handlers) return;\n\n  const listener = handlers.get(type);\n  if (listener) {\n    element.removeEventListener(type, listener);\n    handlers.delete(type); // Remove it from the map\n  }\n\n  // Clean up if no handlers left\n  if (handlers.size === 0) {\n    eventRegistry.delete(element);\n  }\n}\n\n/**\n * Copy event listeners from one element to another\n *\n * @param from - The element to copy the event listeners from.\n * @param to - The element to copy the event listeners to.\n */\nexport function copyEventListeners(from: HTMLElement, to: HTMLElement) {\n  const handlers = eventRegistry.get(from);\n  if (!handlers) return;\n\n  handlers.forEach((listener, type) => {\n    removeEventListener(to, type);\n    addEventListener(to, type, listener);\n  });\n}\n\n/**\n * Remove all event listeners from an element\n *\n * @param element - The element to remove the event listeners from.\n */\nexport function removeEventListeners(element: HTMLElement) {\n  const handlers = eventRegistry.get(element);\n  if (!handlers) return;\n\n  handlers.forEach((listener, type) => {\n    element.removeEventListener(type, listener);\n  });\n\n  eventRegistry.delete(element);\n}\n","import { UNIT_LESS_PROPS } from \"~/const\";\n\nimport { effect } from \"../reactivity\";\nimport { addEventListener, removeEventListener } from \"./event-registry\";\n\n/**\n * apply the properties to the element\n *\n * @param element - The element to apply the properties to.\n * @param props - The properties to apply.\n */\nexport function applyProps(element: HTMLElement, props: Record<string, any>) {\n  for (const key in props) {\n    if (key.startsWith(\"on\") && typeof props[key] === \"function\") {\n      const type = key.slice(2).toLowerCase();\n      let cleanup: () => void;\n\n      effect(() => {\n        // Remove the previous listener if there was one\n        if (cleanup) cleanup();\n\n        const fn = props[key]();\n        if (typeof fn === \"function\") {\n          addEventListener(element, type, fn);\n          // Setup cleanup for next effect run\n          cleanup = () => removeEventListener(element, type);\n        }\n      });\n    } else {\n      const run = () => {\n        const value = typeof props[key] === \"function\" ? props[key]() : props[key];\n\n        if (key === \"ref\" && typeof value === \"function\") {\n          value(element);\n        } else if (key === \"style\") {\n          applyStyle(element, value);\n        } else if (key === \"disabled\") {\n          element.toggleAttribute(key, value);\n        } else {\n          element.setAttribute(key, value);\n        }\n      };\n      effect(() => {\n        try {\n          run();\n        } catch (error) {\n          if (error instanceof Promise) {\n            error.then(run);\n          } else {\n            throw error;\n          }\n        }\n      });\n    }\n  }\n}\n\n/**\n * apply the style to the element\n *\n * @param element - The element to apply the style to.\n * @param style - The style to apply.\n */\nfunction applyStyle(element: HTMLElement, style: Record<string, any>) {\n  if (!(element instanceof HTMLElement)) return;\n\n  for (const [key, value] of Object.entries(style)) {\n    const cssKey = key as keyof CSSStyleDeclaration;\n    if (cssKey === \"length\" || cssKey === \"parentRule\") continue;\n\n    const isNumber = typeof value === \"number\";\n    const needsUnit = isNumber && !isUnitLessCSSProperty(key);\n    const finalValue = needsUnit ? `${value}px` : String(value);\n\n    element.style.setProperty(String(cssKey), finalValue);\n  }\n}\n\n/**\n * check if a property is a unit less CSS property\n *\n * @param prop - The property to check.\n * @returns True if the property is a unit less CSS property.\n */\nfunction isUnitLessCSSProperty(prop: string): boolean {\n  const unitLessProps = new Set(UNIT_LESS_PROPS);\n\n  return unitLessProps.has(prop);\n}\n","import { MATH_ML_TAGS, SVG_TAGS } from \"~/const\";\nimport { Fragment } from \"~/jsx-runtime\";\n\nimport { applyProps } from \"./apply-props\";\nimport { mountComponent } from \"./mount-component\";\nimport { renderChildren } from \"./render-children\";\n\n/**\n * create a JSX element\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element.\n */\nexport function h(\n  type: string | ((props: Record<string, any>) => any),\n  props: Record<string, any>,\n  children: JSX.Element[],\n  key?: () => string,\n) {\n  if (type === Fragment) {\n    return children;\n  }\n\n  if (typeof type === \"function\") {\n    return mountComponent(type, { key, ...props }, children);\n  }\n\n  const element = createElement(type, props.xmlns);\n\n  applyProps(element, props);\n  renderChildren(element, children);\n\n  return element;\n}\n\nfunction createElement(tag: string, namespace?: string) {\n  if ((SVG_TAGS.has(tag) || MATH_ML_TAGS.has(tag)) && namespace) {\n    return document.createElementNS(namespace, tag) as HTMLElement;\n  }\n\n  return document.createElement(tag);\n}\n","/**\n * Create a JSX element for SSR\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element for SSR.\n */\nexport function hSSR(\n  type: string | ((props: Record<string, any>) => any),\n  props: Record<string, any>,\n  children: JSX.Element[],\n) {\n  if (typeof type === \"function\") {\n    return type({ ...props, children });\n  }\n\n  return `<${type} ${handlePropsSSR(props)}>${handleChildrenSSR(children)}</${type}>`;\n}\n\n/**\n * Handle the properties of the element for SSR\n *\n * @param props - The properties of the element.\n * @returns The transformed properties.\n */\nfunction handlePropsSSR(props: Record<string, any>) {\n  const transformedProps: string[] = [];\n\n  for (const key in props) {\n    if (key.startsWith(\"on\") && typeof props[key] === \"function\") {\n      continue;\n    }\n\n    const value = typeof props[key] === \"function\" ? props[key]() : props[key];\n\n    if (key === \"ref\" && typeof value === \"function\") {\n      // value($element);\n    } else if (key === \"style\") {\n      // applyStyle($element, value);\n    } else if (key === \"disabled\" && value) {\n      transformedProps.push(\"disabled\");\n    } else {\n      transformedProps.push(`${key}=\"${value}\"`);\n    }\n  }\n\n  return transformedProps.join(\" \");\n}\n\n/**\n * Handle the children of the element for SSR\n *\n * @param children - The children of the element.\n * @returns The transformed children.\n */\nfunction handleChildrenSSR(children: JSX.Element[]) {\n  const transformedChildren: string[] = [];\n\n  for (const child of children) {\n    if (typeof child === \"function\") {\n      transformedChildren.push(String(child()));\n    } else if (Array.isArray(child)) {\n      // RECURSIVELY flatten nested arrays\n      child.forEach((nested) => transformedChildren.push(handleChildrenSSR([nested])));\n    } else {\n      transformedChildren.push(child as string);\n    }\n  }\n\n  return transformedChildren.join(\"\");\n}\n"],"names":["cleanupMap","setComponentCleanup","node","cleanups","runComponentCleanup","cleanup","destroyContext","setDestroyContext","newDestroyContext","effectContext","setEffectContext","newEffectContext","mountContext","setMountContext","newMountStack","stateContext","setStateContext","newStateContext","stateMap","createStateContext","type","key","instance","typeMap","createLifeCycleContext","context","onMount","fn","activeEffect","setActiveEffect","newActiveEffect","lastDisposer","effect","wrappedEffect","removeEffect","previousEffect","disposer","stopEffect","depSet","untrack","prevEffect","componentLifecycleContexts","runLifecycle","targetNode","c","isNil","value","getNode","jsxElement","toArray","item","patch","parentNode","oldNodes","newNodes","insertBeforeNode","maxLength","i","oldNode","newNode","IGNORE_COMPONENT","Suspense","resolveComponentProps","props","componentRootNodes","mountComponent","_key","children","suspenseHandlerList","rootNode","fallback","withSuspenseRender","items","handler","renderChildren","promise","getCurrentSuspenseHandler","baseAnchor","child","anchor","run","error","Fragment","SVG_TAGS","MATH_ML_TAGS","UNIT_LESS_PROPS","IS_SSR","jsx","hSSR","h","eventRegistry","addEventListener","element","listener","handlers","removeEventListener","applyProps","applyStyle","style","cssKey","finalValue","isUnitLessCSSProperty","prop","createElement","tag","namespace","handlePropsSSR","handleChildrenSSR","transformedProps","transformedChildren","nested"],"mappings":"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hB,MAAM5C,EAAWJ,EAAO,IAAM,CAE5B,IAAIsB,EAAsC,GAE1C,GAAI,CAEFA,EAAWL,EAAQF,EAAQ+B,CAAK,CAAC,CACnC,OAASG,EAAO,CACd,GAAIA,aAAiB,QACfR,EACFA,EAAQQ,CAAK,EAEbA,EAAM,KAAK,IAAM,CACf7C,EAAAA,EACA4C,EAAI,CACN,CAAC,aAGGC,CAEV,CAEA5B,EAAWF,EAAMC,EAAYC,EAAUC,EAAUyB,CAAM,EAEvD5E,EAAS,SAAS,KAAK,IAAM,CAC3BgD,EAAMC,EAAYC,EAAU,CAAC,EAAGwB,CAAU,CAC5C,CAAC,CACH,CAAC,EAED1E,EAAS,SAAS,KAAK,IAAM,CAC3BiC,GACF,CAAC,CACH,EAEA4C,EACF,CAAA,CAEA,MAAO,IAAM,CACX7E,EAAS,SAAS,QAASE,GAAYA,EAAQ,CAAC,EAChDF,EAAS,SAAS,QAASE,GAAYA,EAAS,CAAA,CAClD,CACF,CC7DO,SAAS6E,EAAS,CAAE,SAAAf,CAAS,EAAgC,CAClE,OAAOA,CACT,CCRa,MAAAgB,EAAW,IAAI,IAAI,CAC9B,IACA,UACA,gBACA,mBACA,SACA,WACA,OACA,OACA,UACA,UACA,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,eACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,eACA,SACA,gBACA,IACA,QACA,YACA,QACA,OACA,iBACA,SACA,OACA,OACA,eACA,YACA,UACA,WACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,SACA,MACA,aACA,OACA,QACA,MACA,SACA,SACA,OACA,WACA,QACA,OACA,QACA,UACA,MACA,MACF,CAAC,EAEYC,EAAe,IAAI,IAAI,CAClC,OACA,UACA,cACA,aACA,WACA,SACA,UACA,QACA,SACA,KACA,aACA,gBACA,KACA,KACA,QACA,UACA,WACA,QACA,OACA,KACA,YACA,UACA,UACA,SACA,SACA,OACA,UACA,OACA,SACA,MACA,QACA,MACA,SACA,aACA,YACA,aACA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"}