{"version":3,"file":"index.js","sources":["../../../veltra-app/src/const/index.ts","../../../veltra-app/src/render/render-children/patch.ts","../../../veltra-app/src/render/render-children/suspense-effect.ts","../../../veltra-app/src/render/render-children/render-children.ts","../../../veltra-app/src/render/fragment.ts","../../../veltra-app/src/reactivity/effect.ts","../../../veltra-app/src/render/apply-props.ts","../../../veltra-app/src/render/suspense.ts","../../../veltra-app/src/render/mount-component/resolve-component-props.ts","../../../veltra-app/src/render/mount-component/mount-component.ts","../../../veltra-app/src/render/h.ts","../../../veltra-app/src/render/ssr.ts","../../../veltra-app/src/util/to-array.ts","../../../veltra-app/src/jsx-runtime.ts","../../src/index.tsx"],"sourcesContent":["export * from \"./element-tags\";\nexport * from \"./unit-less-props\";\nexport const IS_SSR = typeof document === \"undefined\";\n","import { runComponentCleanup } from \"~/life-cycle\";\nimport { isNil } from \"~/util\";\n\n/**\n * patch the old nodes with the new nodes\n *\n * @param $parent - The parent node.\n * @param $oldNodes - The old nodes.\n * @param $newNodes - The new nodes.\n * @param isFirstRender - Whether it is the first render.\n */\nexport function patch(\n  $parent: Node,\n  $oldNodes: Node[],\n  $newNodes: (Node | undefined)[],\n  isFirstRender: boolean,\n) {\n  const maxLength = Math.max($oldNodes.length, $newNodes.length);\n\n  for (let i = 0; i < maxLength; i++) {\n    const $oldNode = $oldNodes[i];\n    const $newNode = $newNodes[i];\n\n    if (isFirstRender) {\n      if (isNil($newNode)) continue;\n\n      $parent.appendChild($newNode);\n      $oldNodes[i] = $newNode;\n\n      continue;\n    }\n\n    // Add new node\n    if (isNil($oldNode) && !isNil($newNode)) {\n      $parent.appendChild($newNode);\n      $oldNodes[i] = $newNode;\n      continue;\n    }\n\n    // Remove old node\n    if (!isNil($oldNode) && isNil($newNode)) {\n      runComponentCleanup($oldNode);\n      $parent.removeChild($oldNodes[i]);\n      $oldNodes.splice(i, 1);\n      i--;\n      continue;\n    }\n\n    // If both empty, continue to next iteration\n    if (isNil($oldNode) && isNil($newNode)) {\n      continue;\n    }\n\n    if ($oldNode && $newNode) {\n      // Replace node with node\n      if (!$oldNode.isSameNode($newNode)) {\n        runComponentCleanup($oldNode);\n        ($oldNode as ChildNode).replaceWith($newNode);\n        $oldNodes[i] = $newNode;\n      }\n      continue;\n    }\n\n    console.warn(`[veltra]: warning - unknown dom detected: `, {\n      old: $oldNode,\n      new: $newNode,\n    });\n  }\n\n  return [...$oldNodes];\n}\n","import { effect } from \"~/reactivity\";\n\nexport function suspenseReactor(fn: () => void) {\n  let cleanup: (() => void) | null = null;\n\n  const run = () => {\n    if (cleanup) cleanup();\n\n    cleanup = effect(() => {\n      try {\n        fn();\n      } catch (e) {\n        if (e instanceof Promise) {\n          e.then(run).catch(console.error);\n        } else {\n          console.error(e);\n        }\n      }\n    });\n  };\n\n  run();\n}\n","import { getNode, toArray } from \"~/util\";\n\nimport { patch } from \"./patch\";\nimport { suspenseReactor } from \"./suspense-effect\";\n\n/**\n * render the children\n *\n * @param $parent - The parent node.\n * @param children - The children to render.\n * @param index - The index to insert the children at.\n */\nexport function renderChildren($parent: Node, children: JSX.Element[], index?: number) {\n  let insertBeforeNode: ChildNode | null = null;\n\n  if (index !== undefined) {\n    insertBeforeNode = $parent.childNodes[index] as ChildNode;\n  }\n\n  for (const $child of children) {\n    if (typeof $child === \"function\") {\n      let $oldNodes: Node[] = [];\n      let isFirstRender = true;\n\n      suspenseReactor(() => {\n        const $newNodes = toArray($child()).map(getNode).flat();\n        $oldNodes = patch($parent, $oldNodes, $newNodes, isFirstRender);\n        isFirstRender = false;\n      });\n    } else {\n      const $node = getNode($child);\n      if (!Array.isArray($node) && $node) {\n        if (insertBeforeNode) {\n          $parent.insertBefore($node, insertBeforeNode);\n        } else {\n          $parent.appendChild($node);\n        }\n      }\n    }\n  }\n}\n","export function Fragment({ children }: { children: JSX.Element[] }) {\n  return children;\n}\n","import { effectContext } from \"~/context\";\n\n// Effect function type with dependency tracking\nexport type EffectFn = (() => void) & { deps?: Set<EffectFn>[] };\n\n// Currently active effect (global context for dependency collection)\nexport let activeEffect: EffectFn | null = null;\n\nexport function setActiveEffect(newActiveEffect: EffectFn | null) {\n  activeEffect = newActiveEffect;\n}\n\nexport function effect(fn: () => void): () => void {\n  const wrappedEffect: EffectFn = () => {\n    removeEffect(wrappedEffect);\n\n    const previousEffect = activeEffect; // save previous activeEffect\n    activeEffect = wrappedEffect;\n\n    if (effectContext) {\n      effectContext.push(wrappedEffect); // keep your effectContext intact\n    }\n\n    try {\n      fn();\n    } finally {\n      activeEffect = previousEffect; // restore outer activeEffect\n    }\n  };\n\n  wrappedEffect.deps = [];\n  wrappedEffect();\n\n  return () => removeEffect(wrappedEffect);\n}\n\nexport function removeEffect(effect: EffectFn) {\n  if (effect.deps) {\n    for (const depSet of effect.deps) {\n      depSet.delete(effect); // Remove this effect from all dependency sets\n    }\n    effect.deps.length = 0; // Reset dependency list\n  }\n}\n","import { UNIT_LESS_PROPS } from \"~/const\";\n\nimport { effect as reactor } from \"../reactivity\";\n\n/**\n * apply the properties to the element\n *\n * @param $element - The element to apply the properties to.\n * @param props - The properties to apply.\n */\nexport function applyProps($element: HTMLElement | Element, props: Record<string, any>) {\n  for (const key in props) {\n    if (key.startsWith(\"on\") && typeof props[key] === \"function\") {\n      const type = key.slice(2).toLowerCase();\n      let cleanup: () => void;\n\n      reactor(() => {\n        // Remove the previous listener if there was one\n        if (cleanup) cleanup();\n\n        const fn = props[key]();\n        if (typeof fn === \"function\") {\n          $element.addEventListener(type, fn);\n          // Setup cleanup for next effect run\n          cleanup = () => $element.removeEventListener(type, fn);\n        }\n      });\n    } else {\n      reactor(() => {\n        const value = typeof props[key] === \"function\" ? props[key]() : props[key];\n\n        if (key === \"ref\" && typeof value === \"function\") {\n          value($element);\n        } else if (key === \"style\") {\n          applyStyle($element, value);\n        } else if (key === \"disabled\") {\n          $element.toggleAttribute(key, value);\n        } else {\n          $element.setAttribute(key, value);\n        }\n      });\n    }\n  }\n}\n\n/**\n * apply the style to the element\n *\n * @param $element - The element to apply the style to.\n * @param style - The style to apply.\n */\nfunction applyStyle($element: HTMLElement | Element, style: Record<string, any>) {\n  if (!($element instanceof HTMLElement)) return;\n\n  for (const [key, value] of Object.entries(style)) {\n    const cssKey = key as keyof CSSStyleDeclaration;\n    if (cssKey === \"length\" || cssKey === \"parentRule\") continue;\n\n    const isNumber = typeof value === \"number\";\n    const needsUnit = isNumber && !isUnitLessCSSProperty(key);\n    const finalValue = needsUnit ? `${value}px` : String(value);\n\n    $element.style.setProperty(String(cssKey), finalValue);\n  }\n}\n\n/**\n * check if a property is a unitless CSS property\n *\n * @param prop - The property to check.\n * @returns True if the property is a unitless CSS property.\n */\nfunction isUnitLessCSSProperty(prop: string): boolean {\n  const unitLessProps = new Set(UNIT_LESS_PROPS);\n\n  return unitLessProps.has(prop);\n}\n","import { effect, state } from \"~/reactivity\";\nimport { getNode, toArray } from \"~/util\";\n\nimport { patch } from \"./render-children/patch\";\n\nexport const suspensePromise = state<Promise<void> | null>(null);\n\n/**\n * create a suspense component\n *\n * @param props - The properties of the component.\n * @returns The suspense component.\n */\nexport function Suspense(props: { fallback: JSX.Element; children: JSX.Element }) {\n  const $rootNode = document.createTextNode(\"\");\n  let $parent: Node;\n\n  // Change types since this is transformed by babel\n  const {\n    fallback: _fallback,\n    children: [children],\n  } = props as unknown as {\n    fallback: () => JSX.Element;\n    children: [() => JSX.Element[]];\n  };\n\n  const fallback = _fallback() as Node;\n\n  let isFirstRender = true;\n  let $oldNodes: Node[] = [];\n\n  const renderFallback = () => {\n    $oldNodes = patch($parent, $oldNodes, getNodes(fallback), isFirstRender);\n    isFirstRender = false;\n  };\n\n  const renderSuspenseChildren = () => {\n    const $newNodes = getNodes(children()).flat() as Node[];\n    $oldNodes = patch($parent, $oldNodes, $newNodes, isFirstRender);\n  };\n\n  queueMicrotask(() => {\n    $parent = $rootNode.parentNode as Node;\n\n    effect(() => {\n      try {\n        if (!$parent) return;\n        renderFallback();\n\n        if (suspensePromise.value) throw suspensePromise.value;\n\n        renderSuspenseChildren();\n      } catch (errorOrPromise) {\n        if (errorOrPromise instanceof Promise) {\n          errorOrPromise\n            .then(() => {\n              suspensePromise.value = null;\n              renderSuspenseChildren();\n            })\n            .catch(() => {});\n        } else {\n          throw errorOrPromise;\n        }\n      }\n    });\n  });\n\n  // initial render is fallback node\n  return $rootNode;\n}\n\nconst getNodes = <T extends JSX.Element | Node>(items: T) => {\n  const results: T[] = [];\n  const flatItems = toArray(items);\n\n  for (const item of flatItems) {\n    const node = getNode(item); // Throws here if resource.value is pending\n    if (Array.isArray(node)) {\n      results.push(...(node as T[]));\n    } else {\n      results.push(node as T);\n    }\n  }\n\n  return results;\n};\n","import { Suspense } from \"../suspense\";\n\nconst IGNORE_COMPONENT = [Suspense] as Array<(...args: any[]) => any>;\n\n/**\n * resolve the component props\n *\n * @param type - The type of the component.\n * @param props - The properties of the component.\n */\nexport function resolveComponentProps(type: (...args: any[]) => any, props: Record<string, any>) {\n  if (IGNORE_COMPONENT.includes(type)) return;\n\n  for (const key in props) {\n    props[key] = props[key] instanceof Function ? props[key]() : props[key];\n  }\n}\n","import { initializeLifecycleContext, LifecycleContext, registerLifeCycles } from \"~/life-cycle\";\nimport { untrack } from \"~/reactivity\";\n\nimport { resolveComponentProps } from \"./resolve-component-props\";\n\nexport const componentRootNodes = new Set<Node>();\n\n/**\n * mount a component\n *\n * @param type - The type of the component.\n * @param props - The properties of the component.\n * @param children - The children of the component.\n */\nexport function mountComponent(\n  type: (props: Record<string, any>) => any,\n  props: Record<string, any>,\n  children: JSX.Element[],\n) {\n  resolveComponentProps(type, props);\n\n  const lifecycleContext: LifecycleContext = {\n    mount: [],\n    effect: [],\n    destroy: [],\n  };\n\n  initializeLifecycleContext(lifecycleContext);\n\n  const $node = untrack(() => type({ ...props, children }));\n  let $target = $node;\n\n  if (Array.isArray($node)) {\n    $target = document.createTextNode(\"\");\n    $node.unshift($target);\n  }\n\n  registerLifeCycles(lifecycleContext, $target);\n\n  componentRootNodes.add($target);\n  return $node;\n}\n","import { MATH_ML_TAGS, SVG_TAGS } from \"~/const\";\nimport { Fragment } from \"~/jsx-runtime\";\n\nimport { applyProps } from \"./apply-props\";\nimport { mountComponent } from \"./mount-component\";\nimport { renderChildren } from \"./render-children\";\n\n/**\n * create a JSX element\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element.\n */\nexport function h(\n  type: string | ((props: Record<string, any>) => any),\n  props: Record<string, any>,\n  children: JSX.Element[],\n) {\n  if (type === Fragment) {\n    return children;\n  }\n\n  if (typeof type === \"function\") {\n    return mountComponent(type, props, children);\n  }\n\n  const $element = createElement(type, props.xmlns);\n\n  applyProps($element, props);\n  renderChildren($element, children);\n\n  return $element;\n}\n\nfunction createElement(tag: string, namespace?: string) {\n  if ((SVG_TAGS.has(tag) || MATH_ML_TAGS.has(tag)) && namespace) {\n    return document.createElementNS(namespace, tag);\n  }\n\n  return document.createElement(tag);\n}\n","export function hSSR(\n  type: string | ((props: Record<string, any>) => any),\n  props: Record<string, any>,\n  children: JSX.Element[],\n) {\n  if (typeof type === \"function\") {\n    return type({ ...props, children });\n  }\n\n  return `<${type} ${handlePropsSSR(props)}>${handleChildrenSSR(children)}</${type}>`;\n}\n\nfunction handlePropsSSR(props: Record<string, any>) {\n  const transformedProps: string[] = [];\n\n  for (const key in props) {\n    if (key.startsWith(\"on\") && typeof props[key] === \"function\") {\n      continue;\n    }\n\n    const value = typeof props[key] === \"function\" ? props[key]() : props[key];\n\n    if (key === \"ref\" && typeof value === \"function\") {\n      // value($element);\n    } else if (key === \"style\") {\n      // applyStyle($element, value);\n    } else if (key === \"disabled\" && value) {\n      transformedProps.push(\"disabled\");\n    } else {\n      transformedProps.push(`${key}=\"${value}\"`);\n    }\n  }\n\n  return transformedProps.join(\" \");\n}\n\nfunction handleChildrenSSR(children: JSX.Element[]) {\n  const transformedChildren: string[] = [];\n\n  for (const child of children) {\n    if (typeof child === \"function\") {\n      transformedChildren.push(String(child()));\n    } else if (Array.isArray(child)) {\n      // RECURSIVELY flatten nested arrays\n      child.forEach((nested) => transformedChildren.push(handleChildrenSSR([nested])));\n    } else {\n      // console.log(child);\n      transformedChildren.push(child as string);\n      // return child\n      // const childRef = getNode(child) as Node;\n\n      // $parent.appendChild(childRef);\n      // mountSpecialComponent(childRef);\n    }\n  }\n\n  return transformedChildren.join(\"\");\n}\n","/**\n * convert an item to an array\n *\n * @param item - The item to convert to an array.\n * @returns The item as an array.\n */\nexport const toArray = <T>(item: T) => {\n  return (Array.isArray(item) ? item : [item]).flat(Infinity) as T[];\n};\n","/// <reference path=\"./jsx.d.ts\" />\n\nimport { IS_SSR } from \"./const\";\nimport { Fragment, h, hSSR } from \"./render\";\nimport { toArray } from \"./util\";\n\n/**\n * jsx runtime\n *\n * @param type - The type of the element.\n * @param props - The properties of the element.\n * @param children - The children of the element.\n * @returns The JSX element.\n */\nconst jsx = (\n  type: string | ((props: Record<string, any>) => any),\n  { children = [], ...props }: Record<string, any>,\n) => {\n  if (IS_SSR) {\n    return hSSR(type, props, toArray(children));\n  }\n\n  return h(type, props, toArray(children));\n};\n\nexport { Fragment, jsx, jsx as jsxs };\n","import { effect, state } from \"@veltra/app\";\n\nexport type Route = {\n  path: string;\n  component: () => JSX.Element;\n  children?: Route[];\n  guard?: () => boolean;\n  lazy?: () => Promise<{ default: () => JSX.Element }>;\n};\n\nexport type Location = {\n  pathname: string;\n  search: string;\n};\n\nexport const location = state<Location>({\n  pathname: window.location.pathname,\n  search: window.location.search,\n});\n\nwindow.addEventListener(\"popstate\", () => {\n  location.value = {\n    ...location.value,\n    pathname: window.location.pathname,\n  };\n});\n\n/**\n * navigate to a path\n *\n * @param path - The path to navigate to.\n */\nexport function navigate(path: string) {\n  history.pushState(null, \"\", path);\n  location.value = {\n    ...location.value,\n    pathname: path,\n  };\n}\n\nfunction matchRoute(path: string, routes: Route[]): Route | undefined {\n  for (const route of routes) {\n    if (route.path === path) return route;\n    if (route.children) {\n      const child = matchRoute(path, route.children);\n      if (child) return child;\n    }\n  }\n  return undefined;\n}\n\n/**\n * create a router\n *\n * @param props - The properties of the router.\n * @returns The router.\n */\nexport function Router(props: { routes: Route[] }) {\n  const current = state<() => JSX.Element>(() => <></>);\n\n  effect(() => {\n    const matched = matchRoute(location.value.pathname, props.routes);\n    if (matched) {\n      if (matched.guard && !matched.guard()) {\n        current.value = () => <div>Access Denied</div>;\n        return;\n      }\n      if (matched.lazy) {\n        matched.lazy().then((mod) => {\n          current.value = mod.default;\n        });\n        return;\n      }\n      current.value = matched.component;\n    } else {\n      current.value = () => <div>404 Not Found</div>;\n    }\n  });\n\n  return () => {\n    return <>{current.value()}</>;\n  };\n}\n"],"names":["IS_SSR","patch","$parent","$oldNodes","$newNodes","isFirstRender","maxLength","i","$oldNode","$newNode","isNil","runComponentCleanup","suspenseReactor","fn","cleanup","run","effect","e","renderChildren","children","index","$child","toArray","getNode","$node","Fragment","wrappedEffect","removeEffect","effectContext","depSet","applyProps","$element","props","key","type","reactor","value","applyStyle","style","cssKey","finalValue","isUnitLessCSSProperty","prop","UNIT_LESS_PROPS","suspensePromise","state","Suspense","$rootNode","_fallback","fallback","renderFallback","getNodes","renderSuspenseChildren","errorOrPromise","items","results","flatItems","item","node","IGNORE_COMPONENT","resolveComponentProps","componentRootNodes","mountComponent","lifecycleContext","initializeLifecycleContext","untrack","$target","registerLifeCycles","h","createElement","tag","namespace","SVG_TAGS","MATH_ML_TAGS","hSSR","handlePropsSSR","handleChildrenSSR","transformedProps","transformedChildren","child","nested","jsx","location","navigate","path","matchRoute","routes","route","Router","current","matched","mod"],"mappings":"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"}